<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Text Formatter & Doc Exporter</title>
    <script src="https://unpkg.com/docx@8.5.0/build/index.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e0e0e0;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5rem;
            background: linear-gradient(90deg, #ff6b6b, #feca57, #48dbfb);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #888;
            font-size: 1.1rem;
        }

        .mode-toggle {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .mode-btn {
            padding: 10px 25px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.05);
            color: #e0e0e0;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #ff6b6b, #feca57);
            border-color: transparent;
            color: #1a1a2e;
            font-weight: bold;
        }

        .mode-btn:hover:not(.active) {
            background: rgba(255, 255, 255, 0.1);
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .panel-title {
            font-size: 1.2rem;
            color: #48dbfb;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .panel-title svg {
            width: 24px;
            height: 24px;
        }

        textarea {
            width: 100%;
            height: 450px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 15px;
            color: #e0e0e0;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            resize: vertical;
            transition: border-color 0.3s;
        }

        textarea:focus {
            outline: none;
            border-color: #48dbfb;
        }

        textarea::placeholder {
            color: #666;
        }

        .preview-area {
            width: 100%;
            min-height: 450px;
            background: #ffffff;
            border-radius: 12px;
            padding: 30px;
            color: #333;
            overflow-y: auto;
            max-height: 600px;
        }

        .preview-area h1 {
            font-size: 1.8rem;
            color: #1a1a2e;
            -webkit-text-fill-color: #1a1a2e;
            margin-bottom: 15px;
            border-bottom: 2px solid #ff6b6b;
            padding-bottom: 10px;
        }

        .preview-area h2 {
            font-size: 1.4rem;
            color: #16213e;
            margin: 20px 0 10px 0;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }

        .preview-area h3 {
            font-size: 1.2rem;
            color: #0f3460;
            margin: 15px 0 8px 0;
        }

        .preview-area p {
            margin-bottom: 12px;
            line-height: 1.7;
            text-align: justify;
        }

        .preview-area .code-block {
            background: #1e1e1e;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            overflow-x: auto;
            border-left: 4px solid #ff6b6b;
        }

        .preview-area .code-block pre {
            margin: 0;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            color: #d4d4d4;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .preview-area .code-block .lang-label {
            display: inline-block;
            background: #ff6b6b;
            color: #fff;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            margin-bottom: 10px;
            font-weight: bold;
            text-transform: uppercase;
        }

        .preview-area .inline-code {
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
            color: #d63384;
        }

        .preview-area ul, .preview-area ol {
            margin: 10px 0 10px 25px;
        }

        .preview-area li {
            margin-bottom: 5px;
            line-height: 1.6;
        }

        .preview-area blockquote {
            border-left: 4px solid #feca57;
            padding-left: 15px;
            margin: 15px 0;
            color: #666;
            font-style: italic;
            background: #fffbf0;
            padding: 10px 15px;
            border-radius: 0 8px 8px 0;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #ff6b6b, #feca57);
            color: #1a1a2e;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 107, 107, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .btn svg {
            width: 18px;
            height: 18px;
        }

        .detection-info {
            margin-top: 20px;
            background: rgba(255, 107, 107, 0.1);
            border-radius: 12px;
            padding: 15px 20px;
            border: 1px solid rgba(255, 107, 107, 0.2);
        }

        .detection-info h3 {
            color: #ff6b6b;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .detection-stats {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }

        .stat-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 13px;
        }

        .stat-item span {
            color: #feca57;
            font-weight: bold;
        }

        .instructions {
            margin-top: 30px;
            background: rgba(72, 219, 251, 0.1);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(72, 219, 251, 0.2);
        }

        .instructions h3 {
            color: #48dbfb;
            margin-bottom: 15px;
        }

        .instructions ul {
            list-style: none;
        }

        .instructions li {
            padding: 8px 0;
            padding-left: 25px;
            position: relative;
        }

        .instructions li::before {
            content: "‚úì";
            position: absolute;
            left: 0;
            color: #feca57;
        }

        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, #ff6b6b, #feca57);
            color: #1a1a2e;
            padding: 15px 25px;
            border-radius: 8px;
            font-weight: 600;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s;
            z-index: 1000;
        }

        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }

        .toast.error {
            background: linear-gradient(135deg, #ff4757, #ff6b6b);
        }

        .empty-state {
            text-align: center;
            padding: 50px 20px;
            color: #888;
        }

        .empty-state svg {
            width: 80px;
            height: 80px;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .auto-badge {
            background: #ff6b6b;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            margin-left: 8px;
            vertical-align: middle;
        }

        .status-bar {
            text-align: center;
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 8px;
            font-size: 12px;
        }

        .status-bar.ready {
            background: rgba(0, 255, 136, 0.1);
            color: #00ff88;
            border: 1px solid rgba(0, 255, 136, 0.3);
        }

        .status-bar.error {
            background: rgba(255, 71, 87, 0.1);
            color: #ff4757;
            border: 1px solid rgba(255, 71, 87, 0.3);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üß† Smart Text Formatter</h1>
            <p class="subtitle">Auto-detects code, headings & structure from plain text</p>
        </header>

        <div id="statusBar" class="status-bar ready">‚úì Libraries loaded - Ready to export</div>

        <div class="mode-toggle">
            <button class="mode-btn active" onclick="setMode('smart')" id="smartModeBtn">
                üß† Smart Mode (Auto-Detect)
            </button>
            <button class="mode-btn" onclick="setMode('markdown')" id="markdownModeBtn">
                üìù Markdown Mode
            </button>
        </div>

        <div class="main-content">
            <div class="panel">
                <div class="panel-header">
                    <span class="panel-title">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"/>
                        </svg>
                        Input Text
                    </span>
                    <div class="btn-group">
                        <button class="btn btn-secondary" onclick="clearInput()">
                            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                            </svg>
                            Clear
                        </button>
                        <button class="btn btn-secondary" onclick="loadPlainSample()">
                            üìÑ Plain Text
                        </button>
                        <button class="btn btn-secondary" onclick="loadMarkdownSample()">
                            üìù Markdown
                        </button>
                    </div>
                </div>
                <textarea id="inputText" placeholder="Paste ANY text here - plain or markdown!

Smart Mode will auto-detect:
‚Ä¢ Code blocks (functions, variables, brackets)
‚Ä¢ Headings (short lines, ALL CAPS, Title Case)
‚Ä¢ Lists (lines starting with bullets or numbers)
‚Ä¢ Quotes (lines starting with > or in quotes)

No special formatting needed!"></textarea>
            </div>

            <div class="panel">
                <div class="panel-header">
                    <span class="panel-title">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"/>
                        </svg>
                        Preview
                        <span class="auto-badge" id="modeBadge">AUTO</span>
                    </span>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="exportToDoc()" id="exportBtn">
                            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/>
                            </svg>
                            Export to .DOCX
                        </button>
                    </div>
                </div>
                <div class="preview-area" id="previewArea">
                    <div class="empty-state">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
                        </svg>
                        <p>Paste any text to see smart formatting</p>
                    </div>
                </div>
            </div>
        </div>

        <div class="detection-info" id="detectionInfo" style="display: none;">
            <h3>üîç Auto-Detection Results</h3>
            <div class="detection-stats" id="detectionStats"></div>
        </div>

        <div class="instructions">
            <h3>üß† Smart Detection Features</h3>
            <ul>
                <li><strong>Code Detection:</strong> Recognizes function definitions, variables, brackets, semicolons, imports</li>
                <li><strong>Heading Detection:</strong> Short lines (under 60 chars), ALL CAPS, Title Case, lines ending with colon</li>
                <li><strong>List Detection:</strong> Lines starting with ‚Ä¢, -, *, or numbers</li>
                <li><strong>Quote Detection:</strong> Lines starting with > or wrapped in quotation marks</li>
                <li><strong>Language Detection:</strong> Identifies Python, JavaScript, Java, C++, SQL, HTML, CSS, and more</li>
            </ul>
        </div>
    </div>

    <div class="toast" id="toast">Document exported successfully!</div>

    <script>
        // Check if libraries are loaded
        window.addEventListener('load', function() {
            const statusBar = document.getElementById('statusBar');
            if (typeof docx !== 'undefined' && typeof saveAs !== 'undefined') {
                statusBar.className = 'status-bar ready';
                statusBar.innerHTML = '‚úì Libraries loaded - Ready to export';
            } else {
                statusBar.className = 'status-bar error';
                statusBar.innerHTML = '‚ö† Library loading issue - Please refresh the page';
            }
        });

        const inputText = document.getElementById('inputText');
        const previewArea = document.getElementById('previewArea');
        const detectionInfo = document.getElementById('detectionInfo');
        const detectionStats = document.getElementById('detectionStats');
        const modeBadge = document.getElementById('modeBadge');
        
        let parsedContent = [];
        let currentMode = 'smart';
        let stats = {};

        inputText.addEventListener('input', () => {
            updatePreview();
        });

        function setMode(mode) {
            currentMode = mode;
            document.getElementById('smartModeBtn').classList.toggle('active', mode === 'smart');
            document.getElementById('markdownModeBtn').classList.toggle('active', mode === 'markdown');
            modeBadge.textContent = mode === 'smart' ? 'AUTO' : 'MD';
            modeBadge.style.background = mode === 'smart' ? '#ff6b6b' : '#48dbfb';
            updatePreview();
        }

        function updatePreview() {
            const text = inputText.value;
            if (!text.trim()) {
                previewArea.innerHTML = `
                    <div class="empty-state">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
                        </svg>
                        <p>Paste any text to see smart formatting</p>
                    </div>
                `;
                parsedContent = [];
                detectionInfo.style.display = 'none';
                return;
            }

            if (currentMode === 'smart') {
                parsedContent = parseTextSmart(text);
            } else {
                parsedContent = parseTextMarkdown(text);
            }
            
            previewArea.innerHTML = renderHTML(parsedContent);
            
            if (currentMode === 'smart') {
                showDetectionStats();
            } else {
                detectionInfo.style.display = 'none';
            }
        }

        // Code detection patterns
        const codePatterns = [
            /^(import|from|require|include|using)\s+/,
            /^(def|function|func|fn|class|interface|struct|enum)\s+\w+/,
            /^(const|let|var|int|string|bool|float|double|char)\s+\w+/,
            /^(if|else|elif|while|for|switch|case|try|catch|finally)\s*[\(\{]/,
            /^(return|yield|throw|raise)\s+/,
            /[{}\[\]();]\s*$/,
            /^\s*(public|private|protected|static|async|await)\s+/,
            /=>\s*[{\(]/,
            /\w+\s*\([^)]*\)\s*[{:]/,
            /^\s*@\w+/,
            /^\s*#\s*(include|define|ifdef|endif)/,
            /console\.(log|error|warn)/,
            /print\s*\(/,
            /System\.out\./,
            /std::/,
            /SELECT|INSERT|UPDATE|DELETE|FROM|WHERE|JOIN/i,
            /^\s*<\/?[a-z]+[^>]*>\s*$/i,
            /^\s*\.[a-z-]+\s*\{/,
            /^\s*[a-z-]+\s*:\s*[^;]+;/,
        ];

        function isCodeLine(line) {
            const trimmed = line.trim();
            if (!trimmed) return false;
            
            for (const pattern of codePatterns) {
                if (pattern.test(trimmed)) return true;
            }
            
            const codeChars = (trimmed.match(/[{}()\[\];=<>!&|+\-*/]/g) || []).length;
            const ratio = codeChars / trimmed.length;
            if (ratio > 0.15 && trimmed.length > 10) return true;
            
            return false;
        }

        function detectLanguage(code) {
            const lines = code.toLowerCase();
            
            if (/\bdef\s+\w+\s*\(|import\s+\w+|from\s+\w+\s+import|print\s*\(/.test(lines)) return 'python';
            if (/\bfunction\s+\w+|const\s+\w+\s*=|let\s+\w+\s*=|console\.log|=>\s*{/.test(lines)) return 'javascript';
            if (/public\s+class|System\.out|void\s+main/.test(lines)) return 'java';
            if (/#include|std::|int\s+main|cout\s*<</.test(lines)) return 'cpp';
            if (/SELECT|INSERT|UPDATE|DELETE|FROM|WHERE/i.test(lines)) return 'sql';
            if (/<html|<div|<span|<head|<body/i.test(lines)) return 'html';
            if (/[.#]\w+\s*\{|:\s*\d+px|margin:|padding:|color:/.test(lines)) return 'css';
            if (/^\s*\$|echo\s+|apt\s+|npm\s+|pip\s+|git\s+/.test(lines)) return 'bash';
            if (/\{\s*"|\[\s*\{|":\s*["\d\[]/.test(lines)) return 'json';
            
            return 'code';
        }

        function isHeading(line, nextLine, prevLine) {
            const trimmed = line.trim();
            if (!trimmed || trimmed.length > 80) return false;
            
            if (/^#{1,3}\s+/.test(trimmed)) return true;
            if (/^[A-Z][A-Z\s]{2,}$/.test(trimmed) && trimmed.length < 60) return 'h1';
            
            if (/^[A-Z][a-zA-Z\s]+$/.test(trimmed) && trimmed.length < 50 && !/[.!?,;]$/.test(trimmed)) {
                const words = trimmed.split(/\s+/);
                if (words.length <= 8 && words.length >= 2) {
                    const capitalWords = words.filter(w => /^[A-Z]/.test(w)).length;
                    if (capitalWords >= words.length * 0.6) return 'h2';
                }
            }
            
            if (/^[A-Za-z][A-Za-z\s]+:$/.test(trimmed) && trimmed.length < 40) return 'h3';
            
            if (trimmed.length < 40 && !trimmed.includes('.') && nextLine && nextLine.trim().length > trimmed.length * 2) {
                return 'h2';
            }
            
            return false;
        }

        function parseTextSmart(text) {
            const lines = text.split('\n');
            const content = [];
            let i = 0;
            
            stats = { headings: 0, codeBlocks: 0, lists: 0, paragraphs: 0, quotes: 0 };

            while (i < lines.length) {
                const line = lines[i];
                const nextLine = lines[i + 1] || '';
                const prevLine = lines[i - 1] || '';
                const trimmed = line.trim();

                if (!trimmed) {
                    i++;
                    continue;
                }

                if (trimmed.startsWith('```')) {
                    const lang = trimmed.slice(3).trim() || 'code';
                    const codeLines = [];
                    i++;
                    while (i < lines.length && !lines[i].trim().startsWith('```')) {
                        codeLines.push(lines[i]);
                        i++;
                    }
                    content.push({ type: 'code-block', language: lang, code: codeLines.join('\n') });
                    stats.codeBlocks++;
                    i++;
                    continue;
                }

                const mdHeading = trimmed.match(/^(#{1,3})\s+(.+)$/);
                if (mdHeading) {
                    content.push({ type: `h${mdHeading[1].length}`, text: mdHeading[2] });
                    stats.headings++;
                    i++;
                    continue;
                }

                if (isCodeLine(line)) {
                    const codeLines = [line];
                    i++;
                    while (i < lines.length) {
                        const nextL = lines[i];
                        if (!nextL.trim()) {
                            if (i + 1 < lines.length && isCodeLine(lines[i + 1])) {
                                codeLines.push(nextL);
                                i++;
                                continue;
                            }
                            break;
                        }
                        if (isCodeLine(nextL) || /^\s+/.test(nextL)) {
                            codeLines.push(nextL);
                            i++;
                        } else {
                            break;
                        }
                    }
                    const code = codeLines.join('\n');
                    content.push({ type: 'code-block', language: detectLanguage(code), code: code });
                    stats.codeBlocks++;
                    continue;
                }

                const headingLevel = isHeading(line, nextLine, prevLine);
                if (headingLevel) {
                    const headingText = trimmed.replace(/^#{1,3}\s+/, '').replace(/:$/, '');
                    content.push({ type: headingLevel === true ? 'h2' : headingLevel, text: headingText });
                    stats.headings++;
                    i++;
                    continue;
                }

                if (trimmed.startsWith('>') || (trimmed.startsWith('"') && trimmed.endsWith('"'))) {
                    let quoteText = trimmed.startsWith('>') ? trimmed.slice(1).trim() : trimmed.slice(1, -1);
                    content.push({ type: 'blockquote', text: quoteText });
                    stats.quotes++;
                    i++;
                    continue;
                }

                const bulletMatch = trimmed.match(/^[‚Ä¢\-\*]\s+(.+)$/);
                const numberedMatch = trimmed.match(/^\d+[\.\)]\s+(.+)$/);
                
                if (bulletMatch || numberedMatch) {
                    const listType = bulletMatch ? 'bullet-list' : 'numbered-list';
                    const items = [];
                    
                    while (i < lines.length) {
                        const listLine = lines[i].trim();
                        const bMatch = listLine.match(/^[‚Ä¢\-\*]\s+(.+)$/);
                        const nMatch = listLine.match(/^\d+[\.\)]\s+(.+)$/);
                        
                        if ((listType === 'bullet-list' && bMatch) || (listType === 'numbered-list' && nMatch)) {
                            items.push(bMatch ? bMatch[1] : nMatch[1]);
                            i++;
                        } else if (!listLine) {
                            i++;
                            break;
                        } else {
                            break;
                        }
                    }
                    
                    if (items.length > 0) {
                        content.push({ type: listType, items: items });
                        stats.lists++;
                    }
                    continue;
                }

                content.push({ type: 'paragraph', text: trimmed });
                stats.paragraphs++;
                i++;
            }

            return content;
        }

        function parseTextMarkdown(text) {
            const lines = text.split('\n');
            const content = [];
            let i = 0;
            let currentList = null;
            let currentListType = null;

            while (i < lines.length) {
                const line = lines[i];

                if (line.trim().startsWith('```')) {
                    if (currentList) {
                        content.push(currentList);
                        currentList = null;
                        currentListType = null;
                    }
                    
                    const lang = line.trim().slice(3).trim() || 'code';
                    const codeLines = [];
                    i++;
                    while (i < lines.length && !lines[i].trim().startsWith('```')) {
                        codeLines.push(lines[i]);
                        i++;
                    }
                    content.push({ type: 'code-block', language: lang, code: codeLines.join('\n') });
                    i++;
                    continue;
                }

                const headingMatch = line.match(/^(#{1,3})\s+(.+)$/);
                if (headingMatch) {
                    if (currentList) {
                        content.push(currentList);
                        currentList = null;
                        currentListType = null;
                    }
                    content.push({ type: `h${headingMatch[1].length}`, text: headingMatch[2] });
                    i++;
                    continue;
                }

                if (line.trim().startsWith('>')) {
                    if (currentList) {
                        content.push(currentList);
                        currentList = null;
                        currentListType = null;
                    }
                    content.push({ type: 'blockquote', text: line.trim().slice(1).trim() });
                    i++;
                    continue;
                }

                const bulletMatch = line.match(/^[\s]*[-*]\s+(.+)$/);
                if (bulletMatch) {
                    if (currentListType !== 'bullet') {
                        if (currentList) content.push(currentList);
                        currentList = { type: 'bullet-list', items: [] };
                        currentListType = 'bullet';
                    }
                    currentList.items.push(bulletMatch[1]);
                    i++;
                    continue;
                }

                const numberedMatch = line.match(/^[\s]*\d+\.\s+(.+)$/);
                if (numberedMatch) {
                    if (currentListType !== 'numbered') {
                        if (currentList) content.push(currentList);
                        currentList = { type: 'numbered-list', items: [] };
                        currentListType = 'numbered';
                    }
                    currentList.items.push(numberedMatch[1]);
                    i++;
                    continue;
                }

                if (currentList) {
                    content.push(currentList);
                    currentList = null;
                    currentListType = null;
                }

                if (line.trim()) {
                    content.push({ type: 'paragraph', text: line.trim() });
                }
                i++;
            }

            if (currentList) content.push(currentList);
            return content;
        }

        function formatInlineText(text) {
            text = text.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
            text = text.replace(/\*(.+?)\*/g, '<em>$1</em>');
            text = text.replace(/`([^`]+)`/g, '<span class="inline-code">$1</span>');
            return text;
        }

        function renderHTML(content) {
            return content.map(item => {
                switch (item.type) {
                    case 'h1':
                        return `<h1>${formatInlineText(item.text)}</h1>`;
                    case 'h2':
                        return `<h2>${formatInlineText(item.text)}</h2>`;
                    case 'h3':
                        return `<h3>${formatInlineText(item.text)}</h3>`;
                    case 'paragraph':
                        return `<p>${formatInlineText(item.text)}</p>`;
                    case 'code-block':
                        return `<div class="code-block">
                            <span class="lang-label">${escapeHtml(item.language)}</span>
                            <pre>${escapeHtml(item.code)}</pre>
                        </div>`;
                    case 'blockquote':
                        return `<blockquote>${formatInlineText(item.text)}</blockquote>`;
                    case 'bullet-list':
                        return `<ul>${item.items.map(i => `<li>${formatInlineText(i)}</li>`).join('')}</ul>`;
                    case 'numbered-list':
                        return `<ol>${item.items.map(i => `<li>${formatInlineText(i)}</li>`).join('')}</ol>`;
                    default:
                        return '';
                }
            }).join('');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showDetectionStats() {
            detectionInfo.style.display = 'block';
            detectionStats.innerHTML = `
                <div class="stat-item">üìå Headings: <span>${stats.headings}</span></div>
                <div class="stat-item">üíª Code Blocks: <span>${stats.codeBlocks}</span></div>
                <div class="stat-item">üìù Lists: <span>${stats.lists}</span></div>
                <div class="stat-item">üí¨ Quotes: <span>${stats.quotes}</span></div>
                <div class="stat-item">üìÑ Paragraphs: <span>${stats.paragraphs}</span></div>
            `;
        }

        function clearInput() {
            inputText.value = '';
            updatePreview();
        }

        function loadPlainSample() {
            inputText.value = `USER AUTHENTICATION SYSTEM

Project Overview

This document describes the implementation of a secure login system for our web application. The system handles user registration, authentication, and session management.

Key Features

The authentication module includes the following capabilities:
- Secure password hashing using bcrypt
- JWT token based sessions
- Rate limiting for brute force protection
- Two factor authentication support

Database Schema

Here is the user model definition:

const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
    email: {
        type: String,
        required: true,
        unique: true
    },
    password: {
        type: String,
        required: true
    },
    createdAt: {
        type: Date,
        default: Date.now
    }
});

module.exports = mongoose.model('User', userSchema);

Authentication Function

The login handler validates credentials and returns a token:

async function authenticateUser(email, password) {
    const user = await User.findOne({ email });
    
    if (!user) {
        throw new Error('User not found');
    }
    
    const isValid = await bcrypt.compare(password, user.password);
    
    if (!isValid) {
        throw new Error('Invalid password');
    }
    
    return { success: true, user };
}

Test Results

After running the automated test suite:

1. Unit tests passed: 45 out of 47
2. Integration tests passed: 12 out of 12
3. Code coverage: 89%
4. Performance benchmark: 450 requests per second

Conclusion

This authentication system provides a robust foundation for user management.`;
            updatePreview();
        }

        function loadMarkdownSample() {
            inputText.value = `# Project Documentation

This is a **sample document** with markdown formatting.

## Features

- Easy to use
- Fast processing
- Export to Word

### Code Example

\`\`\`javascript
function greet(name) {
    console.log(\`Hello, \${name}!\`);
}
\`\`\`

## Steps

1. Write your content
2. Preview the result
3. Export to document

> This is a blockquote for important notes.

Use \`inline code\` for small snippets.`;
            updatePreview();
        }

        async function exportToDoc() {
            try {
                if (parsedContent.length === 0) {
                    showToast('Please enter some text first!', true);
                    return;
                }

                // Check if docx library is available
                if (typeof docx === 'undefined') {
                    showToast('Library not loaded. Please refresh the page.', true);
                    return;
                }

                const { Document, Packer, Paragraph, TextRun, HeadingLevel, 
                        AlignmentType, BorderStyle, ShadingType } = docx;

                const docChildren = [];

                for (const item of parsedContent) {
                    switch (item.type) {
                        case 'h1':
                            docChildren.push(new Paragraph({
                                children: [new TextRun({ text: item.text, bold: true, size: 48, font: 'Arial' })],
                                heading: HeadingLevel.HEADING_1,
                                spacing: { before: 400, after: 200 }
                            }));
                            break;

                        case 'h2':
                            docChildren.push(new Paragraph({
                                children: [new TextRun({ text: item.text, bold: true, size: 36, font: 'Arial' })],
                                heading: HeadingLevel.HEADING_2,
                                spacing: { before: 300, after: 150 }
                            }));
                            break;

                        case 'h3':
                            docChildren.push(new Paragraph({
                                children: [new TextRun({ text: item.text, bold: true, size: 28, font: 'Arial' })],
                                heading: HeadingLevel.HEADING_3,
                                spacing: { before: 200, after: 100 }
                            }));
                            break;

                        case 'paragraph':
                            docChildren.push(new Paragraph({
                                children: [new TextRun({ text: item.text, size: 24, font: 'Arial' })],
                                spacing: { after: 200 }
                            }));
                            break;

                        case 'code-block':
                            // Language label
                            docChildren.push(new Paragraph({
                                children: [new TextRun({
                                    text: item.language.toUpperCase(),
                                    font: 'Consolas',
                                    size: 18,
                                    bold: true,
                                    color: 'CC4400'
                                })],
                                spacing: { before: 200 }
                            }));

                            // Code content
                            const codeLines = item.code.split('\n');
                            codeLines.forEach((line, idx) => {
                                docChildren.push(new Paragraph({
                                    children: [new TextRun({
                                        text: line || ' ',
                                        font: 'Consolas',
                                        size: 20,
                                        color: '333333'
                                    })],
                                    shading: { fill: 'F5F5F5', type: ShadingType.CLEAR },
                                    border: {
                                        left: { style: BorderStyle.SINGLE, size: 24, color: 'CC4400' }
                                    },
                                    indent: { left: 360 },
                                    spacing: { 
                                        before: idx === 0 ? 100 : 0, 
                                        after: idx === codeLines.length - 1 ? 200 : 0 
                                    }
                                }));
                            });
                            break;

                        case 'blockquote':
                            docChildren.push(new Paragraph({
                                children: [new TextRun({ text: item.text, size: 24, italics: true, color: '666666', font: 'Arial' })],
                                border: {
                                    left: { style: BorderStyle.SINGLE, size: 24, color: 'FFAA00' }
                                },
                                shading: { fill: 'FFFBF0', type: ShadingType.CLEAR },
                                indent: { left: 720 },
                                spacing: { before: 200, after: 200 }
                            }));
                            break;

                        case 'bullet-list':
                            item.items.forEach(listItem => {
                                docChildren.push(new Paragraph({
                                    children: [
                                        new TextRun({ text: '‚Ä¢  ', size: 24, font: 'Arial' }),
                                        new TextRun({ text: listItem, size: 24, font: 'Arial' })
                                    ],
                                    indent: { left: 720 },
                                    spacing: { after: 80 }
                                }));
                            });
                            docChildren.push(new Paragraph({ children: [] }));
                            break;

                        case 'numbered-list':
                            item.items.forEach((listItem, idx) => {
                                docChildren.push(new Paragraph({
                                    children: [
                                        new TextRun({ text: `${idx + 1}.  `, size: 24, font: 'Arial' }),
                                        new TextRun({ text: listItem, size: 24, font: 'Arial' })
                                    ],
                                    indent: { left: 720 },
                                    spacing: { after: 80 }
                                }));
                            });
                            docChildren.push(new Paragraph({ children: [] }));
                            break;
                    }
                }

                const doc = new Document({
                    styles: {
                        default: { document: { run: { font: 'Arial', size: 24 } } }
                    },
                    sections: [{
                        properties: {
                            page: {
                                size: { width: 12240, height: 15840 },
                                margin: { top: 1440, right: 1440, bottom: 1440, left: 1440 }
                            }
                        },
                        children: docChildren
                    }]
                });

                const blob = await Packer.toBlob(doc);
                saveAs(blob, 'formatted-document.docx');
                showToast('Document exported successfully!');

            } catch (error) {
                console.error('Export error:', error);
                showToast('Export failed: ' + error.message, true);
            }
        }

        function showToast(message, isError = false) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = 'toast show' + (isError ? ' error' : '');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }
    </script>
</body>
</html>
