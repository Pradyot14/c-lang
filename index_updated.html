<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C Call Tracer + Argument Flow (ROBUST)</title>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --border: #30363d;
            --text: #c9d1d9;
            --text-muted: #8b949e;
            --cyan: #58a6ff;
            --green: #3fb950;
            --purple: #a371f7;
            --pink: #f778ba;
            --orange: #d29922;
            --red: #f85149;
            --yellow: #e3b341;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: var(--bg-primary); color: var(--text); min-height: 100vh; }
        .container { max-width: 1800px; margin: 0 auto; padding: 15px; }
        header { text-align: center; padding: 10px 0; border-bottom: 1px solid var(--border); margin-bottom: 12px; }
        h1 { color: var(--cyan); font-size: 1.5rem; margin-bottom: 3px; }
        .subtitle { color: var(--text-muted); font-size: 0.75rem; }
        
        .main-grid { display: grid; grid-template-columns: 380px 1fr; gap: 15px; }
        @media (max-width: 1100px) { .main-grid { grid-template-columns: 1fr; } }
        
        .card { background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 8px; padding: 12px; margin-bottom: 10px; }
        .card-title { color: var(--cyan); font-size: 0.8rem; font-weight: 600; margin-bottom: 8px; padding-bottom: 6px; border-bottom: 1px solid var(--border); }
        
        .upload-zone { border: 2px dashed var(--border); border-radius: 8px; padding: 15px; text-align: center; cursor: pointer; transition: all 0.2s; }
        .upload-zone:hover { border-color: var(--cyan); background: rgba(88, 166, 255, 0.05); }
        .upload-zone.has-files { border-color: var(--green); border-style: solid; }
        .upload-zone p { color: var(--text-muted); margin-bottom: 5px; font-size: 0.75rem; }
        .upload-zone .badge { display: inline-block; background: var(--bg-tertiary); color: var(--cyan); padding: 2px 6px; border-radius: 4px; font-size: 0.65rem; margin: 2px; font-family: monospace; }
        
        .file-list { max-height: 100px; overflow-y: auto; margin-top: 8px; }
        .file-item { display: flex; justify-content: space-between; align-items: center; background: var(--bg-tertiary); padding: 3px 8px; border-radius: 4px; margin-bottom: 3px; font-size: 0.7rem; font-family: monospace; }
        .file-item .type { padding: 1px 4px; border-radius: 3px; font-size: 0.6rem; margin-right: 5px; }
        .file-item .type.c { background: rgba(63, 185, 80, 0.2); color: var(--green); }
        .file-item .type.h { background: rgba(163, 113, 247, 0.2); color: var(--purple); }
        .file-item .remove { background: none; border: none; color: var(--text-muted); cursor: pointer; font-size: 0.85rem; }
        .file-item .remove:hover { color: var(--red); }
        
        .form-group { margin-bottom: 7px; }
        .form-group label { display: block; color: var(--text-muted); font-size: 0.65rem; margin-bottom: 2px; }
        .form-group input, .form-group select { width: 100%; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 4px; padding: 6px 8px; color: var(--text); font-family: monospace; font-size: 0.75rem; }
        .form-group input:focus { outline: none; border-color: var(--cyan); }
        
        .form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .form-row-3 { display: grid; grid-template-columns: 1fr 65px 80px; gap: 5px; }
        
        .btn { width: 100%; padding: 9px; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; font-size: 0.75rem; transition: all 0.2s; }
        .btn-primary { background: linear-gradient(135deg, var(--cyan), var(--purple)); color: #fff; }
        .btn-primary:hover:not(:disabled) { opacity: 0.9; }
        .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-secondary { background: var(--bg-tertiary); color: var(--text); border: 1px solid var(--border); margin-top: 5px; }
        .btn-arg { background: linear-gradient(135deg, var(--yellow), var(--orange)); color: #000; margin-top: 5px; }
        
        .stats { display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px; margin-top: 6px; }
        .stat { background: var(--bg-tertiary); padding: 5px; border-radius: 4px; text-align: center; }
        .stat-val { font-size: 1rem; font-weight: 700; color: var(--cyan); }
        .stat-label { font-size: 0.55rem; color: var(--text-muted); }
        
        .tabs { display: flex; gap: 4px; margin-bottom: 8px; flex-wrap: wrap; }
        .tab { padding: 5px 10px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 4px; color: var(--text-muted); cursor: pointer; font-size: 0.7rem; }
        .tab:hover { border-color: var(--cyan); color: var(--text); }
        .tab.active { background: rgba(88, 166, 255, 0.1); border-color: var(--cyan); color: var(--cyan); }
        .tab.arg-tab.active { background: rgba(227, 179, 65, 0.15); border-color: var(--yellow); color: var(--yellow); }
        
        .output { background: var(--bg-tertiary); border-radius: 6px; padding: 10px; min-height: 500px; max-height: 620px; overflow: auto; font-family: 'Monaco', 'Menlo', monospace; font-size: 0.72rem; line-height: 1.5; white-space: pre-wrap; }
        
        .progress { padding: 20px; text-align: center; }
        .progress-bar { height: 4px; background: var(--border); border-radius: 2px; margin: 10px 0; overflow: hidden; }
        .progress-fill { height: 100%; background: var(--cyan); transition: width 0.3s; }
        .progress-text { color: var(--text-muted); font-size: 0.75rem; }
        
        .error { background: rgba(248, 81, 73, 0.1); border: 1px solid var(--red); border-radius: 6px; padding: 10px; color: var(--red); font-size: 0.75rem; }
        .warning { background: rgba(210, 153, 34, 0.1); border: 1px solid var(--orange); border-radius: 6px; padding: 8px; color: var(--orange); margin-bottom: 8px; font-size: 0.7rem; }
        .success { background: rgba(63, 185, 80, 0.1); border: 1px solid var(--green); border-radius: 6px; padding: 8px; color: var(--green); margin-bottom: 8px; font-size: 0.7rem; }
        
        .legend { display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 6px; padding: 5px 8px; background: var(--bg-tertiary); border-radius: 4px; font-size: 0.6rem; }
        .legend-item { display: flex; align-items: center; gap: 3px; color: var(--text-muted); }
        .legend-color { width: 8px; height: 8px; border-radius: 2px; }
        
        .c-entry { color: var(--cyan); }
        .c-target { color: var(--green); font-weight: bold; }
        .c-inter { color: var(--purple); }
        .c-muted { color: var(--text-muted); }
        .c-yellow { color: var(--yellow); }
        .c-orange { color: var(--orange); }
        .c-red { color: var(--red); }
        .c-green { color: var(--green); }
        .c-pink { color: var(--pink); }
        
        .arg-box { background: var(--bg-secondary); border: 1px solid var(--yellow); border-radius: 8px; padding: 10px; margin-bottom: 10px; }
        .arg-box-title { color: var(--yellow); font-weight: 600; font-size: 0.8rem; margin-bottom: 6px; display: flex; justify-content: space-between; align-items: center; }
        .arg-box-badge { background: rgba(227, 179, 65, 0.2); color: var(--yellow); padding: 2px 8px; border-radius: 10px; font-size: 0.6rem; }
        
        .arg-step { background: var(--bg-tertiary); border-radius: 5px; padding: 8px; margin-bottom: 5px; border-left: 3px solid var(--purple); }
        .arg-step.origin { border-left-color: var(--green); background: rgba(63, 185, 80, 0.05); }
        .arg-step-header { display: flex; justify-content: space-between; align-items: center; }
        .arg-step-func { color: var(--purple); font-weight: 600; font-size: 0.75rem; }
        .arg-step.origin .arg-step-func { color: var(--green); }
        .arg-step-file { color: var(--text-muted); font-size: 0.65rem; }
        .arg-step-detail { margin-top: 3px; font-size: 0.7rem; }
        .arg-step-detail code { background: var(--bg-secondary); padding: 1px 4px; border-radius: 3px; color: var(--yellow); }
        
        .debug-box { background: rgba(88, 166, 255, 0.03); border: 1px dashed var(--border); border-radius: 6px; padding: 8px; margin-top: 10px; max-height: 200px; overflow: auto; }
        .debug-title { color: var(--cyan); font-size: 0.7rem; margin-bottom: 5px; }
        
        ::-webkit-scrollbar { width: 5px; height: 5px; }
        ::-webkit-scrollbar-track { background: var(--bg-tertiary); }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üîç C Call Tracer + Argument Flow</h1>
            <p class="subtitle">Trace paths & backtrack argument values (filenum, mode, handle, etc.)</p>
        </header>
        
        <div class="main-grid">
            <div class="sidebar">
                <div class="card">
                    <div class="card-title">üìÅ Upload C/H Files</div>
                    <div class="upload-zone" id="uploadZone">
                        <p>Drop files here or click</p>
                        <div><span class="badge">.c</span><span class="badge">.h</span></div>
                        <input type="file" id="fileInput" multiple accept=".c,.h,.cpp,.hpp" hidden>
                    </div>
                    <div class="file-list" id="fileList"></div>
                </div>
                
                <div class="card">
                    <div class="card-title">‚öôÔ∏è Call Path Analysis</div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Entry Function</label>
                            <input type="text" id="entryFunc" value="main">
                        </div>
                        <div class="form-group">
                            <label>Target Function</label>
                            <input type="text" id="targetFunc" value="mpf_mfs_open">
                        </div>
                    </div>
                    <button class="btn btn-primary" id="analyzeBtn" disabled>üî¨ Analyze Call Paths</button>
                </div>
                
                <div class="card">
                    <div class="card-title">üîÑ Argument Flow Tracking</div>
                    <div class="form-row-3">
                        <div class="form-group">
                            <label>Target Function</label>
                            <input type="text" id="argTargetFunc" value="mpf_mfs_open">
                        </div>
                        <div class="form-group">
                            <label>Arg #</label>
                            <select id="argPosition">
                                <option value="1">1st</option>
                                <option value="2">2nd</option>
                                <option value="3" selected>3rd</option>
                                <option value="4">4th</option>
                                <option value="5">5th</option>
                                <option value="6">6th</option>
                                <option value="7">7th</option>
                                <option value="8">8th</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Name</label>
                            <input type="text" id="argName" value="filenum">
                        </div>
                    </div>
                    <button class="btn btn-arg" id="traceArgBtn" disabled>üîÑ Trace Argument Origin</button>
                </div>
                
                <div class="card" id="statsCard" style="display:none;">
                    <div class="card-title">üìä Results</div>
                    <div class="stats">
                        <div class="stat"><div class="stat-val" id="statFiles">0</div><div class="stat-label">Files</div></div>
                        <div class="stat"><div class="stat-val" id="statFuncs">0</div><div class="stat-label">Functions</div></div>
                        <div class="stat"><div class="stat-val" id="statPaths">0</div><div class="stat-label">Paths</div></div>
                    </div>
                </div>
                
                <button class="btn btn-secondary" id="clearBtn">Clear All</button>
            </div>
            
            <div class="results">
                <div class="card" style="height: 100%;">
                    <div class="tabs">
                        <button class="tab active" data-tab="tree">Call Tree</button>
                        <button class="tab" data-tab="paths">All Paths</button>
                        <button class="tab arg-tab" data-tab="argflow">üîÑ Arg Flow</button>
                        <button class="tab" data-tab="calls">All Calls</button>
                        <button class="tab" data-tab="debug">Debug</button>
                    </div>
                    
                    <div class="legend">
                        <div class="legend-item"><div class="legend-color" style="background:var(--cyan)"></div>Entry</div>
                        <div class="legend-item"><div class="legend-color" style="background:var(--green)"></div>Target/Origin</div>
                        <div class="legend-item"><div class="legend-color" style="background:var(--purple)"></div>Intermediate</div>
                        <div class="legend-item"><div class="legend-color" style="background:var(--yellow)"></div>Argument</div>
                    </div>
                    
                    <div class="output" id="output">
                        <div style="color:var(--text-muted);text-align:center;padding:50px;">
                            Upload C files and click Analyze
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

<script>
// =====================================================
// ROBUST C PARSER - HANDLES ALL ARGUMENT TRACKING CASES
// =====================================================
class CParser {
    constructor() {
        this.files = new Map();
        this.functions = new Map();
        this.macros = new Map();
        this.callGraph = new Map();
        this.allCalls = new Map();         // funcName -> [{callee, args[], argsRaw, line, context}]
        this.varOrigins = new Map();       // funcName -> Map(varName -> {type, value, line})
        this.log = [];
    }

    addLog(type, msg) {
        this.log.push({ type, msg, ts: Date.now() });
        console.log(`[${type}] ${msg}`);
    }

    // Remove comments preserving newlines for line counting
    removeComments(code) {
        // Remove block comments
        code = code.replace(/\/\*[\s\S]*?\*\//g, match => match.replace(/[^\n]/g, ' '));
        // Remove line comments
        code = code.replace(/\/\/.*$/gm, '');
        return code;
    }

    // Check if valid function name
    isValidFunc(name) {
        const kw = new Set(['if','else','while','for','do','switch','case','break','continue','return','goto','sizeof','typeof','NULL','null','true','false','void','int','char','float','double','long','short','unsigned','signed','const','static','extern','struct','enum','union','typedef','volatile','register','inline','auto','default','defined','__attribute__','__asm__']);
        if (kw.has(name)) return false;
        if (/^\d/.test(name)) return false;
        if (name.length < 2) return false;
        return true;
    }

    // Parse macros
    parseMacros(code, file) {
        const norm = code.replace(/\\\s*\n/g, ' ');
        // Function-like macros
        const funcMacro = /#\s*define\s+(\w+)\s*\(([^)]*)\)\s+(.+?)(?=\n|$)/g;
        let m;
        while ((m = funcMacro.exec(norm)) !== null) {
            this.macros.set(m[1], { name: m[1], params: m[2], body: m[3].trim(), file });
        }
        // Object macros
        const objMacro = /#\s*define\s+(\w+)\s+(\S[^\n]*)/g;
        while ((m = objMacro.exec(norm)) !== null) {
            if (!this.macros.has(m[1]) && !m[1].includes('(')) {
                this.macros.set(m[1], { name: m[1], body: m[2].trim(), file });
            }
        }
    }

    // Find matching brace
    findMatchingBrace(code, start) {
        let depth = 1, i = start;
        const limit = Math.min(code.length, start + 150000);
        while (i < limit && depth > 0) {
            if (code[i] === '{') depth++;
            else if (code[i] === '}') depth--;
            i++;
        }
        return depth === 0 ? i : -1;
    }

    // ROBUST: Parse arguments from string - handles all edge cases
    parseArguments(argsStr) {
        if (!argsStr || !argsStr.trim()) return [];
        
        const args = [];
        let current = '';
        let depth = 0;        // For (), [], {}
        let inString = false;
        let stringChar = '';
        let escaped = false;
        
        for (let i = 0; i < argsStr.length; i++) {
            const c = argsStr[i];
            
            // Handle escape sequences
            if (escaped) {
                current += c;
                escaped = false;
                continue;
            }
            
            if (c === '\\') {
                current += c;
                escaped = true;
                continue;
            }
            
            // Handle string literals
            if ((c === '"' || c === "'") && !inString) {
                inString = true;
                stringChar = c;
                current += c;
                continue;
            }
            
            if (inString) {
                current += c;
                if (c === stringChar) {
                    inString = false;
                }
                continue;
            }
            
            // Handle nesting
            if (c === '(' || c === '[' || c === '{') {
                depth++;
                current += c;
            } else if (c === ')' || c === ']' || c === '}') {
                depth--;
                current += c;
            } else if (c === ',' && depth === 0) {
                // Argument separator at top level
                const trimmed = current.trim();
                if (trimmed) args.push(trimmed);
                current = '';
            } else {
                current += c;
            }
        }
        
        // Don't forget last argument
        const trimmed = current.trim();
        if (trimmed) args.push(trimmed);
        
        return args;
    }

    // ROBUST: Extract ALL function calls with their arguments
    extractAllCalls(body, funcName) {
        const calls = [];
        const cleanBody = this.removeComments(body);
        
        // Use regex to find potential function calls
        const callPattern = /\b([a-zA-Z_]\w*)\s*\(/g;
        let match;
        
        while ((match = callPattern.exec(cleanBody)) !== null) {
            const callee = match[1];
            
            if (!this.isValidFunc(callee)) continue;
            
            const callStart = match.index;
            const parenStart = match.index + match[0].length - 1;
            
            // Find the matching closing parenthesis
            let depth = 1;
            let j = parenStart + 1;
            let inStr = false;
            let strChr = '';
            
            while (j < cleanBody.length && depth > 0) {
                const c = cleanBody[j];
                const prev = j > 0 ? cleanBody[j - 1] : '';
                
                // Handle strings
                if ((c === '"' || c === "'") && prev !== '\\') {
                    if (!inStr) { inStr = true; strChr = c; }
                    else if (c === strChr) { inStr = false; }
                }
                
                if (!inStr) {
                    if (c === '(') depth++;
                    else if (c === ')') depth--;
                }
                j++;
            }
            
            if (depth === 0) {
                const argsStr = cleanBody.substring(parenStart + 1, j - 1);
                const args = this.parseArguments(argsStr);
                
                // Calculate line number
                const lineNum = (cleanBody.substring(0, callStart).match(/\n/g) || []).length + 1;
                
                // Get some context around the call
                const lineStart = cleanBody.lastIndexOf('\n', callStart) + 1;
                const lineEnd = cleanBody.indexOf('\n', j);
                const context = cleanBody.substring(lineStart, lineEnd > 0 ? lineEnd : j + 50).trim();
                
                calls.push({
                    callee,
                    args,
                    argsRaw: argsStr.trim(),
                    line: lineNum,
                    context: context.substring(0, 200),
                    raw: cleanBody.substring(callStart, j)
                });
            }
        }
        
        this.allCalls.set(funcName, calls);
        return calls;
    }

    // ROBUST: Parse variable assignments and track origins
    parseVariableOrigins(funcName, body, params) {
        const origins = new Map();
        const cleanBody = this.removeComments(body);
        
        // First: Add all parameters as potential sources
        params.forEach((p, idx) => {
            origins.set(p.name, {
                type: 'parameter',
                paramIndex: idx,
                value: `(parameter #${idx + 1})`,
                line: 0
            });
        });
        
        // Pattern 1: Type declarations with initialization
        // int x = value; unsigned int y = value; char *ptr = value;
        const declPatterns = [
            /\b(?:const\s+)?(?:unsigned\s+|signed\s+)?(?:int|char|short|long|float|double|void|size_t|ssize_t|uint\d+_t|int\d+_t|\w+_t)\s*\*?\s*(\w+)\s*=\s*([^;]+);/g,
            /\b(?:struct|enum|union)\s+\w+\s*\*?\s*(\w+)\s*=\s*([^;]+);/g
        ];
        
        for (const pattern of declPatterns) {
            let m;
            while ((m = pattern.exec(cleanBody)) !== null) {
                const varName = m[1];
                const value = m[2].trim();
                if (varName && value && !origins.has(varName)) {
                    const line = (cleanBody.substring(0, m.index).match(/\n/g) || []).length + 1;
                    origins.set(varName, {
                        type: this.classifyValue(value),
                        value: value,
                        line: line
                    });
                }
            }
        }
        
        // Pattern 2: Simple assignments (var = value;)
        // Be careful not to match == or !=
        const assignPattern = /\b([a-zA-Z_]\w*)\s*=\s*([^;=!<>]+);/g;
        let m;
        while ((m = assignPattern.exec(cleanBody)) !== null) {
            const varName = m[1];
            const value = m[2].trim();
            
            // Skip if already have origin (params or declarations take precedence)
            if (origins.has(varName)) continue;
            
            // Skip if this looks like a comparison that slipped through
            if (value.includes('==') || value.includes('!=') || value.includes('<=') || value.includes('>=')) continue;
            
            // Skip control flow keywords
            if (['if', 'while', 'for', 'switch', 'return'].includes(varName)) continue;
            
            const line = (cleanBody.substring(0, m.index).match(/\n/g) || []).length + 1;
            origins.set(varName, {
                type: this.classifyValue(value),
                value: value,
                line: line
            });
        }
        
        this.varOrigins.set(funcName, origins);
        return origins;
    }

    // Classify value type
    classifyValue(value) {
        if (!value) return 'unknown';
        value = value.trim();
        
        // Literals
        if (/^-?\d+$/.test(value)) return 'literal-int';
        if (/^0x[\da-fA-F]+$/i.test(value)) return 'literal-hex';
        if (/^-?\d+\.\d*f?$/.test(value)) return 'literal-float';
        if (/^["']/.test(value)) return 'literal-string';
        if (value === 'NULL' || value === 'nullptr') return 'literal-null';
        if (value === 'true' || value === 'false') return 'literal-bool';
        
        // Expressions
        if (value.includes('->')) return 'member-ptr';
        if (value.includes('.') && !value.includes('(')) return 'member-dot';
        if (value.includes('[')) return 'array-access';
        if (/\w+\s*\(/.test(value)) return 'function-call';
        if (/[+\-*\/%&|^~!]/.test(value)) return 'expression';
        if (value.includes('?') && value.includes(':')) return 'ternary';
        
        // Check if it's a known macro
        if (this.macros.has(value)) return 'macro';
        
        // Simple identifier
        if (/^[a-zA-Z_]\w*$/.test(value)) return 'variable';
        
        return 'expression';
    }

    // Parse function parameters
    parseParameters(paramsStr) {
        const params = [];
        if (!paramsStr || !paramsStr.trim() || paramsStr.trim() === 'void') return params;
        
        const parts = paramsStr.split(',');
        for (const part of parts) {
            const trimmed = part.trim();
            if (!trimmed) continue;
            
            // Extract parameter name - it's the last identifier before optional array brackets
            // Handles: int x, const char *ptr, struct foo *bar, int arr[], void (*callback)(int)
            const match = trimmed.match(/(\w+)\s*(?:\[[\d\s]*\])?\s*$/);
            if (match) {
                params.push({ name: match[1], full: trimmed });
            }
        }
        
        return params;
    }

    // Parse all functions from code
    parseFunctions(code, file) {
        const cleanCode = this.removeComments(code);
        
        // Match function definitions
        const funcRegex = /\b([a-zA-Z_]\w*)\s*\(([^)]*)\)\s*\{/g;
        let m;
        
        while ((m = funcRegex.exec(cleanCode)) !== null) {
            const name = m[1];
            const paramsStr = m[2];
            
            if (!this.isValidFunc(name)) continue;
            if (this.functions.has(name)) continue;
            
            const params = this.parseParameters(paramsStr);
            const bodyStart = m.index + m[0].length;
            const bodyEnd = this.findMatchingBrace(cleanCode, bodyStart);
            
            if (bodyEnd === -1) continue;
            
            const body = cleanCode.substring(bodyStart - 1, bodyEnd);
            
            // Extract all calls with arguments
            const calls = this.extractAllCalls(body, name);
            
            // Parse variable origins
            this.parseVariableOrigins(name, body, params);
            
            // Build simple call map for path finding
            const callMap = new Map();
            for (const call of calls) {
                if (!callMap.has(call.callee)) {
                    callMap.set(call.callee, { type: 'direct' });
                }
            }
            
            this.functions.set(name, {
                name,
                file,
                params,
                body,
                calls: callMap,
                callDetails: calls
            });
            
            this.addLog('parse', `${file}: ${name}(${params.map(p=>p.name).join(', ')}) - ${calls.length} calls found`);
        }
    }

    buildGraph() {
        for (const [name, func] of this.functions) {
            this.callGraph.set(name, func.calls);
        }
        this.addLog('info', `Call graph built: ${this.functions.size} functions`);
    }

    parseFile(filename, content) {
        this.files.set(filename, content);
        try {
            this.parseMacros(content, filename);
            this.parseFunctions(content, filename);
        } catch (e) {
            this.addLog('error', `Error in ${filename}: ${e.message}`);
        }
    }

    findPaths(entry, target, maxDepth = 30, maxPaths = 100, maxTime = 5000) {
        const paths = [];
        const startTime = Date.now();
        
        if (!this.callGraph.has(entry)) {
            this.addLog('error', `Entry function '${entry}' not found!`);
            return paths;
        }

        const dfs = (current, path, visited) => {
            if (Date.now() - startTime > maxTime) return;
            if (paths.length >= maxPaths) return;
            if (path.length > maxDepth) return;
            if (visited.has(current)) return;

            if (current === target) {
                paths.push([...path]);
                return;
            }

            visited.add(current);
            const calls = this.callGraph.get(current);
            if (calls) {
                for (const [callee] of calls) {
                    path.push({ name: callee });
                    dfs(callee, path, visited);
                    path.pop();
                }
            }
            visited.delete(current);
        };

        dfs(entry, [{ name: entry }], new Set());
        this.addLog('info', `Found ${paths.length} paths in ${Date.now() - startTime}ms`);
        return paths;
    }

    // =====================================================
    // ROBUST ARGUMENT FLOW TRACKING
    // =====================================================

    traceArgumentFlow(targetFunc, argPosition, paths) {
        this.addLog('arg', `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);
        this.addLog('arg', `TRACING ARG #${argPosition} OF ${targetFunc}()`);
        this.addLog('arg', `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);
        
        const results = [];
        
        for (let pathIdx = 0; pathIdx < paths.length; pathIdx++) {
            const path = paths[pathIdx];
            this.addLog('arg', ``);
            this.addLog('arg', `‚îÄ‚îÄ‚îÄ PATH ${pathIdx + 1}: ${path.map(p => p.name).join(' ‚Üí ')} ‚îÄ‚îÄ‚îÄ`);
            
            const trace = this.traceArgInPath(targetFunc, argPosition, path);
            results.push({
                pathIndex: pathIdx + 1,
                path,
                trace
            });
        }
        
        return results;
    }

    traceArgInPath(targetFunc, argPosition, path) {
        const trace = {
            targetFunc,
            argPosition,
            steps: [],
            origin: null,
            debug: []
        };
        
        let currentArgPos = argPosition;
        let currentVarName = null;
        
        // Walk backwards through the path
        for (let i = path.length - 1; i >= 0; i--) {
            const funcName = path[i].name;
            const funcInfo = this.functions.get(funcName);
            
            trace.debug.push(`[Step ${path.length - i}] Function: ${funcName}`);
            
            if (!funcInfo) {
                trace.debug.push(`  ‚ö† Not found in parsed functions`);
                continue;
            }
            
            // If this is the target function itself, just note it and continue to find its caller
            if (funcName === targetFunc && i === path.length - 1) {
                trace.debug.push(`  ‚Üí Target function, looking for caller...`);
                
                // Check if the target function has that parameter defined
                if (funcInfo.params[currentArgPos - 1]) {
                    currentVarName = funcInfo.params[currentArgPos - 1].name;
                    trace.debug.push(`  ‚Üí Target's param #${currentArgPos} is named: ${currentVarName}`);
                }
                continue;
            }
            
            // Get the next function in path (the one this function calls)
            const nextFuncName = path[i + 1]?.name;
            if (!nextFuncName) {
                trace.debug.push(`  ‚ö† No next function in path`);
                continue;
            }
            
            trace.debug.push(`  ‚Üí Looking for calls to ${nextFuncName}()`);
            
            // Find all calls from this function to the next function
            const callDetails = funcInfo.callDetails || [];
            const callsToNext = callDetails.filter(c => c.callee === nextFuncName);
            
            trace.debug.push(`  ‚Üí Found ${callsToNext.length} call(s) to ${nextFuncName}`);
            
            if (callsToNext.length === 0) {
                trace.debug.push(`  ‚ö† WARNING: No direct calls found!`);
                // Try to continue anyway - might be indirect call
                continue;
            }
            
            // Process the first matching call (could be enhanced to handle multiple)
            const call = callsToNext[0];
            trace.debug.push(`  ‚Üí Call: ${call.callee}(${call.argsRaw})`);
            trace.debug.push(`  ‚Üí Parsed ${call.args.length} arguments:`);
            call.args.forEach((a, idx) => {
                trace.debug.push(`      [${idx + 1}] = "${a}"`);
            });
            
            // Get the argument at current position
            const argValue = call.args[currentArgPos - 1];
            
            if (argValue === undefined || argValue === null) {
                trace.debug.push(`  ‚ö† Arg #${currentArgPos} NOT FOUND (call has ${call.args.length} args)`);
                // Maybe arg count changed, try to find by name if we have it
                if (currentVarName) {
                    const foundIdx = call.args.findIndex(a => a.trim() === currentVarName);
                    if (foundIdx !== -1) {
                        trace.debug.push(`  ‚Üí Found "${currentVarName}" at position ${foundIdx + 1} instead`);
                        currentArgPos = foundIdx + 1;
                    }
                }
                continue;
            }
            
            trace.debug.push(`  ‚úì Arg #${currentArgPos} = "${argValue}"`);
            
            // Record this step
            trace.steps.push({
                func: funcName,
                file: funcInfo.file,
                callsFunc: nextFuncName,
                argPos: currentArgPos,
                argValue: argValue,
                line: call.line,
                context: call.context
            });
            
            // Now trace where this value comes from in this function
            const origins = this.varOrigins.get(funcName);
            
            // Check 1: Is it a parameter of this function?
            const paramIdx = funcInfo.params.findIndex(p => p.name === argValue);
            if (paramIdx !== -1) {
                trace.debug.push(`  ‚Üí "${argValue}" is PARAMETER #${paramIdx + 1} of ${funcName}()`);
                currentArgPos = paramIdx + 1;
                currentVarName = argValue;
                continue; // Continue tracing upward
            }
            
            // Check 2: Do we have origin info for this variable?
            if (origins && origins.has(argValue)) {
                const varInfo = origins.get(argValue);
                trace.debug.push(`  ‚Üí "${argValue}" origin: ${varInfo.type} = "${varInfo.value}"`);
                
                if (varInfo.type === 'parameter') {
                    // It's a parameter - continue tracing
                    currentArgPos = varInfo.paramIndex + 1;
                    currentVarName = argValue;
                    continue;
                }
                
                // Found the actual origin!
                trace.origin = {
                    func: funcName,
                    file: funcInfo.file,
                    type: varInfo.type,
                    value: varInfo.value,
                    variable: argValue,
                    line: varInfo.line
                };
                trace.debug.push(`  ‚úì‚úì ORIGIN FOUND: ${varInfo.type}`);
                break;
            }
            
            // Check 3: Classify the value directly
            const valueType = this.classifyValue(argValue);
            trace.debug.push(`  ‚Üí Direct value classified as: ${valueType}`);
            
            // Check 4: If it's a simple variable name, might be from somewhere we didn't track
            if (valueType === 'variable') {
                // It's a variable but we don't know its origin
                // Could be a global, or assignment we missed
                trace.debug.push(`  ‚Üí Unknown variable "${argValue}" - treating as origin`);
            }
            
            // Set as origin (literal, expression, member access, etc.)
            trace.origin = {
                func: funcName,
                file: funcInfo.file,
                type: valueType,
                value: argValue,
                variable: valueType === 'variable' ? argValue : null,
                line: call.line
            };
            trace.debug.push(`  ‚úì‚úì ORIGIN SET: ${valueType}`);
            break;
        }
        
        // If we traced all the way to the entry function without finding origin
        if (!trace.origin && path.length > 0) {
            const entryFunc = this.functions.get(path[0].name);
            if (entryFunc && entryFunc.params[currentArgPos - 1]) {
                const paramName = entryFunc.params[currentArgPos - 1].name;
                trace.origin = {
                    func: path[0].name,
                    file: entryFunc.file,
                    type: 'entry-parameter',
                    value: paramName,
                    variable: paramName,
                    line: 0
                };
                trace.debug.push(`‚Üí Traced to entry: parameter "${paramName}"`);
            } else {
                trace.debug.push(`‚ö† Could not find origin - trace incomplete`);
            }
        }
        
        return trace;
    }
}

// =====================================================
// UI CONTROLLER
// =====================================================
class UI {
    constructor() {
        this.files = new Map();
        this.parser = null;
        this.results = null;
        this.argResults = null;
        this.currentTab = 'tree';
        this.init();
    }

    init() {
        this.uploadZone = document.getElementById('uploadZone');
        this.fileInput = document.getElementById('fileInput');
        this.fileList = document.getElementById('fileList');
        this.analyzeBtn = document.getElementById('analyzeBtn');
        this.clearBtn = document.getElementById('clearBtn');
        this.traceArgBtn = document.getElementById('traceArgBtn');
        this.output = document.getElementById('output');
        this.statsCard = document.getElementById('statsCard');

        this.uploadZone.addEventListener('click', () => this.fileInput.click());
        this.fileInput.addEventListener('change', e => this.handleFiles(e.target.files));
        
        this.uploadZone.addEventListener('dragover', e => { e.preventDefault(); this.uploadZone.style.borderColor = 'var(--cyan)'; });
        this.uploadZone.addEventListener('dragleave', () => { this.uploadZone.style.borderColor = ''; });
        this.uploadZone.addEventListener('drop', e => { e.preventDefault(); this.uploadZone.style.borderColor = ''; this.handleFiles(e.dataTransfer.files); });

        this.analyzeBtn.addEventListener('click', () => this.analyze());
        this.clearBtn.addEventListener('click', () => this.clear());
        this.traceArgBtn.addEventListener('click', () => this.traceArgument());

        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => this.switchTab(tab.dataset.tab));
        });
    }

    handleFiles(fileList) {
        for (const file of fileList) {
            const ext = file.name.split('.').pop().toLowerCase();
            if (['c', 'h', 'cpp', 'hpp'].includes(ext)) {
                const reader = new FileReader();
                reader.onload = e => { this.files.set(file.name, e.target.result); this.updateFileList(); };
                reader.readAsText(file);
            }
        }
    }

    updateFileList() {
        this.fileList.innerHTML = '';
        for (const name of this.files.keys()) {
            const ext = name.split('.').pop().toLowerCase();
            const type = ['h', 'hpp'].includes(ext) ? 'h' : 'c';
            const item = document.createElement('div');
            item.className = 'file-item';
            item.innerHTML = `<span><span class="type ${type}">${type.toUpperCase()}</span>${name}</span><button class="remove" data-file="${name}">√ó</button>`;
            this.fileList.appendChild(item);
        }
        this.fileList.querySelectorAll('.remove').forEach(btn => {
            btn.addEventListener('click', () => { this.files.delete(btn.dataset.file); this.updateFileList(); });
        });
        this.analyzeBtn.disabled = this.files.size === 0;
        this.traceArgBtn.disabled = this.files.size === 0;
        this.uploadZone.classList.toggle('has-files', this.files.size > 0);
    }

    async analyze() {
        const entry = document.getElementById('entryFunc').value.trim();
        const target = document.getElementById('targetFunc').value.trim();

        if (!entry || !target) { alert('Enter entry and target function names'); return; }

        this.output.innerHTML = `<div class="progress"><div class="progress-bar"><div class="progress-fill" style="width: 10%"></div></div><p class="progress-text">Parsing...</p></div>`;
        await this.delay(30);

        try {
            this.parser = new CParser();
            const bar = this.output.querySelector('.progress-fill');
            const txt = this.output.querySelector('.progress-text');

            let count = 0;
            // Parse headers first
            for (const [name, content] of this.files) {
                if (['h', 'hpp'].includes(name.split('.').pop().toLowerCase())) {
                    this.parser.parseFile(name, content);
                    count++;
                    bar.style.width = (10 + (count / this.files.size) * 40) + '%';
                    txt.textContent = `Parsing ${name}...`;
                    await this.delay(5);
                }
            }
            // Parse source files
            for (const [name, content] of this.files) {
                if (['c', 'cpp'].includes(name.split('.').pop().toLowerCase())) {
                    this.parser.parseFile(name, content);
                    count++;
                    bar.style.width = (10 + (count / this.files.size) * 40) + '%';
                    txt.textContent = `Parsing ${name}...`;
                    await this.delay(5);
                }
            }

            bar.style.width = '80%'; txt.textContent = 'Building graph...';
            await this.delay(20);
            this.parser.buildGraph();

            bar.style.width = '90%'; txt.textContent = 'Finding paths...';
            await this.delay(20);
            const paths = this.parser.findPaths(entry, target, 30, 100, 5000);

            this.results = { entry, target, paths };

            document.getElementById('statFiles').textContent = this.files.size;
            document.getElementById('statFuncs').textContent = this.parser.functions.size;
            document.getElementById('statPaths').textContent = paths.length;
            this.statsCard.style.display = 'block';

            this.switchTab(this.currentTab);
        } catch (error) {
            console.error(error);
            this.output.innerHTML = `<div class="error"><strong>Error:</strong> ${error.message}<br><br>${error.stack}</div>`;
        }
    }

    async traceArgument() {
        const targetFunc = document.getElementById('argTargetFunc').value.trim();
        const argPosition = parseInt(document.getElementById('argPosition').value);
        const argName = document.getElementById('argName').value.trim();

        if (!this.parser || !this.results) { alert('Run "Analyze Call Paths" first'); return; }

        this.output.innerHTML = `<div class="progress"><div class="progress-bar"><div class="progress-fill" style="width: 50%"></div></div><p class="progress-text">Tracing arg #${argPosition}${argName ? ` (${argName})` : ''} of ${targetFunc}...</p></div>`;
        await this.delay(50);

        try {
            let pathsToTarget = this.results.paths;
            if (targetFunc !== this.results.target) {
                pathsToTarget = this.parser.findPaths(this.results.entry, targetFunc, 30, 100, 5000);
            }

            if (pathsToTarget.length === 0) {
                this.output.innerHTML = `<div class="error">No paths found to ${targetFunc}()</div>`;
                return;
            }

            this.argResults = {
                targetFunc,
                argPosition,
                argName,
                traces: this.parser.traceArgumentFlow(targetFunc, argPosition, pathsToTarget)
            };

            this.switchTab('argflow');
        } catch (error) {
            console.error(error);
            this.output.innerHTML = `<div class="error"><strong>Error:</strong> ${error.message}</div>`;
        }
    }

    delay(ms) { return new Promise(r => setTimeout(r, ms)); }

    switchTab(tab) {
        this.currentTab = tab;
        document.querySelectorAll('.tab').forEach(t => t.classList.toggle('active', t.dataset.tab === tab));
        if (!this.results && !this.parser) return;

        switch (tab) {
            case 'tree': this.renderTree(); break;
            case 'paths': this.renderPaths(); break;
            case 'argflow': this.renderArgFlow(); break;
            case 'calls': this.renderCalls(); break;
            case 'debug': this.renderDebug(); break;
        }
    }

    renderTree() {
        if (!this.results || this.results.paths.length === 0) {
            this.output.innerHTML = `<div style="color:var(--text-muted);text-align:center;padding:50px;">No paths found</div>`;
            return;
        }

        const root = { name: this.results.entry, children: new Map() };
        for (const path of this.results.paths) {
            let node = root;
            for (let i = 1; i < path.length; i++) {
                if (!node.children.has(path[i].name)) {
                    node.children.set(path[i].name, { name: path[i].name, children: new Map() });
                }
                node = node.children.get(path[i].name);
            }
        }

        let html = '';
        const render = (node, prefix = '', isLast = true, isRoot = false) => {
            const conn = isRoot ? '' : (isLast ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ ');
            const isTarget = node.name === this.results.target;
            const isEntry = node.name === this.results.entry;
            let cls = 'c-inter';
            if (isEntry) cls = 'c-entry';
            else if (isTarget) cls = 'c-target';
            const marker = isTarget ? ' ‚òÖ' : '';
            const file = this.parser.functions.get(node.name)?.file;
            const fileRef = file ? ` <span class="c-muted">[${file}]</span>` : '';
            html += `${prefix}${conn}<span class="${cls}">${node.name}</span>${marker}${fileRef}\n`;
            const children = [...node.children.values()];
            const newPrefix = prefix + (isRoot ? '' : (isLast ? '    ' : '‚îÇ   '));
            children.forEach((child, i) => render(child, newPrefix, i === children.length - 1));
        };
        render(root, '', true, true);
        this.output.innerHTML = html;
    }

    renderPaths() {
        if (!this.results || this.results.paths.length === 0) {
            this.output.innerHTML = `<div style="color:var(--text-muted);text-align:center;padding:50px;">No paths found</div>`;
            return;
        }
        let html = `<span class="c-green">Found ${this.results.paths.length} paths from ${this.results.entry}() to ${this.results.target}()</span>\n\n`;
        this.results.paths.forEach((path, i) => {
            html += `<span class="c-yellow">Path ${i + 1}</span> <span class="c-muted">(depth ${path.length})</span>\n`;
            html += `  ${path.map((p, j) => j === path.length - 1 ? `<span class="c-target">${p.name}</span>` : `<span class="c-inter">${p.name}</span>`).join(' ‚Üí ')}\n\n`;
        });
        this.output.innerHTML = html;
    }

    renderArgFlow() {
        if (!this.argResults) {
            this.output.innerHTML = `<div style="color:var(--text-muted);text-align:center;padding:50px;">Click "Trace Argument Origin" to analyze argument flow</div>`;
            return;
        }

        const { targetFunc, argPosition, argName, traces } = this.argResults;

        let html = `<div class="arg-box">
            <div class="arg-box-title">
                <span>üéØ Tracking: ${targetFunc}() ‚Üí Arg #${argPosition}${argName ? ` (${argName})` : ''}</span>
                <span class="arg-box-badge">${traces.length} path(s) analyzed</span>
            </div>
        </div>`;

        // Group traces by origin
        const byOrigin = new Map();
        const noOrigin = [];
        
        for (const t of traces) {
            if (t.trace.origin) {
                const key = `${t.trace.origin.func}::${t.trace.origin.value}::${t.trace.origin.type}`;
                if (!byOrigin.has(key)) {
                    byOrigin.set(key, { origin: t.trace.origin, traces: [] });
                }
                byOrigin.get(key).traces.push(t);
            } else {
                noOrigin.push(t);
            }
        }

        if (byOrigin.size === 0) {
            html += `<div class="warning">‚ö†Ô∏è Could not determine argument origin. Check the Debug tab for details.</div>`;
            
            // Show debug info for first trace
            if (traces.length > 0 && traces[0].trace.debug.length > 0) {
                html += `<div class="debug-box"><div class="debug-title">Debug trace for Path 1:</div>`;
                for (const d of traces[0].trace.debug) {
                    html += `<span class="c-muted">${this.esc(d)}</span>\n`;
                }
                html += `</div>`;
            }
        } else {
            html += `<div class="success">‚úì Found <strong>${byOrigin.size}</strong> unique origin(s) for argument #${argPosition}</div>`;

            let idx = 0;
            for (const [key, data] of byOrigin) {
                idx++;
                const origin = data.origin;

                html += `<div class="arg-box">
                    <div class="arg-box-title">
                        <span>Origin #${idx}: ${origin.func}()</span>
                        <span class="arg-box-badge">${origin.type}</span>
                    </div>
                    
                    <div class="arg-step origin">
                        <div class="arg-step-header">
                            <span class="arg-step-func">üìç ${origin.func}()</span>
                            <span class="arg-step-file">${origin.file}${origin.line ? `:${origin.line}` : ''}</span>
                        </div>
                        <div class="arg-step-detail">
                            Value: <code>${this.esc(origin.value)}</code>
                            ${origin.variable ? `<br>Variable: <code>${origin.variable}</code>` : ''}
                            <br>Type: <code>${origin.type}</code>
                        </div>
                    </div>`;

                // Show flow steps from first trace
                const firstTrace = data.traces[0];
                if (firstTrace.trace.steps.length > 0) {
                    html += `<div style="margin:8px 0 4px;color:var(--text-muted);font-size:0.65rem;">Call chain flow:</div>`;
                    
                    for (let i = firstTrace.trace.steps.length - 1; i >= 0; i--) {
                        const step = firstTrace.trace.steps[i];
                        html += `<div class="arg-step">
                            <div class="arg-step-header">
                                <span class="arg-step-func">${step.func}()</span>
                                <span class="arg-step-file">${step.file}:${step.line || '?'}</span>
                            </div>
                            <div class="arg-step-detail">
                                Passes <code>${this.esc(step.argValue)}</code> as arg #${step.argPos} ‚Üí ${step.callsFunc}()
                            </div>
                        </div>`;
                    }
                }

                html += `<div style="margin-top:6px;font-size:0.65rem;color:var(--text-muted);">
                    Used in ${data.traces.length} path(s): ${data.traces.map(t => '#' + t.pathIndex).join(', ')}
                </div></div>`;
            }
        }

        // Show paths without origin
        if (noOrigin.length > 0) {
            html += `<div class="warning" style="margin-top:10px;">
                ‚ö†Ô∏è ${noOrigin.length} path(s) could not be traced: ${noOrigin.map(t => '#' + t.pathIndex).join(', ')}
            </div>`;
        }

        this.output.innerHTML = html;
    }

    renderCalls() {
        if (!this.parser) return;
        
        let html = '<span class="c-green">All Function Calls with Arguments</span>\n\n';
        
        for (const [funcName, calls] of this.parser.allCalls) {
            if (calls.length === 0) continue;
            
            html += `<span class="c-inter">${funcName}</span>():\n`;
            for (const call of calls) {
                html += `  <span class="c-muted">L${String(call.line).padStart(3)}</span> ‚îÇ ${call.callee}(`;
                if (call.args.length > 0) {
                    html += call.args.map((a, i) => `<span class="c-yellow">${i+1}:</span>${this.esc(a)}`).join(', ');
                }
                html += `)\n`;
            }
            html += '\n';
        }
        
        this.output.innerHTML = html;
    }

    renderDebug() {
        if (!this.parser) return;
        
        let html = '<span class="c-green">Parser Debug Log</span>\n\n';
        
        for (const entry of this.parser.log) {
            let cls = 'c-muted';
            if (entry.type === 'error') cls = 'c-red';
            else if (entry.type === 'arg') cls = 'c-yellow';
            else if (entry.type === 'info') cls = 'c-cyan';
            else if (entry.type === 'parse') cls = 'c-purple';
            
            html += `<span class="${cls}">[${entry.type.toUpperCase().padEnd(5)}]</span> ${this.esc(entry.msg)}\n`;
        }
        
        this.output.innerHTML = html || '<span class="c-muted">No log entries</span>';
    }

    esc(text) {
        if (text === null || text === undefined) return '';
        const div = document.createElement('div');
        div.textContent = String(text);
        return div.innerHTML;
    }

    clear() {
        this.files.clear();
        this.parser = null;
        this.results = null;
        this.argResults = null;
        this.updateFileList();
        this.statsCard.style.display = 'none';
        this.output.innerHTML = `<div style="color:var(--text-muted);text-align:center;padding:50px;">Upload C files and click Analyze</div>`;
    }
}

document.addEventListener('DOMContentLoaded', () => new UI());
</script>
</body>
</html>
