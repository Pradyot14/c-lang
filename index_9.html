<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C Call Tracer - Strict Linkage</title>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --border: #30363d;
            --text: #c9d1d9;
            --text-muted: #8b949e;
            --cyan: #58a6ff;
            --green: #3fb950;
            --purple: #a371f7;
            --pink: #f778ba;
            --orange: #d29922;
            --red: #f85149;
            --yellow: #e3b341;
            --teal: #39d3c3;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: var(--bg-primary); color: var(--text); min-height: 100vh; }
        .container { max-width: 1600px; margin: 0 auto; padding: 20px; }
        header { text-align: center; padding: 20px 0; border-bottom: 1px solid var(--border); margin-bottom: 20px; }
        h1 { color: var(--cyan); font-size: 1.8rem; margin-bottom: 5px; }
        .subtitle { color: var(--text-muted); font-size: 0.9rem; }
        
        .main-grid { display: grid; grid-template-columns: 350px 1fr; gap: 20px; }
        @media (max-width: 1000px) { .main-grid { grid-template-columns: 1fr; } }
        
        .card { background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 8px; padding: 16px; margin-bottom: 16px; }
        .card-title { color: var(--cyan); font-size: 0.95rem; font-weight: 600; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid var(--border); }
        
        .upload-zone { border: 2px dashed var(--border); border-radius: 8px; padding: 25px; text-align: center; cursor: pointer; transition: all 0.2s; }
        .upload-zone:hover { border-color: var(--cyan); background: rgba(88, 166, 255, 0.05); }
        .upload-zone.has-files { border-color: var(--green); border-style: solid; }
        .upload-zone p { color: var(--text-muted); margin-bottom: 8px; }
        .upload-zone .badge { display: inline-block; background: var(--bg-tertiary); color: var(--cyan); padding: 3px 8px; border-radius: 4px; font-size: 0.75rem; margin: 2px; font-family: monospace; }
        
        .file-list { max-height: 150px; overflow-y: auto; margin-top: 10px; }
        .file-item { display: flex; justify-content: space-between; align-items: center; background: var(--bg-tertiary); padding: 6px 10px; border-radius: 4px; margin-bottom: 4px; font-size: 0.8rem; font-family: monospace; }
        .file-item .type { padding: 2px 6px; border-radius: 3px; font-size: 0.7rem; margin-right: 8px; }
        .file-item .type.c { background: rgba(63, 185, 80, 0.2); color: var(--green); }
        .file-item .type.h { background: rgba(163, 113, 247, 0.2); color: var(--purple); }
        .file-item .remove { background: none; border: none; color: var(--text-muted); cursor: pointer; font-size: 1rem; }
        .file-item .remove:hover { color: var(--red); }
        
        .form-group { margin-bottom: 12px; }
        .form-group label { display: block; color: var(--text-muted); font-size: 0.8rem; margin-bottom: 4px; }
        .form-group input, .form-group select { width: 100%; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 4px; padding: 8px 10px; color: var(--text); font-family: monospace; }
        .form-group input:focus { outline: none; border-color: var(--cyan); }
        
        .form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .form-row-3 { display: grid; grid-template-columns: 1fr 70px 80px; gap: 8px; }
        
        .btn { width: 100%; padding: 12px; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; transition: all 0.2s; }
        .btn-primary { background: var(--cyan); color: #000; }
        .btn-primary:hover { opacity: 0.9; }
        .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-secondary { background: var(--bg-tertiary); color: var(--text); border: 1px solid var(--border); margin-top: 8px; }
        .btn-arg { background: linear-gradient(135deg, var(--yellow), var(--orange)); color: #000; margin-top: 8px; }
        
        .stats { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-top: 12px; }
        .stat { background: var(--bg-tertiary); padding: 10px; border-radius: 4px; text-align: center; }
        .stat-val { font-size: 1.4rem; font-weight: 700; color: var(--cyan); }
        .stat-label { font-size: 0.7rem; color: var(--text-muted); }
        
        .tabs { display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap; }
        .tab { padding: 8px 16px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 4px; color: var(--text-muted); cursor: pointer; font-size: 0.85rem; }
        .tab:hover { border-color: var(--cyan); color: var(--text); }
        .tab.active { background: rgba(88, 166, 255, 0.1); border-color: var(--cyan); color: var(--cyan); }
        .tab.arg-tab { border-color: var(--yellow); }
        .tab.arg-tab.active { background: rgba(227, 179, 65, 0.15); border-color: var(--yellow); color: var(--yellow); }
        
        .output { background: var(--bg-tertiary); border-radius: 6px; padding: 16px; min-height: 400px; max-height: 600px; overflow: auto; font-family: 'Monaco', 'Menlo', monospace; font-size: 0.8rem; line-height: 1.5; white-space: pre-wrap; }
        
        .progress { padding: 20px; text-align: center; }
        .progress-bar { height: 4px; background: var(--border); border-radius: 2px; margin: 15px 0; overflow: hidden; }
        .progress-fill { height: 100%; background: var(--cyan); transition: width 0.3s; }
        .progress-text { color: var(--text-muted); font-size: 0.85rem; }
        
        .error { background: rgba(248, 81, 73, 0.1); border: 1px solid var(--red); border-radius: 6px; padding: 16px; color: var(--red); }
        .warning { background: rgba(210, 153, 34, 0.1); border: 1px solid var(--orange); border-radius: 6px; padding: 12px; color: var(--orange); margin-bottom: 10px; }
        .success { background: rgba(63, 185, 80, 0.1); border: 1px solid var(--green); border-radius: 6px; padding: 12px; color: var(--green); margin-bottom: 10px; }
        
        .legend { display: flex; flex-wrap: wrap; gap: 12px; margin-bottom: 12px; padding: 10px; background: var(--bg-tertiary); border-radius: 4px; }
        .legend-item { display: flex; align-items: center; gap: 6px; font-size: 0.75rem; color: var(--text-muted); }
        .legend-color { width: 12px; height: 12px; border-radius: 2px; }
        
        .func-entry { color: var(--cyan); }
        .func-target { color: var(--green); font-weight: bold; }
        .func-inter { color: var(--purple); }
        .func-macro { color: var(--pink); }
        .func-ptr { color: #58a6ff; }
        .func-ext { color: var(--orange); }
        .func-arg { color: var(--teal); }
        .file-ref { color: var(--text-muted); }
        
        .path-item { background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 6px; padding: 12px; margin-bottom: 8px; }
        .path-header { display: flex; justify-content: space-between; margin-bottom: 8px; }
        .path-num { background: var(--cyan); color: #000; padding: 2px 8px; border-radius: 10px; font-size: 0.75rem; font-weight: 600; }
        .path-chain { font-family: monospace; font-size: 0.8rem; display: flex; flex-wrap: wrap; gap: 4px; align-items: center; }
        .path-chain .func { background: var(--bg-tertiary); padding: 2px 6px; border-radius: 3px; }
        .path-chain .func.target { background: rgba(63, 185, 80, 0.2); color: var(--green); }
        .path-chain .arrow { color: var(--cyan); }
        
        .arg-box { background: var(--bg-secondary); border: 1px solid var(--yellow); border-radius: 8px; padding: 12px; margin-bottom: 12px; }
        .arg-box-title { color: var(--yellow); font-weight: 600; margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center; }
        .arg-box-badge { background: rgba(227, 179, 65, 0.2); color: var(--yellow); padding: 2px 10px; border-radius: 12px; font-size: 0.7rem; }
        .arg-step { background: var(--bg-tertiary); border-radius: 6px; padding: 10px; margin-bottom: 6px; border-left: 3px solid var(--purple); }
        .arg-step.origin { border-left-color: var(--green); background: rgba(63, 185, 80, 0.05); }
        .arg-step-func { color: var(--purple); font-weight: 600; }
        .arg-step.origin .arg-step-func { color: var(--green); }
        .arg-step-file { color: var(--text-muted); font-size: 0.75rem; }
        .arg-step-detail { margin-top: 4px; }
        .arg-step-detail code { background: var(--bg-secondary); padding: 1px 5px; border-radius: 3px; color: var(--yellow); }
        
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg-tertiary); }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üîç C Call Tracer - Strict Linkage (v9)</h1>
            <p class="subtitle">Only includes calls with verified header linkage. Upload both .c AND .h files!</p>
        </header>
        
        <div class="main-grid">
            <div class="sidebar">
                <div class="card">
                    <div class="card-title">üìÅ Upload Files</div>
                    <div class="upload-zone" id="uploadZone">
                        <p>Drop .c and .h files here</p>
                        <p style="color:var(--orange);font-size:0.75rem;">‚ö†Ô∏è Must include header files for linkage!</p>
                        <div>
                            <span class="badge">.c</span>
                            <span class="badge">.h</span>
                        </div>
                        <input type="file" id="fileInput" multiple accept=".c,.h,.cpp,.hpp" hidden>
                    </div>
                    <div class="file-list" id="fileList"></div>
                </div>
                
                <div class="card">
                    <div class="card-title">‚öôÔ∏è Configuration</div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Entry Function</label>
                            <input type="text" id="entryFunc" value="main">
                        </div>
                        <div class="form-group">
                            <label>Target Function</label>
                            <input type="text" id="targetFunc" value="mpf_mfs_open">
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Max Search Depth</label>
                        <input type="number" id="maxDepth" value="30" min="5" max="100">
                    </div>
                    <button class="btn btn-primary" id="analyzeBtn" disabled>üî¨ Analyze</button>
                    <button class="btn btn-secondary" id="clearBtn">Clear All</button>
                </div>
                
                <div class="card">
                    <div class="card-title">üîÑ Argument Flow Tracking</div>
                    <div class="form-row-3">
                        <div class="form-group">
                            <label>Target Function</label>
                            <input type="text" id="argTargetFunc" value="mpf_mfs_open">
                        </div>
                        <div class="form-group">
                            <label>Arg #</label>
                            <select id="argPosition">
                                <option value="1">1st</option>
                                <option value="2">2nd</option>
                                <option value="3" selected>3rd</option>
                                <option value="4">4th</option>
                                <option value="5">5th</option>
                                <option value="6">6th</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Name</label>
                            <input type="text" id="argName" value="filenum">
                        </div>
                    </div>
                    <button class="btn btn-arg" id="traceArgBtn" disabled>üîÑ Trace Argument</button>
                </div>
                
                <div class="card" id="statsCard" style="display:none;">
                    <div class="card-title">üìä Results</div>
                    <div class="stats">
                        <div class="stat"><div class="stat-val" id="statFiles">0</div><div class="stat-label">Files</div></div>
                        <div class="stat"><div class="stat-val" id="statFuncs">0</div><div class="stat-label">Functions</div></div>
                        <div class="stat"><div class="stat-val" id="statMacros">0</div><div class="stat-label">Macros</div></div>
                        <div class="stat"><div class="stat-val" id="statPaths">0</div><div class="stat-label">Paths</div></div>
                        <div class="stat"><div class="stat-val" id="statDepth">0</div><div class="stat-label">Max Depth</div></div>
                        <div class="stat"><div class="stat-val" id="statTime">0</div><div class="stat-label">ms</div></div>
                    </div>
                </div>
            </div>
            
            <div class="results">
                <div class="card" style="height: 100%;">
                    <div class="tabs">
                        <button class="tab active" data-tab="tree">Text Tree</button>
                        <button class="tab" data-tab="paths">All Paths</button>
                        <button class="tab arg-tab" data-tab="argflow">üîÑ Arg Flow</button>
                        <button class="tab" data-tab="funcs">Functions</button>
                        <button class="tab" data-tab="linkage">Linkage</button>
                        <button class="tab" data-tab="types">Types</button>
                        <button class="tab" data-tab="log">Log</button>
                    </div>
                    
                    <div class="legend">
                        <div class="legend-item"><div class="legend-color" style="background:var(--cyan)"></div>Entry</div>
                        <div class="legend-item"><div class="legend-color" style="background:var(--green)"></div>Target</div>
                        <div class="legend-item"><div class="legend-color" style="background:var(--purple)"></div>Linked Call</div>
                        <div class="legend-item"><div class="legend-color" style="background:var(--pink)"></div>Macro</div>
                        <div class="legend-item"><div class="legend-color" style="background:var(--teal)"></div>Func Ptr</div>
                    </div>
                    
                    <div class="output" id="output">
                        <div style="color:var(--text-muted);text-align:center;padding:50px;">
                            Upload C files <strong>AND their header files</strong> to trace call paths.<br><br>
                            <span style="color:var(--orange);">‚ö†Ô∏è Without headers, external function calls cannot be verified!</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

<script>
// =============================================================================
// STRICT LINKAGE PARSER - v9
// Only includes calls that can be verified through header inclusion
// =============================================================================
class StrictParser {
    constructor() {
        this.files = new Map();              // filename -> content
        this.fileTypes = new Map();          // filename -> 'c' | 'h'
        
        // Include tracking
        this.fileIncludes = new Map();       // file -> Set<headerBasename>
        
        // Declaration tracking - WHERE things are declared/defined
        this.functionDefinitions = new Map();   // funcName -> {file, params, body}
        this.functionDeclarations = new Map();  // funcName -> Set<files where declared>
        this.macroDefinitions = new Map();      // macroName -> {file, params, body, calls}
        this.typeDefinitions = new Map();       // typeName -> {file, kind, isFuncPtr, details}
        
        // Variable type tracking
        this.globalVarTypes = new Map();        // varName -> {type, file, isFuncPtr}
        this.funcParamTypes = new Map();        // funcName -> [{name, type, isFuncPtr}]
        this.funcLocalVarTypes = new Map();     // funcName -> Map(varName -> {type, isFuncPtr, assignedFunc})
        
        // Final call graph - only verified calls
        this.verifiedCalls = new Map();         // funcName -> Map(callee -> {type, via, linkedThrough})
        
        this.log = [];
    }

    addLog(type, msg) {
        this.log.push({ type, msg });
        console.log(`[${type}] ${msg}`);
    }

    // ==========================================================================
    // UTILITY FUNCTIONS
    // ==========================================================================
    
    getBasename(filepath) {
        return filepath.split(/[\/\\]/).pop();
    }

    isHeader(filename) {
        const ext = filename.split('.').pop().toLowerCase();
        return ['h', 'hpp'].includes(ext);
    }

    clean(code) {
        code = code.replace(/\/\*[\s\S]*?\*\//g, ' ');
        code = code.replace(/\/\/.*$/gm, '');
        code = code.replace(/"(?:[^"\\]|\\.)*"/g, '""');
        code = code.replace(/'(?:[^'\\]|\\.)*'/g, "''");
        return code;
    }

    isKeyword(name) {
        const keywords = ['if','else','while','for','do','switch','case','break','continue','return','goto','sizeof','NULL','true','false','void','int','char','float','double','long','short','unsigned','signed','const','static','extern','struct','enum','union','typedef','register','volatile','inline','restrict','_Bool','_Complex','_Imaginary','defined'];
        return keywords.includes(name);
    }

    isValidFunc(name) {
        if (this.isKeyword(name)) return false;
        if (/^\d/.test(name)) return false;
        if (name.length < 2) return false;
        return true;
    }

    findBrace(code, start, limit = 100000) {
        let depth = 1, i = start;
        const end = Math.min(code.length, start + limit);
        while (i < end && depth > 0) {
            if (code[i] === '{') depth++;
            else if (code[i] === '}') depth--;
            i++;
        }
        return depth === 0 ? i : -1;
    }

    parseArgList(argsStr) {
        if (!argsStr || !argsStr.trim()) return [];
        const args = [];
        let current = '', depth = 0;
        for (let i = 0; i < argsStr.length; i++) {
            const c = argsStr[i];
            if (c === '(' || c === '[' || c === '{') { depth++; current += c; }
            else if (c === ')' || c === ']' || c === '}') { depth--; current += c; }
            else if (c === ',' && depth === 0) { if (current.trim()) args.push(current.trim()); current = ''; }
            else { current += c; }
        }
        if (current.trim()) args.push(current.trim());
        return args;
    }

    // ==========================================================================
    // PHASE 1: Parse #include directives
    // ==========================================================================
    parseIncludes(content, file) {
        const includes = new Set();
        const regex = /#\s*include\s*[<"]([^>"]+)[>"]/g;
        let m;
        while ((m = regex.exec(content)) !== null) {
            const inc = this.getBasename(m[1]);
            includes.add(inc);
        }
        this.fileIncludes.set(file, includes);
        if (includes.size > 0) {
            this.addLog('include', `${file} ‚Üí ${[...includes].join(', ')}`);
        }
    }

    // ==========================================================================
    // PHASE 2: Parse type definitions (typedefs for function pointers)
    // ==========================================================================
    parseTypes(content, file) {
        // typedef returnType (*typeName)(params);
        const fptrTypedef = /typedef\s+([\w\s\*]+?)\s*\(\s*\*\s*(\w+)\s*\)\s*\(([^)]*)\)\s*;/g;
        let m;
        while ((m = fptrTypedef.exec(content)) !== null) {
            const typeName = m[2];
            this.typeDefinitions.set(typeName, {
                file,
                kind: 'func-ptr-typedef',
                isFuncPtr: true,
                returnType: m[1].trim(),
                params: m[3]
            });
            this.addLog('type', `${typeName} = func ptr [${file}]`);
        }

        // Check common naming conventions for function pointer types
        const simpleTypedef = /typedef\s+[\w\s\*]+\s+(\w+)\s*;/g;
        const fptrPatterns = [/_fn$/i, /_func$/i, /_cb$/i, /_callback$/i, /_handler$/i, /^fn_/i, /^cb_/i, /handler$/i, /callback$/i];
        while ((m = simpleTypedef.exec(content)) !== null) {
            const typeName = m[1];
            if (!this.typeDefinitions.has(typeName)) {
                for (const pat of fptrPatterns) {
                    if (pat.test(typeName)) {
                        this.typeDefinitions.set(typeName, {
                            file,
                            kind: 'potential-func-ptr',
                            isFuncPtr: true
                        });
                        this.addLog('type', `${typeName} = potential func ptr (naming) [${file}]`);
                        break;
                    }
                }
            }
        }
    }

    // ==========================================================================
    // PHASE 3: Parse function declarations (prototypes in headers)
    // ==========================================================================
    parseDeclarations(content, file) {
        const clean = this.clean(content);
        
        // Function declarations: type name(params);
        // Must NOT be followed by { (that would be a definition)
        const declRegex = /\b([a-zA-Z_]\w*)\s*\(([^)]*)\)\s*;/g;
        let m;
        while ((m = declRegex.exec(clean)) !== null) {
            const funcName = m[1];
            if (!this.isValidFunc(funcName)) continue;
            
            if (!this.functionDeclarations.has(funcName)) {
                this.functionDeclarations.set(funcName, new Set());
            }
            this.functionDeclarations.get(funcName).add(file);
            
            // Also parse parameter types for this declaration
            if (!this.funcParamTypes.has(funcName)) {
                this.funcParamTypes.set(funcName, this.parseParamTypes(m[2]));
            }
        }
    }

    // ==========================================================================
    // PHASE 4: Parse macro definitions
    // ==========================================================================
    parseMacros(content, file) {
        // Function-like macros
        const funcMacro = /#\s*define\s+(\w+)\s*\(([^)]*)\)\s*(.+?)(?=\n|$)/g;
        let m;
        while ((m = funcMacro.exec(content)) !== null) {
            const name = m[1];
            const params = m[2].split(',').map(p => p.trim()).filter(p => p);
            const body = m[3].replace(/\\\n/g, ' ').trim();
            
            // Find function calls in macro body
            const calls = [];
            const callRegex = /\b([a-zA-Z_]\w*)\s*\(/g;
            let cm;
            while ((cm = callRegex.exec(body)) !== null) {
                if (this.isValidFunc(cm[1]) && !params.includes(cm[1])) {
                    calls.push(cm[1]);
                }
            }
            
            this.macroDefinitions.set(name, { file, params, body, calls: [...new Set(calls)] });
            
            if (calls.length > 0) {
                this.addLog('macro', `${name}() ‚Üí [${calls.join(', ')}] [${file}]`);
            }
        }

        // Object-like macros
        const objMacro = /#\s*define\s+(\w+)\s+([^(\n][^\n]*)/g;
        while ((m = objMacro.exec(content)) !== null) {
            const name = m[1];
            if (!this.macroDefinitions.has(name)) {
                const body = m[2].trim();
                const calls = [];
                const callRegex = /\b([a-zA-Z_]\w*)\s*\(/g;
                let cm;
                while ((cm = callRegex.exec(body)) !== null) {
                    if (this.isValidFunc(cm[1])) calls.push(cm[1]);
                }
                this.macroDefinitions.set(name, { file, params: [], body, calls: [...new Set(calls)] });
            }
        }
    }

    // ==========================================================================
    // Parse parameter types from a parameter string
    // ==========================================================================
    parseParamTypes(paramsStr) {
        const params = [];
        if (!paramsStr || !paramsStr.trim() || paramsStr.trim() === 'void') return params;
        
        const parts = this.parseArgList(paramsStr);
        for (const part of parts) {
            const trimmed = part.trim();
            if (!trimmed) continue;
            
            // Function pointer param: type (*name)(args)
            const fptrMatch = trimmed.match(/^([\w\s\*]+)\s*\(\s*\*\s*(\w+)\s*\)\s*\([^)]*\)$/);
            if (fptrMatch) {
                params.push({ name: fptrMatch[2], type: trimmed, isFuncPtr: true });
                continue;
            }
            
            // Regular param: type name or type *name
            const regularMatch = trimmed.match(/^(.*?)\s*\*?\s*(\w+)\s*(?:\[\s*\d*\s*\])?$/);
            if (regularMatch) {
                const typePart = regularMatch[1].trim();
                const namePart = regularMatch[2];
                const isFuncPtr = this.isTypeFuncPtr(typePart);
                params.push({ name: namePart, type: typePart, isFuncPtr });
            }
        }
        return params;
    }

    // ==========================================================================
    // Check if a type name is a function pointer type
    // ==========================================================================
    isTypeFuncPtr(typeName) {
        if (!typeName) return false;
        typeName = typeName.trim();
        
        // Check our recorded types
        const typeInfo = this.typeDefinitions.get(typeName);
        if (typeInfo && typeInfo.isFuncPtr) return true;
        
        // Check syntax patterns
        if (/\(\s*\*\s*\)/.test(typeName)) return true;
        
        // Check naming conventions
        const fptrPatterns = [/_fn$/i, /_func$/i, /_cb$/i, /_callback$/i, /_handler$/i, /^fn_/i, /^cb_/i, /handler$/i, /callback$/i];
        for (const pat of fptrPatterns) {
            if (pat.test(typeName)) return true;
        }
        
        return false;
    }

    // ==========================================================================
    // PHASE 5: Parse function definitions
    // ==========================================================================
    parseFunctionDefinitions(content, file) {
        const clean = this.clean(content);
        const funcRegex = /\b([a-zA-Z_]\w*)\s*\(([^)]*)\)\s*\{/g;
        let m;
        
        while ((m = funcRegex.exec(clean)) !== null) {
            const funcName = m[1];
            const paramsStr = m[2];
            
            if (!this.isValidFunc(funcName)) continue;
            
            const bodyStart = m.index + m[0].length;
            const bodyEnd = this.findBrace(clean, bodyStart);
            if (bodyEnd === -1) continue;
            
            const body = clean.substring(bodyStart - 1, bodyEnd);
            
            // Store definition
            this.functionDefinitions.set(funcName, { file, paramsStr, body });
            
            // Parse parameter types
            if (!this.funcParamTypes.has(funcName)) {
                this.funcParamTypes.set(funcName, this.parseParamTypes(paramsStr));
            }
            
            // Parse local variable types
            this.parseLocalVarTypes(funcName, body);
            
            // Function definition also counts as declaration
            if (!this.functionDeclarations.has(funcName)) {
                this.functionDeclarations.set(funcName, new Set());
            }
            this.functionDeclarations.get(funcName).add(file);
            
            this.addLog('func-def', `${funcName}() defined in ${file}`);
        }
    }

    // ==========================================================================
    // Parse local variable types within a function
    // ==========================================================================
    parseLocalVarTypes(funcName, body) {
        const varTypes = new Map();
        
        // Type declarations: type varName = value; or type varName;
        const declRegex = /\b((?:const\s+)?(?:unsigned\s+|signed\s+)?(?:struct\s+)?[\w_]+(?:\s*\*)*)\s+(\w+)\s*(?:=\s*([^;]+))?;/g;
        let m;
        
        while ((m = declRegex.exec(body)) !== null) {
            const typeName = m[1].trim();
            const varName = m[2];
            const initValue = m[3] ? m[3].trim() : null;
            
            if (this.isKeyword(varName)) continue;
            if (varTypes.has(varName)) continue;
            
            const isFuncPtr = this.isTypeFuncPtr(typeName);
            
            // If it's a function pointer type and has init value, extract the assigned function
            let assignedFunc = null;
            if (isFuncPtr && initValue) {
                const funcMatch = initValue.match(/^&?([a-zA-Z_]\w*)$/);
                if (funcMatch && this.isValidFunc(funcMatch[1])) {
                    assignedFunc = funcMatch[1];
                }
            }
            
            varTypes.set(varName, { type: typeName, isFuncPtr, assignedFunc });
        }
        
        // Explicit function pointer declarations: type (*varName)(args) = func;
        const fptrDeclRegex = /\b([\w\s\*]+)\s*\(\s*\*\s*(\w+)\s*\)\s*\([^)]*\)\s*(?:=\s*&?(\w+))?\s*;/g;
        while ((m = fptrDeclRegex.exec(body)) !== null) {
            const varName = m[2];
            const assignedFunc = m[3] && this.isValidFunc(m[3]) ? m[3] : null;
            varTypes.set(varName, { type: 'explicit-func-ptr', isFuncPtr: true, assignedFunc });
        }
        
        this.funcLocalVarTypes.set(funcName, varTypes);
    }

    // ==========================================================================
    // CHECK LINKAGE: Can a source file access a function?
    // ==========================================================================
    canAccess(sourceFile, targetName) {
        // 1. Is target defined in the same file?
        const definition = this.functionDefinitions.get(targetName);
        if (definition && definition.file === sourceFile) {
            return { valid: true, reason: 'same-file-definition', through: sourceFile };
        }
        
        // 2. Is target declared in the same file (forward declaration)?
        const declarations = this.functionDeclarations.get(targetName);
        if (declarations && declarations.has(sourceFile)) {
            return { valid: true, reason: 'same-file-declaration', through: sourceFile };
        }
        
        // 3. Is target declared in a header that sourceFile includes?
        const includes = this.fileIncludes.get(sourceFile) || new Set();
        if (declarations) {
            for (const declFile of declarations) {
                // Check if sourceFile includes this declaration file
                const declBasename = this.getBasename(declFile);
                if (includes.has(declBasename) || includes.has(declFile)) {
                    return { valid: true, reason: 'included-header', through: declFile };
                }
            }
        }
        
        // 4. Is target a macro defined in same file or included header?
        const macroDef = this.macroDefinitions.get(targetName);
        if (macroDef) {
            if (macroDef.file === sourceFile) {
                return { valid: true, reason: 'same-file-macro', through: sourceFile };
            }
            const macroBasename = this.getBasename(macroDef.file);
            if (includes.has(macroBasename) || includes.has(macroDef.file)) {
                return { valid: true, reason: 'included-macro', through: macroDef.file };
            }
        }
        
        // 5. NOT ACCESSIBLE
        return { valid: false, reason: 'no-linkage' };
    }

    // ==========================================================================
    // CHECK TYPE LINKAGE: Can a source file access a type definition?
    // ==========================================================================
    canAccessType(sourceFile, typeName) {
        const typeInfo = this.typeDefinitions.get(typeName);
        if (!typeInfo) return { valid: false, reason: 'type-not-found' };
        
        // Same file?
        if (typeInfo.file === sourceFile) {
            return { valid: true, reason: 'same-file-type', through: sourceFile };
        }
        
        // Included header?
        const includes = this.fileIncludes.get(sourceFile) || new Set();
        const typeBasename = this.getBasename(typeInfo.file);
        if (includes.has(typeBasename) || includes.has(typeInfo.file)) {
            return { valid: true, reason: 'included-type', through: typeInfo.file };
        }
        
        return { valid: false, reason: 'type-not-accessible' };
    }

    // ==========================================================================
    // PHASE 6: Build verified call graph (only linked calls)
    // ==========================================================================
    buildVerifiedCallGraph() {
        this.addLog('info', '=== Building verified call graph ===');
        
        for (const [funcName, funcDef] of this.functionDefinitions) {
            const sourceFile = funcDef.file;
            const body = funcDef.body;
            const verifiedCalls = new Map();
            
            // Find all function calls in body
            const callRegex = /\b([a-zA-Z_]\w*)\s*\(/g;
            let m;
            const rawCalls = new Set();
            
            while ((m = callRegex.exec(body)) !== null) {
                if (this.isValidFunc(m[1])) {
                    rawCalls.add(m[1]);
                }
            }
            
            for (const callee of rawCalls) {
                // Check if this is a macro
                if (this.macroDefinitions.has(callee)) {
                    const macroAccess = this.canAccess(sourceFile, callee);
                    if (macroAccess.valid) {
                        const macro = this.macroDefinitions.get(callee);
                        verifiedCalls.set(callee, { type: 'macro-invoke', through: macroAccess.through });
                        
                        // Also add calls inside the macro (need to verify from macro's file)
                        for (const macroCall of macro.calls) {
                            const macroCallAccess = this.canAccess(macro.file, macroCall);
                            if (macroCallAccess.valid) {
                                verifiedCalls.set(macroCall, { type: 'via-macro', via: callee, through: macroCallAccess.through });
                            } else {
                                this.addLog('unlinked', `${funcName}() via macro ${callee}() -> ${macroCall}() - macro's call not linked`);
                            }
                        }
                    } else {
                        this.addLog('unlinked', `${funcName}() -> macro ${callee}() - ${macroAccess.reason}`);
                    }
                    continue;
                }
                
                // Regular function call - check linkage
                const access = this.canAccess(sourceFile, callee);
                if (access.valid) {
                    verifiedCalls.set(callee, { type: 'direct', through: access.through });
                    this.addLog('linked', `${funcName}() -> ${callee}() via ${access.through}`);
                } else {
                    this.addLog('unlinked', `${funcName}() -> ${callee}() - ${access.reason}`);
                }
            }
            
            // Now check for function pointers passed as arguments
            // ONLY if the variable's TYPE is verified as a function pointer
            this.findTypedFuncPtrCalls(funcName, body, sourceFile, verifiedCalls);
            
            this.verifiedCalls.set(funcName, verifiedCalls);
        }
    }

    // ==========================================================================
    // Find function pointers passed as arguments (type-verified)
    // ==========================================================================
    findTypedFuncPtrCalls(funcName, body, sourceFile, verifiedCalls) {
        const paramTypes = this.funcParamTypes.get(funcName) || [];
        const localVarTypes = this.funcLocalVarTypes.get(funcName) || new Map();
        
        // Build type map: varName -> type info
        const typeMap = new Map();
        for (const p of paramTypes) {
            typeMap.set(p.name, { type: p.type, isFuncPtr: p.isFuncPtr, source: 'param' });
        }
        for (const [varName, info] of localVarTypes) {
            if (!typeMap.has(varName)) {
                typeMap.set(varName, { ...info, source: 'local' });
            }
        }
        
        // Find all function calls and check their arguments
        const callRegex = /\b([a-zA-Z_]\w*)\s*\(([^)]*(?:\([^)]*\)[^)]*)*)\)/g;
        let m;
        
        while ((m = callRegex.exec(body)) !== null) {
            const callee = m[1];
            if (!this.isValidFunc(callee)) continue;
            
            const argsStr = m[2];
            const args = this.parseArgList(argsStr);
            
            // Get callee's parameter types (if known)
            const calleeParamTypes = this.funcParamTypes.get(callee) || [];
            
            for (let i = 0; i < args.length; i++) {
                const arg = args[i].trim();
                
                // Extract variable name from argument (could be &var, (cast)var, etc.)
                const varMatch = arg.match(/^(?:&|\([^)]+\)\s*)?([a-zA-Z_]\w*)$/);
                if (!varMatch) continue;
                
                const varName = varMatch[1];
                
                // METHOD 1: Check if the variable's DECLARED TYPE is a function pointer
                const varTypeInfo = typeMap.get(varName);
                if (varTypeInfo && varTypeInfo.isFuncPtr) {
                    // The variable's type is a function pointer!
                    // Check if we can verify the type is accessible
                    const typeAccess = this.canAccessType(sourceFile, varTypeInfo.type);
                    
                    if (varTypeInfo.assignedFunc) {
                        // We know what function is assigned to this variable
                        const funcAccess = this.canAccess(sourceFile, varTypeInfo.assignedFunc);
                        if (funcAccess.valid && (typeAccess.valid || varTypeInfo.type === 'explicit-func-ptr')) {
                            if (!verifiedCalls.has(varTypeInfo.assignedFunc)) {
                                verifiedCalls.set(varTypeInfo.assignedFunc, {
                                    type: 'func-ptr-arg',
                                    via: callee,
                                    varName: varName,
                                    varType: varTypeInfo.type,
                                    through: funcAccess.through
                                });
                                this.addLog('fptr-arg', `${funcName}(): ${varName} (${varTypeInfo.type}) = ${varTypeInfo.assignedFunc} -> ${callee}()`);
                            }
                        }
                    }
                    continue;
                }
                
                // METHOD 2: Check if the CALLEE's parameter expects a function pointer
                const calleeParam = calleeParamTypes[i];
                if (calleeParam && calleeParam.isFuncPtr) {
                    // The callee expects a function pointer at this position
                    // Check if varName is a known function
                    const funcAccess = this.canAccess(sourceFile, varName);
                    if (funcAccess.valid) {
                        // Also verify we can access the callee's param type definition
                        const paramTypeAccess = this.canAccessType(sourceFile, calleeParam.type);
                        if (paramTypeAccess.valid || calleeParam.type.includes('(*)')) {
                            if (!verifiedCalls.has(varName)) {
                                verifiedCalls.set(varName, {
                                    type: 'func-ptr-arg',
                                    via: callee,
                                    argPos: i,
                                    expectedType: calleeParam.type,
                                    through: funcAccess.through
                                });
                                this.addLog('fptr-arg', `${funcName}(): ${varName} passed to ${callee}() param #${i+1} (expects ${calleeParam.type})`);
                            }
                        }
                    }
                }
            }
        }
    }

    // ==========================================================================
    // Parse a single file (Phase 1-5)
    // ==========================================================================
    parseFile(filename, content) {
        this.addLog('info', `Parsing ${filename} (${content.length} bytes)`);
        this.files.set(filename, content);
        this.fileTypes.set(filename, this.isHeader(filename) ? 'h' : 'c');
        
        // Phase 1: Includes
        this.parseIncludes(content, filename);
        
        // Phase 2: Types
        this.parseTypes(content, filename);
        
        // Phase 3: Declarations (especially important for headers)
        this.parseDeclarations(content, filename);
        
        // Phase 4: Macros
        this.parseMacros(content, filename);
        
        // Phase 5: Function definitions
        this.parseFunctionDefinitions(content, filename);
    }

    // ==========================================================================
    // Find paths using verified call graph
    // ==========================================================================
    findPaths(entry, target, maxDepth = 30, maxPaths = 100, maxTime = 5000) {
        const paths = [];
        const startTime = Date.now();
        
        if (!this.verifiedCalls.has(entry)) {
            this.addLog('error', `Entry function '${entry}' not found or has no verified calls`);
            return paths;
        }

        const dfs = (current, path, visited) => {
            if (Date.now() - startTime > maxTime) return;
            if (paths.length >= maxPaths) return;
            if (path.length > maxDepth) return;
            if (visited.has(current)) return;

            if (current === target) {
                paths.push([...path]);
                return;
            }

            visited.add(current);
            
            const calls = this.verifiedCalls.get(current);
            if (calls) {
                for (const [callee, info] of calls) {
                    path.push({ name: callee, ...info });
                    dfs(callee, path, visited);
                    path.pop();
                }
            }

            visited.delete(current);
        };

        dfs(entry, [{ name: entry, type: 'entry' }], new Set());
        
        this.addLog('info', `Found ${paths.length} paths in ${Date.now() - startTime}ms`);
        return paths;
    }
}

// =============================================================================
// ARGUMENT TRACKER (simplified for strict mode)
// =============================================================================
class ArgumentTracker {
    constructor(parser) {
        this.parser = parser;
        this.log = [];
    }

    addLog(msg) { this.log.push(msg); }

    parseArgs(argsStr) {
        if (!argsStr || !argsStr.trim()) return [];
        const args = [];
        let current = '', depth = 0;
        for (let i = 0; i < argsStr.length; i++) {
            const c = argsStr[i];
            if (c === '(' || c === '[' || c === '{') { depth++; current += c; }
            else if (c === ')' || c === ']' || c === '}') { depth--; current += c; }
            else if (c === ',' && depth === 0) { if (current.trim()) args.push(current.trim()); current = ''; }
            else { current += c; }
        }
        if (current.trim()) args.push(current.trim());
        return args;
    }

    traceArgumentFlow(targetFunc, argPosition, paths) {
        this.addLog(`=== Tracing arg #${argPosition} of ${targetFunc}() ===`);
        const results = [];
        
        for (let pathIdx = 0; pathIdx < paths.length; pathIdx++) {
            const path = paths[pathIdx];
            const trace = this.traceArgInPath(targetFunc, argPosition, path);
            results.push({ pathIndex: pathIdx + 1, path, trace });
        }
        
        return results;
    }

    traceArgInPath(targetFunc, argPosition, path) {
        const trace = { targetFunc, argPosition, steps: [], origin: null, debug: [] };
        let currentArgPos = argPosition;
        
        for (let i = path.length - 1; i >= 0; i--) {
            const funcName = path[i].name;
            trace.debug.push(`[${funcName}]`);
            
            if (funcName === targetFunc && i === path.length - 1) {
                const params = this.parser.funcParamTypes.get(funcName) || [];
                if (params[currentArgPos - 1]) {
                    trace.debug.push(`  Target param: ${params[currentArgPos - 1].name}`);
                }
                continue;
            }
            
            const nextFunc = path[i + 1]?.name;
            if (!nextFunc) continue;
            
            const funcDef = this.parser.functionDefinitions.get(funcName);
            if (!funcDef) { trace.debug.push(`  No definition`); continue; }
            
            // Find calls to nextFunc in body
            const callRegex = new RegExp(`\\b${nextFunc}\\s*\\(([^)]*(?:\\([^)]*\\)[^)]*)*)\\)`, 'g');
            const match = callRegex.exec(funcDef.body);
            
            if (!match) { trace.debug.push(`  Call to ${nextFunc} not found`); continue; }
            
            const args = this.parseArgs(match[1]);
            trace.debug.push(`  Args: [${args.join(' | ')}]`);
            
            const argValue = args[currentArgPos - 1];
            if (!argValue) { trace.debug.push(`  Arg #${currentArgPos} not found`); continue; }
            
            trace.debug.push(`  Arg #${currentArgPos} = "${argValue}"`);
            
            const funcFile = funcDef.file;
            trace.steps.push({ func: funcName, file: funcFile, callsFunc: nextFunc, argPos: currentArgPos, argValue });
            
            // Check if argValue is a parameter
            const params = this.parser.funcParamTypes.get(funcName) || [];
            const paramIdx = params.findIndex(p => p.name === argValue);
            if (paramIdx !== -1) {
                trace.debug.push(`  ‚Üí "${argValue}" is param #${paramIdx + 1}`);
                currentArgPos = paramIdx + 1;
                continue;
            }
            
            // Check local variables
            const localVars = this.parser.funcLocalVarTypes.get(funcName);
            if (localVars && localVars.has(argValue)) {
                const info = localVars.get(argValue);
                trace.debug.push(`  ‚Üí "${argValue}" is local var (${info.type})`);
                trace.origin = { func: funcName, file: funcFile, type: info.type, value: info.assignedFunc || argValue, variable: argValue };
                break;
            }
            
            // Direct value
            trace.origin = { func: funcName, file: funcFile, type: 'direct', value: argValue, variable: argValue };
            break;
        }
        
        return trace;
    }
}

// =============================================================================
// UI
// =============================================================================
class UI {
    constructor() {
        this.files = new Map();
        this.parser = null;
        this.argTracker = null;
        this.results = null;
        this.argResults = null;
        this.currentTab = 'tree';
        this.init();
    }

    init() {
        this.uploadZone = document.getElementById('uploadZone');
        this.fileInput = document.getElementById('fileInput');
        this.fileList = document.getElementById('fileList');
        this.analyzeBtn = document.getElementById('analyzeBtn');
        this.clearBtn = document.getElementById('clearBtn');
        this.traceArgBtn = document.getElementById('traceArgBtn');
        this.output = document.getElementById('output');
        this.statsCard = document.getElementById('statsCard');

        this.uploadZone.addEventListener('click', () => this.fileInput.click());
        this.fileInput.addEventListener('change', e => this.handleFiles(e.target.files));
        this.uploadZone.addEventListener('dragover', e => { e.preventDefault(); this.uploadZone.style.borderColor = 'var(--cyan)'; });
        this.uploadZone.addEventListener('dragleave', () => { this.uploadZone.style.borderColor = ''; });
        this.uploadZone.addEventListener('drop', e => { e.preventDefault(); this.uploadZone.style.borderColor = ''; this.handleFiles(e.dataTransfer.files); });
        this.analyzeBtn.addEventListener('click', () => this.analyze());
        this.clearBtn.addEventListener('click', () => this.clear());
        this.traceArgBtn.addEventListener('click', () => this.traceArgument());
        document.querySelectorAll('.tab').forEach(tab => { tab.addEventListener('click', () => this.switchTab(tab.dataset.tab)); });
    }

    handleFiles(fileList) {
        for (const file of fileList) {
            const ext = file.name.split('.').pop().toLowerCase();
            if (['c', 'h', 'cpp', 'hpp'].includes(ext)) {
                const reader = new FileReader();
                reader.onload = e => { this.files.set(file.name, e.target.result); this.updateFileList(); };
                reader.readAsText(file);
            }
        }
    }

    updateFileList() {
        this.fileList.innerHTML = '';
        let hasHeaders = false, hasSources = false;
        for (const name of this.files.keys()) {
            const ext = name.split('.').pop().toLowerCase();
            const type = ['h', 'hpp'].includes(ext) ? 'h' : 'c';
            if (type === 'h') hasHeaders = true;
            else hasSources = true;
            const item = document.createElement('div');
            item.className = 'file-item';
            item.innerHTML = `<span><span class="type ${type}">${type.toUpperCase()}</span>${name}</span><button class="remove" data-file="${name}">√ó</button>`;
            this.fileList.appendChild(item);
        }
        this.fileList.querySelectorAll('.remove').forEach(btn => {
            btn.addEventListener('click', () => { this.files.delete(btn.dataset.file); this.updateFileList(); });
        });
        this.analyzeBtn.disabled = this.files.size === 0;
        this.traceArgBtn.disabled = this.files.size === 0;
        this.uploadZone.classList.toggle('has-files', this.files.size > 0);
        
        // Show warning if no headers
        if (hasSources && !hasHeaders) {
            this.output.innerHTML = `<div class="warning" style="margin:20px;">‚ö†Ô∏è <strong>No header files uploaded!</strong><br><br>Without headers, external function calls cannot be verified. The tool will only show calls within the same file.<br><br>Please upload the corresponding .h files.</div>`;
        }
    }

    async analyze() {
        const entry = document.getElementById('entryFunc').value.trim();
        const target = document.getElementById('targetFunc').value.trim();
        const maxDepth = parseInt(document.getElementById('maxDepth').value) || 30;

        if (!entry || !target) { alert('Enter entry and target functions'); return; }

        this.output.innerHTML = `<div class="progress"><div class="progress-bar"><div class="progress-fill" style="width: 5%"></div></div><p class="progress-text">Initializing...</p></div>`;
        await new Promise(r => setTimeout(r, 50));
        const startTime = Date.now();

        try {
            this.parser = new StrictParser();
            const progressBar = this.output.querySelector('.progress-fill');
            const progressText = this.output.querySelector('.progress-text');

            // Parse headers first
            progressText.textContent = 'Parsing header files...';
            for (const [name, content] of this.files) {
                if (['h', 'hpp'].includes(name.split('.').pop().toLowerCase())) {
                    this.parser.parseFile(name, content);
                    await new Promise(r => setTimeout(r, 10));
                }
            }
            progressBar.style.width = '30%';

            // Parse source files
            progressText.textContent = 'Parsing source files...';
            for (const [name, content] of this.files) {
                if (['c', 'cpp'].includes(name.split('.').pop().toLowerCase())) {
                    this.parser.parseFile(name, content);
                    await new Promise(r => setTimeout(r, 10));
                }
            }
            progressBar.style.width = '60%';

            // Build verified call graph
            progressText.textContent = 'Building verified call graph (checking linkage)...';
            await new Promise(r => setTimeout(r, 50));
            this.parser.buildVerifiedCallGraph();
            progressBar.style.width = '80%';

            // Find paths
            progressText.textContent = 'Finding paths...';
            await new Promise(r => setTimeout(r, 50));
            const paths = this.parser.findPaths(entry, target, maxDepth, 100, 5000);
            
            this.argTracker = new ArgumentTracker(this.parser);
            
            const elapsed = Date.now() - startTime;
            this.results = { entry, target, paths, elapsed };

            document.getElementById('statFiles').textContent = this.files.size;
            document.getElementById('statFuncs').textContent = this.parser.functionDefinitions.size;
            document.getElementById('statMacros').textContent = this.parser.macroDefinitions.size;
            document.getElementById('statPaths').textContent = paths.length;
            document.getElementById('statDepth').textContent = paths.length > 0 ? Math.max(...paths.map(p => p.length)) : 0;
            document.getElementById('statTime').textContent = elapsed;
            this.statsCard.style.display = 'block';

            this.switchTab(this.currentTab);
        } catch (error) {
            console.error(error);
            this.output.innerHTML = `<div class="error"><strong>Error:</strong> ${error.message}</div>`;
        }
    }

    async traceArgument() {
        const targetFunc = document.getElementById('argTargetFunc').value.trim();
        const argPosition = parseInt(document.getElementById('argPosition').value);
        const argName = document.getElementById('argName').value.trim();
        if (!this.parser || !this.results) { alert('Run "Analyze" first'); return; }
        
        let pathsToTarget = this.results.paths;
        if (targetFunc !== this.results.target) {
            pathsToTarget = this.parser.findPaths(this.results.entry, targetFunc, 30, 100, 5000);
        }
        
        if (pathsToTarget.length === 0) {
            this.output.innerHTML = `<div class="error">No paths found to ${targetFunc}</div>`;
            return;
        }
        
        this.argResults = { targetFunc, argPosition, argName, traces: this.argTracker.traceArgumentFlow(targetFunc, argPosition, pathsToTarget) };
        this.switchTab('argflow');
    }

    switchTab(tab) {
        this.currentTab = tab;
        document.querySelectorAll('.tab').forEach(t => t.classList.toggle('active', t.dataset.tab === tab));
        if (!this.results && !this.parser) return;
        switch (tab) {
            case 'tree': this.renderTree(); break;
            case 'paths': this.renderPaths(); break;
            case 'argflow': this.renderArgFlow(); break;
            case 'funcs': this.renderFunctions(); break;
            case 'linkage': this.renderLinkage(); break;
            case 'types': this.renderTypes(); break;
            case 'log': this.renderLog(); break;
        }
    }

    renderTree() {
        if (!this.results || this.results.paths.length === 0) {
            let msg = `No paths found from ${this.results?.entry || 'entry'} to ${this.results?.target || 'target'}`;
            
            // Check if it's a linkage issue
            const hasHeaders = [...this.files.keys()].some(f => ['h','hpp'].includes(f.split('.').pop().toLowerCase()));
            if (!hasHeaders) {
                msg += `\n\n<span style="color:var(--orange)">‚ö†Ô∏è No header files uploaded. External function calls cannot be verified without headers!</span>`;
            }
            
            this.output.innerHTML = `<div style="color:var(--text-muted);text-align:center;padding:50px;">${msg}</div>`;
            return;
        }

        const root = { name: this.results.entry, type: 'entry', children: new Map() };
        for (const path of this.results.paths) {
            let node = root;
            for (let i = 1; i < path.length; i++) {
                const step = path[i];
                if (!node.children.has(step.name)) {
                    node.children.set(step.name, { 
                        name: step.name, 
                        type: step.name === this.results.target ? 'target' : step.type, 
                        via: step.via,
                        through: step.through,
                        children: new Map() 
                    });
                }
                node = node.children.get(step.name);
            }
        }

        let html = '';
        const render = (node, prefix = '', isLast = true) => {
            const conn = isLast ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ ';
            let cls = 'func-inter';
            if (node.type === 'entry') cls = 'func-entry';
            else if (node.type === 'target') cls = 'func-target';
            else if (node.type === 'macro-invoke' || node.type === 'via-macro') cls = 'func-macro';
            else if (node.type === 'func-ptr-arg') cls = 'func-arg';

            const marker = node.type === 'target' ? ' ‚òÖ' : '';
            let via = '';
            if (node.via) via = ` <span class="file-ref">[via ${node.via}]</span>`;
            
            let through = '';
            if (node.through) through = ` <span style="color:var(--green);font-size:0.7rem;">‚úì${node.through}</span>`;
            
            const file = this.parser.functionDefinitions.get(node.name)?.file;
            const fileRef = file ? ` <span class="file-ref">[${file}]</span>` : '';
            
            let typeIndicator = '';
            if (node.type === 'func-ptr-arg') typeIndicator = '<span style="color:var(--teal)">[fptr]</span> ';
            else if (node.type === 'via-macro') typeIndicator = '<span style="color:var(--pink)">[macro]</span> ';
            
            html += `${prefix}${conn}${typeIndicator}<span class="${cls}">${node.name}</span>${marker}${via}${through}${fileRef}\n`;
            
            const children = [...node.children.values()];
            const newPrefix = prefix + (isLast ? '    ' : '‚îÇ   ');
            children.forEach((child, i) => render(child, newPrefix, i === children.length - 1));
        };
        render(root);
        this.output.innerHTML = html;
    }

    renderPaths() {
        if (!this.results || this.results.paths.length === 0) {
            this.output.innerHTML = `<div style="color:var(--text-muted);text-align:center;padding:50px;">No paths found</div>`;
            return;
        }
        let html = '';
        this.results.paths.forEach((path, i) => {
            html += `<div class="path-item"><div class="path-header"><span class="path-num">Path ${i + 1}</span><span style="color:var(--text-muted);font-size:0.8rem;">Depth: ${path.length}</span></div><div class="path-chain">`;
            path.forEach((step, j) => {
                const isTarget = j === path.length - 1;
                let style = '';
                if (step.type === 'func-ptr-arg') style = 'style="border:1px solid var(--teal)"';
                else if (step.type === 'via-macro') style = 'style="border:1px solid var(--pink)"';
                html += `<span class="func ${isTarget ? 'target' : ''}" ${style}>${step.name}</span>`;
                if (j < path.length - 1) html += `<span class="arrow">‚Üí</span>`;
            });
            html += '</div></div>';
        });
        this.output.innerHTML = html;
    }

    renderArgFlow() {
        if (!this.argResults) {
            this.output.innerHTML = `<div style="color:var(--text-muted);text-align:center;padding:50px;">Click "Trace Argument" to analyze</div>`;
            return;
        }
        const { targetFunc, argPosition, argName, traces } = this.argResults;
        let html = `<div class="arg-box"><div class="arg-box-title"><span>üéØ ${targetFunc}() ‚Üí Arg #${argPosition}${argName ? ` (${argName})` : ''}</span><span class="arg-box-badge">${traces.length} path(s)</span></div></div>`;
        
        const byOrigin = new Map();
        for (const t of traces) {
            if (t.trace.origin) {
                const key = `${t.trace.origin.func}::${t.trace.origin.value}`;
                if (!byOrigin.has(key)) byOrigin.set(key, { origin: t.trace.origin, traces: [] });
                byOrigin.get(key).traces.push(t);
            }
        }
        
        if (byOrigin.size === 0) {
            html += `<div class="warning">Could not trace argument origin</div>`;
        } else {
            html += `<div class="success">Found ${byOrigin.size} unique origin(s)</div>`;
            let idx = 0;
            for (const [key, data] of byOrigin) {
                idx++;
                const origin = data.origin;
                html += `<div class="arg-box"><div class="arg-box-title"><span>Origin #${idx}: ${origin.func}()</span></div>`;
                html += `<div class="arg-step origin"><div class="arg-step-func">üìç ${origin.func}()</div><div class="arg-step-file">${origin.file}</div><div class="arg-step-detail">Value: <code>${this.esc(origin.value)}</code></div></div></div>`;
            }
        }
        
        this.output.innerHTML = html;
    }

    renderFunctions() {
        if (!this.parser) return;
        let html = `<strong>Defined Functions: ${this.parser.functionDefinitions.size}</strong>\n\n`;
        
        for (const [name, def] of this.parser.functionDefinitions) {
            const calls = this.parser.verifiedCalls.get(name) || new Map();
            const callList = [];
            for (const [callee, info] of calls) {
                let style = '';
                if (info.type === 'func-ptr-arg') style = 'color:var(--teal)';
                else if (info.type === 'via-macro') style = 'color:var(--pink)';
                callList.push(`<span style="${style}">${callee}</span>`);
            }
            html += `<span class="func-inter">${name}</span> <span class="file-ref">[${def.file}]</span>\n`;
            if (callList.length > 0) {
                html += `  ‚îî‚îÄ‚îÄ calls: ${callList.join(', ')}\n`;
            }
        }
        
        if (this.parser.macroDefinitions.size > 0) {
            html += `\n<strong>Macros: ${this.parser.macroDefinitions.size}</strong>\n\n`;
            for (const [name, macro] of this.parser.macroDefinitions) {
                html += `<span class="func-macro">${name}</span> <span class="file-ref">[${macro.file}]</span>`;
                if (macro.calls.length > 0) html += ` ‚Üí ${macro.calls.join(', ')}`;
                html += '\n';
            }
        }
        
        this.output.innerHTML = html;
    }

    renderLinkage() {
        if (!this.parser) return;
        let html = `<strong style="color:var(--cyan)">Include Map:</strong>\n\n`;
        
        for (const [file, includes] of this.parser.fileIncludes) {
            const isHeader = this.parser.fileTypes.get(file) === 'h';
            const color = isHeader ? 'var(--purple)' : 'var(--green)';
            html += `<span style="color:${color}">${file}</span>\n`;
            if (includes.size > 0) {
                for (const inc of includes) {
                    const exists = [...this.files.keys()].some(f => f === inc || f.endsWith('/' + inc));
                    const marker = exists ? '‚úì' : '‚úó';
                    const incColor = exists ? 'var(--green)' : 'var(--red)';
                    html += `  ‚îî‚îÄ‚îÄ <span style="color:${incColor}">${marker} ${inc}</span>\n`;
                }
            } else {
                html += `  ‚îî‚îÄ‚îÄ <span style="color:var(--text-muted)">(no includes)</span>\n`;
            }
            html += '\n';
        }
        
        html += `\n<strong style="color:var(--purple)">Function Declarations:</strong>\n\n`;
        for (const [funcName, files] of this.parser.functionDeclarations) {
            const defFile = this.parser.functionDefinitions.get(funcName)?.file;
            html += `<span class="func-inter">${funcName}</span>\n`;
            for (const file of files) {
                const isDef = file === defFile;
                const marker = isDef ? '‚óè defined' : '‚óã declared';
                html += `  ‚îî‚îÄ‚îÄ ${marker} in <span class="file-ref">${file}</span>\n`;
            }
        }
        
        // Show unlinked calls from log
        const unlinked = this.parser.log.filter(l => l.type === 'unlinked');
        if (unlinked.length > 0) {
            html += `\n<strong style="color:var(--red)">Unlinked Calls (excluded from graph):</strong>\n\n`;
            for (const entry of unlinked) {
                html += `<span style="color:var(--red)">‚úó</span> ${entry.msg}\n`;
            }
        }
        
        this.output.innerHTML = html;
    }

    renderTypes() {
        if (!this.parser) return;
        let html = `<strong style="color:var(--teal)">Function Pointer Types:</strong>\n\n`;
        
        for (const [name, info] of this.parser.typeDefinitions) {
            if (info.isFuncPtr) {
                html += `<span style="color:var(--teal)">${name}</span>`;
                if (info.returnType) html += ` = ${info.returnType}(*)(${info.params})`;
                html += ` <span class="file-ref">[${info.file}]</span>\n`;
            }
        }
        
        html += `\n<strong style="color:var(--purple)">Function Parameters:</strong>\n\n`;
        for (const [funcName, params] of this.parser.funcParamTypes) {
            if (params.length === 0) continue;
            const list = params.map(p => {
                if (p.isFuncPtr) return `<span style="color:var(--teal)">${p.name} [FPTR]</span>`;
                return p.name;
            }).join(', ');
            html += `<span class="func-inter">${funcName}</span>(${list})\n`;
        }
        
        this.output.innerHTML = html;
    }

    renderLog() {
        if (!this.parser) return;
        let html = '<strong>Parser Log:</strong>\n\n';
        for (const entry of this.parser.log) {
            let color = 'var(--text)';
            if (entry.type === 'error') color = 'var(--red)';
            else if (entry.type === 'unlinked') color = 'var(--red)';
            else if (entry.type === 'linked') color = 'var(--green)';
            else if (entry.type === 'fptr-arg') color = 'var(--teal)';
            else if (entry.type === 'macro') color = 'var(--pink)';
            else if (entry.type === 'type') color = 'var(--yellow)';
            else if (entry.type === 'include') color = 'var(--purple)';
            else if (entry.type === 'info') color = 'var(--cyan)';
            else if (entry.type === 'func-def') color = 'var(--cyan)';
            html += `<span style="color:${color}">[${entry.type.toUpperCase()}]</span> ${entry.msg}\n`;
        }
        
        if (this.argTracker && this.argTracker.log.length > 0) {
            html += '\n<strong>Argument Tracker:</strong>\n\n';
            for (const msg of this.argTracker.log) {
                html += `<span style="color:var(--yellow)">[ARG]</span> ${msg}\n`;
            }
        }
        
        this.output.innerHTML = html;
    }

    esc(text) { if (!text) return ''; const div = document.createElement('div'); div.textContent = String(text); return div.innerHTML; }

    clear() {
        this.files.clear(); this.parser = null; this.argTracker = null; this.results = null; this.argResults = null;
        this.updateFileList(); this.statsCard.style.display = 'none';
        this.output.innerHTML = `<div style="color:var(--text-muted);text-align:center;padding:50px;">Upload C files <strong>AND their header files</strong> to trace call paths.<br><br><span style="color:var(--orange);">‚ö†Ô∏è Without headers, external function calls cannot be verified!</span></div>`;
    }
}

document.addEventListener('DOMContentLoaded', () => new UI());
</script>
</body>
</html>
