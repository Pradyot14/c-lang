<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C Call Tracer - Fixed Version</title>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --border: #30363d;
            --text: #c9d1d9;
            --text-muted: #8b949e;
            --cyan: #58a6ff;
            --green: #3fb950;
            --purple: #a371f7;
            --pink: #f778ba;
            --orange: #d29922;
            --red: #f85149;
            --yellow: #e3b341;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: var(--bg-primary); color: var(--text); min-height: 100vh; }
        .container { max-width: 1600px; margin: 0 auto; padding: 20px; }
        header { text-align: center; padding: 20px 0; border-bottom: 1px solid var(--border); margin-bottom: 20px; }
        h1 { color: var(--cyan); font-size: 1.8rem; margin-bottom: 5px; }
        .subtitle { color: var(--text-muted); font-size: 0.9rem; }
        
        .main-grid { display: grid; grid-template-columns: 350px 1fr; gap: 20px; }
        @media (max-width: 1000px) { .main-grid { grid-template-columns: 1fr; } }
        
        .card { background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 8px; padding: 16px; margin-bottom: 16px; }
        .card-title { color: var(--cyan); font-size: 0.95rem; font-weight: 600; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid var(--border); }
        
        .upload-zone { border: 2px dashed var(--border); border-radius: 8px; padding: 25px; text-align: center; cursor: pointer; transition: all 0.2s; }
        .upload-zone:hover { border-color: var(--cyan); background: rgba(88, 166, 255, 0.05); }
        .upload-zone.has-files { border-color: var(--green); border-style: solid; }
        .upload-zone p { color: var(--text-muted); margin-bottom: 8px; }
        .upload-zone .badge { display: inline-block; background: var(--bg-tertiary); color: var(--cyan); padding: 3px 8px; border-radius: 4px; font-size: 0.75rem; margin: 2px; font-family: monospace; }
        
        .file-list { max-height: 150px; overflow-y: auto; margin-top: 10px; }
        .file-item { display: flex; justify-content: space-between; align-items: center; background: var(--bg-tertiary); padding: 6px 10px; border-radius: 4px; margin-bottom: 4px; font-size: 0.8rem; font-family: monospace; }
        .file-item .type { padding: 2px 6px; border-radius: 3px; font-size: 0.7rem; margin-right: 8px; }
        .file-item .type.c { background: rgba(63, 185, 80, 0.2); color: var(--green); }
        .file-item .type.h { background: rgba(163, 113, 247, 0.2); color: var(--purple); }
        .file-item .remove { background: none; border: none; color: var(--text-muted); cursor: pointer; font-size: 1rem; }
        .file-item .remove:hover { color: var(--red); }
        
        .form-group { margin-bottom: 12px; }
        .form-group label { display: block; color: var(--text-muted); font-size: 0.8rem; margin-bottom: 4px; }
        .form-group input { width: 100%; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 4px; padding: 8px 10px; color: var(--text); font-family: monospace; }
        .form-group input:focus { outline: none; border-color: var(--cyan); }
        
        .form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        
        .btn { width: 100%; padding: 12px; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; transition: all 0.2s; }
        .btn-primary { background: var(--cyan); color: #000; }
        .btn-primary:hover { opacity: 0.9; }
        .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-secondary { background: var(--bg-tertiary); color: var(--text); border: 1px solid var(--border); margin-top: 8px; }
        
        .stats { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-top: 12px; }
        .stat { background: var(--bg-tertiary); padding: 10px; border-radius: 4px; text-align: center; }
        .stat-val { font-size: 1.4rem; font-weight: 700; color: var(--cyan); }
        .stat-label { font-size: 0.7rem; color: var(--text-muted); }
        
        .tabs { display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap; }
        .tab { padding: 8px 16px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 4px; color: var(--text-muted); cursor: pointer; font-size: 0.85rem; }
        .tab:hover { border-color: var(--cyan); color: var(--text); }
        .tab.active { background: rgba(88, 166, 255, 0.1); border-color: var(--cyan); color: var(--cyan); }
        
        .output { background: var(--bg-tertiary); border-radius: 6px; padding: 16px; min-height: 400px; max-height: 600px; overflow: auto; font-family: 'Monaco', 'Menlo', monospace; font-size: 0.8rem; line-height: 1.5; white-space: pre-wrap; }
        
        .progress { padding: 20px; text-align: center; }
        .progress-bar { height: 4px; background: var(--border); border-radius: 2px; margin: 15px 0; overflow: hidden; }
        .progress-fill { height: 100%; background: var(--cyan); transition: width 0.3s; }
        .progress-text { color: var(--text-muted); font-size: 0.85rem; }
        
        .error { background: rgba(248, 81, 73, 0.1); border: 1px solid var(--red); border-radius: 6px; padding: 16px; color: var(--red); }
        
        .legend { display: flex; flex-wrap: wrap; gap: 12px; margin-bottom: 12px; padding: 10px; background: var(--bg-tertiary); border-radius: 4px; }
        .legend-item { display: flex; align-items: center; gap: 6px; font-size: 0.75rem; color: var(--text-muted); }
        .legend-color { width: 12px; height: 12px; border-radius: 2px; }
        
        .func-entry { color: var(--cyan); }
        .func-target { color: var(--green); font-weight: bold; }
        .func-inter { color: var(--purple); }
        .func-macro { color: var(--pink); }
        .func-ptr { color: #58a6ff; }
        .func-ext { color: var(--orange); }
        .file-ref { color: var(--text-muted); }
        
        .path-item { background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 6px; padding: 12px; margin-bottom: 8px; }
        .path-header { display: flex; justify-content: space-between; margin-bottom: 8px; }
        .path-num { background: var(--cyan); color: #000; padding: 2px 8px; border-radius: 10px; font-size: 0.75rem; font-weight: 600; }
        .path-chain { font-family: monospace; font-size: 0.8rem; display: flex; flex-wrap: wrap; gap: 4px; align-items: center; }
        .path-chain .func { background: var(--bg-tertiary); padding: 2px 6px; border-radius: 3px; }
        .path-chain .func.target { background: rgba(63, 185, 80, 0.2); color: var(--green); }
        .path-chain .arrow { color: var(--cyan); }
        
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg-tertiary); }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üîç C Call Tracer</h1>
            <p class="subtitle">Trace function call paths with macro & pointer support</p>
        </header>
        
        <div class="main-grid">
            <div class="sidebar">
                <div class="card">
                    <div class="card-title">üìÅ Upload Files</div>
                    <div class="upload-zone" id="uploadZone">
                        <p>Drop .c and .h files here</p>
                        <div>
                            <span class="badge">.c</span>
                            <span class="badge">.h</span>
                        </div>
                        <input type="file" id="fileInput" multiple accept=".c,.h,.cpp,.hpp" hidden>
                    </div>
                    <div class="file-list" id="fileList"></div>
                </div>
                
                <div class="card">
                    <div class="card-title">‚öôÔ∏è Configuration</div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Entry Function</label>
                            <input type="text" id="entryFunc" value="main">
                        </div>
                        <div class="form-group">
                            <label>Target Function</label>
                            <input type="text" id="targetFunc" value="mpf_mfs_open">
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Max Search Depth</label>
                        <input type="number" id="maxDepth" value="30" min="5" max="100">
                    </div>
                    <button class="btn btn-primary" id="analyzeBtn" disabled>üî¨ Analyze</button>
                    <button class="btn btn-secondary" id="clearBtn">Clear All</button>
                </div>
                
                <div class="card" id="statsCard" style="display:none;">
                    <div class="card-title">üìä Results</div>
                    <div class="stats">
                        <div class="stat"><div class="stat-val" id="statFiles">0</div><div class="stat-label">Files</div></div>
                        <div class="stat"><div class="stat-val" id="statFuncs">0</div><div class="stat-label">Functions</div></div>
                        <div class="stat"><div class="stat-val" id="statMacros">0</div><div class="stat-label">Macros</div></div>
                        <div class="stat"><div class="stat-val" id="statPaths">0</div><div class="stat-label">Paths</div></div>
                        <div class="stat"><div class="stat-val" id="statDepth">0</div><div class="stat-label">Max Depth</div></div>
                        <div class="stat"><div class="stat-val" id="statTime">0</div><div class="stat-label">ms</div></div>
                    </div>
                </div>
            </div>
            
            <div class="results">
                <div class="card" style="height: 100%;">
                    <div class="tabs">
                        <button class="tab active" data-tab="tree">Text Tree</button>
                        <button class="tab" data-tab="paths">All Paths</button>
                        <button class="tab" data-tab="funcs">Functions</button>
                        <button class="tab" data-tab="log">Log</button>
                    </div>
                    
                    <div class="legend">
                        <div class="legend-item"><div class="legend-color" style="background:var(--cyan)"></div>Entry</div>
                        <div class="legend-item"><div class="legend-color" style="background:var(--green)"></div>Target</div>
                        <div class="legend-item"><div class="legend-color" style="background:var(--purple)"></div>Intermediate</div>
                        <div class="legend-item"><div class="legend-color" style="background:var(--pink)"></div>Macro</div>
                        <div class="legend-item"><div class="legend-color" style="background:var(--orange)"></div>External</div>
                    </div>
                    
                    <div class="output" id="output">
                        <div style="color:var(--text-muted);text-align:center;padding:50px;">
                            Upload C files and click Analyze to trace call paths
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

<script>
// Simple, robust C parser
class CParser {
    constructor() {
        this.files = new Map();
        this.functions = new Map();
        this.macros = new Map();
        this.funcPointers = new Map();
        this.callGraph = new Map();
        this.log = [];
    }

    addLog(type, msg) {
        this.log.push({ type, msg });
        console.log(`[${type}] ${msg}`);
    }

    // Clean code - remove comments and strings
    clean(code) {
        // Remove multi-line comments
        code = code.replace(/\/\*[\s\S]*?\*\//g, ' ');
        // Remove single-line comments
        code = code.replace(/\/\/.*$/gm, '');
        // Replace strings with empty
        code = code.replace(/"(?:[^"\\]|\\.)*"/g, '""');
        code = code.replace(/'(?:[^'\\]|\\.)*'/g, "''");
        return code;
    }

    // Parse macros
    parseMacros(code, file) {
        // Function-like: #define NAME(args) body
        const funcMacro = /#\s*define\s+(\w+)\s*\(([^)]*)\)\s*(.+?)(?=\n|$)/g;
        let m;
        while ((m = funcMacro.exec(code)) !== null) {
            const name = m[1];
            const body = m[3].replace(/\\\n/g, ' ').trim();
            const calls = this.findCalls(body);
            this.macros.set(name, { name, body, calls, file });
            if (calls.length > 0) {
                this.addLog('macro', `${name} -> ${calls.join(', ')}`);
            }
        }

        // Object-like: #define NAME value (skip function-like)
        const objMacro = /#\s*define\s+(\w+)\s+([^(\n][^\n]*)/g;
        while ((m = objMacro.exec(code)) !== null) {
            const name = m[1];
            if (!this.macros.has(name)) {
                const body = m[2].trim();
                const calls = this.findCalls(body);
                this.macros.set(name, { name, body, calls, file });
            }
        }
    }

    // Parse function pointer assignments
    parseFuncPointers(code, file) {
        // .callback = func_name or callback = func_name
        const patterns = [
            /\.(\w+)\s*=\s*&?(\w+)\s*[,;}\)]/g,
            /(\w+)\s*=\s*&?(\w+)\s*;/g
        ];
        
        for (const pat of patterns) {
            let m;
            while ((m = pat.exec(code)) !== null) {
                const varName = m[1];
                const funcName = m[2];
                if (this.isValidFunc(funcName)) {
                    if (!this.funcPointers.has(varName)) {
                        this.funcPointers.set(varName, new Set());
                    }
                    this.funcPointers.get(varName).add(funcName);
                }
            }
        }
    }

    // Check if name is a valid function name
    isValidFunc(name) {
        const keywords = ['if','else','while','for','do','switch','case','break','continue','return','goto','sizeof','NULL','true','false','void','int','char','float','double','long','short','unsigned','signed','const','static','extern','struct','enum','union','typedef'];
        if (keywords.includes(name)) return false;
        if (/^\d/.test(name)) return false;
        if (name.length < 2) return false;
        return true;
    }

    // Find function calls in code
    findCalls(code) {
        const calls = [];
        const regex = /\b([a-zA-Z_]\w*)\s*\(/g;
        let m;
        while ((m = regex.exec(code)) !== null) {
            if (this.isValidFunc(m[1])) {
                calls.push(m[1]);
            }
        }
        return [...new Set(calls)];
    }

    // Find matching brace with limit
    findBrace(code, start, limit = 50000) {
        let depth = 1;
        let i = start;
        const end = Math.min(code.length, start + limit);
        while (i < end && depth > 0) {
            if (code[i] === '{') depth++;
            else if (code[i] === '}') depth--;
            i++;
        }
        return depth === 0 ? i : -1;
    }

    // Parse functions
    parseFunctions(code, file) {
        const clean = this.clean(code);
        
        // Simpler regex for function definitions
        const funcRegex = /\b([a-zA-Z_]\w*)\s*\(([^)]*)\)\s*\{/g;
        let m;
        
        while ((m = funcRegex.exec(clean)) !== null) {
            const name = m[1];
            
            if (!this.isValidFunc(name)) continue;
            
            const bodyStart = m.index + m[0].length;
            const bodyEnd = this.findBrace(clean, bodyStart);
            
            if (bodyEnd === -1) continue;
            
            const body = clean.substring(bodyStart - 1, bodyEnd);
            const directCalls = this.findCalls(body);
            
            // Expand macro calls
            const allCalls = new Map();
            for (const call of directCalls) {
                if (this.macros.has(call)) {
                    const macro = this.macros.get(call);
                    allCalls.set(call, { type: 'macro-invoke' });
                    for (const mc of macro.calls) {
                        allCalls.set(mc, { type: 'macro', via: call });
                    }
                } else if (this.funcPointers.has(call)) {
                    for (const target of this.funcPointers.get(call)) {
                        allCalls.set(target, { type: 'pointer', via: call });
                    }
                } else {
                    allCalls.set(call, { type: 'direct' });
                }
            }

            // Check for callback patterns
            const cbRegex = /(\w+)->(\w+)\s*\(/g;
            let cb;
            while ((cb = cbRegex.exec(body)) !== null) {
                const member = cb[2];
                if (this.funcPointers.has(member)) {
                    for (const target of this.funcPointers.get(member)) {
                        allCalls.set(target, { type: 'callback', via: member });
                    }
                }
            }

            this.functions.set(name, {
                name,
                file,
                calls: allCalls
            });
        }
    }

    // Build call graph
    buildGraph() {
        for (const [name, func] of this.functions) {
            this.callGraph.set(name, func.calls);
        }
        this.addLog('info', `Built call graph with ${this.functions.size} functions`);
    }

    // Parse a file
    parseFile(filename, content) {
        this.addLog('info', `Parsing ${filename} (${content.length} bytes)`);
        this.files.set(filename, content);
        
        try {
            this.parseMacros(content, filename);
            this.parseFuncPointers(content, filename);
            this.parseFunctions(content, filename);
        } catch (e) {
            this.addLog('error', `Error parsing ${filename}: ${e.message}`);
        }
    }

    // Find all paths from entry to target (with limits)
    findPaths(entry, target, maxDepth = 30, maxPaths = 100, maxTime = 5000) {
        const paths = [];
        const startTime = Date.now();
        
        if (!this.callGraph.has(entry)) {
            this.addLog('error', `Entry function '${entry}' not found`);
            return paths;
        }

        const dfs = (current, path, visited) => {
            // Time limit
            if (Date.now() - startTime > maxTime) return;
            // Path limit
            if (paths.length >= maxPaths) return;
            // Depth limit
            if (path.length > maxDepth) return;
            // Cycle detection
            if (visited.has(current)) return;

            if (current === target) {
                paths.push([...path]);
                return;
            }

            visited.add(current);
            
            const calls = this.callGraph.get(current);
            if (calls) {
                for (const [callee, info] of calls) {
                    path.push({ name: callee, ...info });
                    dfs(callee, path, visited);
                    path.pop();
                }
            }

            visited.delete(current);
        };

        dfs(entry, [{ name: entry, type: 'entry' }], new Set());
        
        this.addLog('info', `Found ${paths.length} paths in ${Date.now() - startTime}ms`);
        return paths;
    }
}

// UI Controller
class UI {
    constructor() {
        this.files = new Map();
        this.parser = null;
        this.results = null;
        this.currentTab = 'tree';
        
        this.init();
    }

    init() {
        // Elements
        this.uploadZone = document.getElementById('uploadZone');
        this.fileInput = document.getElementById('fileInput');
        this.fileList = document.getElementById('fileList');
        this.analyzeBtn = document.getElementById('analyzeBtn');
        this.clearBtn = document.getElementById('clearBtn');
        this.output = document.getElementById('output');
        this.statsCard = document.getElementById('statsCard');

        // Events
        this.uploadZone.addEventListener('click', () => this.fileInput.click());
        this.fileInput.addEventListener('change', e => this.handleFiles(e.target.files));
        
        this.uploadZone.addEventListener('dragover', e => {
            e.preventDefault();
            this.uploadZone.style.borderColor = 'var(--cyan)';
        });
        this.uploadZone.addEventListener('dragleave', () => {
            this.uploadZone.style.borderColor = '';
        });
        this.uploadZone.addEventListener('drop', e => {
            e.preventDefault();
            this.uploadZone.style.borderColor = '';
            this.handleFiles(e.dataTransfer.files);
        });

        this.analyzeBtn.addEventListener('click', () => this.analyze());
        this.clearBtn.addEventListener('click', () => this.clear());

        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => this.switchTab(tab.dataset.tab));
        });
    }

    handleFiles(fileList) {
        for (const file of fileList) {
            const ext = file.name.split('.').pop().toLowerCase();
            if (['c', 'h', 'cpp', 'hpp'].includes(ext)) {
                const reader = new FileReader();
                reader.onload = e => {
                    this.files.set(file.name, e.target.result);
                    this.updateFileList();
                };
                reader.onerror = () => {
                    console.error('Error reading file:', file.name);
                };
                reader.readAsText(file);
            }
        }
    }

    updateFileList() {
        this.fileList.innerHTML = '';
        
        for (const name of this.files.keys()) {
            const ext = name.split('.').pop().toLowerCase();
            const type = ['h', 'hpp'].includes(ext) ? 'h' : 'c';
            
            const item = document.createElement('div');
            item.className = 'file-item';
            item.innerHTML = `
                <span><span class="type ${type}">${type.toUpperCase()}</span>${name}</span>
                <button class="remove" data-file="${name}">√ó</button>
            `;
            this.fileList.appendChild(item);
        }

        this.fileList.querySelectorAll('.remove').forEach(btn => {
            btn.addEventListener('click', () => {
                this.files.delete(btn.dataset.file);
                this.updateFileList();
            });
        });

        this.analyzeBtn.disabled = this.files.size === 0;
        this.uploadZone.classList.toggle('has-files', this.files.size > 0);
    }

    async analyze() {
        const entry = document.getElementById('entryFunc').value.trim();
        const target = document.getElementById('targetFunc').value.trim();
        const maxDepth = parseInt(document.getElementById('maxDepth').value) || 30;

        if (!entry || !target) {
            alert('Please enter entry and target function names');
            return;
        }

        // Show progress
        this.output.innerHTML = `
            <div class="progress">
                <div class="progress-bar"><div class="progress-fill" style="width: 10%"></div></div>
                <p class="progress-text">Parsing files...</p>
            </div>
        `;

        // Use setTimeout to allow UI to update
        await new Promise(r => setTimeout(r, 50));

        const startTime = Date.now();

        try {
            this.parser = new CParser();

            // Parse headers first
            let progress = 10;
            const progressBar = this.output.querySelector('.progress-fill');
            const progressText = this.output.querySelector('.progress-text');

            for (const [name, content] of this.files) {
                const ext = name.split('.').pop().toLowerCase();
                if (['h', 'hpp'].includes(ext)) {
                    this.parser.parseFile(name, content);
                    progress += 30 / this.files.size;
                    progressBar.style.width = progress + '%';
                    progressText.textContent = `Parsing ${name}...`;
                    await new Promise(r => setTimeout(r, 10));
                }
            }

            // Parse source files
            for (const [name, content] of this.files) {
                const ext = name.split('.').pop().toLowerCase();
                if (['c', 'cpp'].includes(ext)) {
                    this.parser.parseFile(name, content);
                    progress += 30 / this.files.size;
                    progressBar.style.width = progress + '%';
                    progressText.textContent = `Parsing ${name}...`;
                    await new Promise(r => setTimeout(r, 10));
                }
            }

            progressBar.style.width = '70%';
            progressText.textContent = 'Building call graph...';
            await new Promise(r => setTimeout(r, 50));

            this.parser.buildGraph();

            progressBar.style.width = '80%';
            progressText.textContent = 'Finding paths...';
            await new Promise(r => setTimeout(r, 50));

            // Find paths
            const paths = this.parser.findPaths(entry, target, maxDepth, 100, 5000);

            const elapsed = Date.now() - startTime;

            // Store results
            this.results = {
                entry,
                target,
                paths,
                elapsed
            };

            // Update stats
            document.getElementById('statFiles').textContent = this.files.size;
            document.getElementById('statFuncs').textContent = this.parser.functions.size;
            document.getElementById('statMacros').textContent = this.parser.macros.size;
            document.getElementById('statPaths').textContent = paths.length;
            document.getElementById('statDepth').textContent = paths.length > 0 ? Math.max(...paths.map(p => p.length)) : 0;
            document.getElementById('statTime').textContent = elapsed;
            this.statsCard.style.display = 'block';

            // Render
            this.switchTab(this.currentTab);

        } catch (error) {
            console.error(error);
            this.output.innerHTML = `
                <div class="error">
                    <strong>Error:</strong> ${error.message}
                </div>
            `;
        }
    }

    switchTab(tab) {
        this.currentTab = tab;
        
        document.querySelectorAll('.tab').forEach(t => {
            t.classList.toggle('active', t.dataset.tab === tab);
        });

        if (!this.results && !this.parser) {
            return;
        }

        switch (tab) {
            case 'tree':
                this.renderTree();
                break;
            case 'paths':
                this.renderPaths();
                break;
            case 'funcs':
                this.renderFunctions();
                break;
            case 'log':
                this.renderLog();
                break;
        }
    }

    renderTree() {
        if (!this.results || this.results.paths.length === 0) {
            this.output.innerHTML = `<div style="color:var(--text-muted);text-align:center;padding:50px;">No paths found from ${this.results?.entry || 'entry'} to ${this.results?.target || 'target'}</div>`;
            return;
        }

        // Build tree from paths
        const root = { name: this.results.entry, type: 'entry', children: new Map() };
        
        for (const path of this.results.paths) {
            let node = root;
            for (let i = 1; i < path.length; i++) {
                const step = path[i];
                if (!node.children.has(step.name)) {
                    node.children.set(step.name, {
                        name: step.name,
                        type: step.name === this.results.target ? 'target' : step.type,
                        via: step.via,
                        children: new Map()
                    });
                }
                node = node.children.get(step.name);
            }
        }

        // Render tree
        let html = '';
        const render = (node, prefix = '', isLast = true) => {
            const conn = isLast ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ ';
            let cls = 'func-inter';
            if (node.type === 'entry') cls = 'func-entry';
            else if (node.type === 'target') cls = 'func-target';
            else if (node.type === 'macro' || node.type === 'macro-invoke') cls = 'func-macro';
            else if (node.type === 'pointer' || node.type === 'callback') cls = 'func-ptr';
            else if (!this.parser.functions.has(node.name)) cls = 'func-ext';

            const marker = node.type === 'target' ? ' ‚òÖ' : '';
            const via = node.via ? ` <span class="file-ref">[via ${node.via}]</span>` : '';
            const file = this.parser.functions.get(node.name)?.file;
            const fileRef = file ? ` <span class="file-ref">[${file}]</span>` : '';

            html += `${prefix}${conn}<span class="${cls}">${node.name}</span>${marker}${via}${fileRef}\n`;

            const children = [...node.children.values()];
            const newPrefix = prefix + (isLast ? '    ' : '‚îÇ   ');
            children.forEach((child, i) => render(child, newPrefix, i === children.length - 1));
        };

        render(root);
        this.output.innerHTML = html;
    }

    renderPaths() {
        if (!this.results || this.results.paths.length === 0) {
            this.output.innerHTML = `<div style="color:var(--text-muted);text-align:center;padding:50px;">No paths found</div>`;
            return;
        }

        let html = '';
        this.results.paths.forEach((path, i) => {
            html += `<div class="path-item">
                <div class="path-header">
                    <span class="path-num">Path ${i + 1}</span>
                    <span style="color:var(--text-muted);font-size:0.8rem;">Depth: ${path.length}</span>
                </div>
                <div class="path-chain">`;
            
            path.forEach((step, j) => {
                const isTarget = j === path.length - 1;
                html += `<span class="func ${isTarget ? 'target' : ''}">${step.name}</span>`;
                if (j < path.length - 1) html += '<span class="arrow">‚Üí</span>';
            });
            
            html += '</div></div>';
        });

        this.output.innerHTML = html;
    }

    renderFunctions() {
        if (!this.parser) return;

        let html = `<strong>Functions found: ${this.parser.functions.size}</strong>\n\n`;
        
        for (const [name, func] of this.parser.functions) {
            const callCount = func.calls.size;
            html += `<span class="func-inter">${name}</span> <span class="file-ref">[${func.file}]</span> ‚Üí ${callCount} calls\n`;
        }

        if (this.parser.macros.size > 0) {
            html += `\n<strong>Macros with calls: ${this.parser.macros.size}</strong>\n\n`;
            for (const [name, macro] of this.parser.macros) {
                if (macro.calls.length > 0) {
                    html += `<span class="func-macro">${name}</span> ‚Üí ${macro.calls.join(', ')}\n`;
                }
            }
        }

        this.output.innerHTML = html;
    }

    renderLog() {
        if (!this.parser) return;

        let html = '';
        for (const entry of this.parser.log) {
            const color = entry.type === 'error' ? 'var(--red)' : 
                         entry.type === 'macro' ? 'var(--pink)' :
                         entry.type === 'info' ? 'var(--cyan)' : 'var(--text)';
            html += `<span style="color:${color}">[${entry.type.toUpperCase()}]</span> ${entry.msg}\n`;
        }

        this.output.innerHTML = html || '<span style="color:var(--text-muted)">No log entries</span>';
    }

    clear() {
        this.files.clear();
        this.parser = null;
        this.results = null;
        this.updateFileList();
        this.statsCard.style.display = 'none';
        this.output.innerHTML = `<div style="color:var(--text-muted);text-align:center;padding:50px;">Upload C files and click Analyze to trace call paths</div>`;
    }
}

// Initialize
document.addEventListener('DOMContentLoaded', () => new UI());
</script>
</body>
</html>
