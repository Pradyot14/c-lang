Executive Summary
This document outlines the data flow architecture for the C Code Analyzer system. The analyzer is designed to parse and analyze C source code files by resolving dependencies, maintaining a function registry, and utilizing an LLM-based agentic system with specialized tools for intelligent code comprehension.
The system follows a four-phase approach: Dependency Resolution, Function Registry initialization, Agentic Tool execution, and Agent Rule enforcement to ensure accurate and comprehensive code analysis.

1. Dependency Resolution
The dependency resolution phase establishes the foundation for code analysis by identifying and resolving all file dependencies within the project.
1.1 Makefile Analysis
The process begins by parsing the project's Makefile to identify all linked source files. The system specifically extracts file references from the SRCS field, which contains the list of all C source files (.c) that are part of the build configuration.
1.2 Header Extraction
For each identified .c file, the system extracts all referenced header file names through #include directive parsing. Once header names are identified, the system attempts to resolve their complete file paths within the project structure.
1.3 Recursive Header Resolution
The system employs a recursive approach to handle nested dependencies. Each resolved header file is scanned for additional #include directives that reference new header files not yet in the dependency graph. This process continues until all transitive dependencies are resolved.
1.4 Output: Header-to-Path Dictionary
The final output of this phase is a comprehensive header-to-path dictionary that maps each header filename to its absolute or relative path within the project. This dictionary serves as the primary reference for subsequent file access operations.
2. Function Registry
The function registry serves as the knowledge base for special and framework-specific functions used throughout the codebase.
2.1 Data Sources
The registry is constructed from two primary sources:
•	Excel spreadsheet: Contains structured function definitions and metadata
•	Moove Header PDF: Provides additional function documentation and specifications
2.2 JSON Structure
The extracted information is compiled into a JSON file containing detailed function metadata. For each special function (e.g., pmf_addevent), the registry stores:
•	Function prototype (complete signature)
•	Argument information (types, names, descriptions)
•	Return type specifications
•	Callback function references (if applicable)
•	Additional behavioral metadata
2.3 Runtime Storage
For efficient runtime access, the JSON data is serialized as pickle files and loaded into memory as a map structure: {function_name: function_info_dictionary}. This enables O(1) lookup time for function metadata during code analysis.
3. Agentic Tools
The LLM agent is equipped with four specialized tools that enable intelligent code navigation and analysis.
3.1 read_file_content
Description	Reads and returns the content of specified files with optional function-level filtering.
Parameters	• path (string): The file path to read
• function_name (string, optional): For .c files, specifies which function to extract
Returns	For .c files with a function name specified, returns only the relevant function code. For other files, returns the complete file content.
Notes	Enables targeted code reading without loading entire files into context, improving efficiency for large codebases.
3.2 list_project_files
Description	Provides the LLM with a filtered list of accessible file paths within the project scope.
Parameters	• filter_keywords (string): Keywords to filter the file list
Returns	A list of file paths matching the filter criteria. Only includes files from the C project folder and headers folder.
Notes	Restricts LLM access to relevant project files only, preventing access to system files or unrelated directories.
3.3 lookup_function_reference
Description	Queries the function registry to retrieve detailed information about known functions.
Parameters	• function_name (string): The name of the function to look up
Returns	Returns the complete function prototype including return type, parameters, callback information, and usage notes. Directs the LLM to search files manually if the function is not found in the registry.
Notes	Provides instant access to pre-documented function metadata, reducing the need for manual code exploration.

3.4 find_definition
Description	Locates definitions for macros, functions, and other symbols that cannot be resolved through other tools.
Parameters	• symbol_name (string): The name of the macro, function, or symbol to find
Returns	Returns the definition location and content for the requested symbol.
Notes	Acts as a fallback mechanism for resolving symbols not covered by the function registry.

4. Rules for the Agent
The agent follows a structured set of rules to ensure systematic and comprehensive code analysis.
4.1 Entry Point
Analysis must always begin from the main() function. The agent initiates by calling read_file_content with the function name parameter set to main().
4.2 Function Resolution Workflow
When the agent encounters an unknown function during analysis, it follows this resolution hierarchy:
Step	Action	Description
1	lookup_function_reference	First, check the function registry for pre-documented metadata
2	find_definition	If not found in registry, search for the symbol definition in project files
3	read_file_content	Once located, read the relevant source code for detailed analysis

4.3 Tool Selection Priority
The agent must adhere to the following tool selection priorities:
•	Registry lookup (lookup_function_reference) is always preferred for known functions
•	Definition search (find_definition) is the fallback for unregistered symbols
•	Direct file reading should only occur after symbol resolution
Notes / Future Extensions:
•	Additional tools can be introduced as the project evolves.
•	Tool expansion should be problem-driven, not speculative.
Data Flow Diagram
The following diagram illustrates the complete data flow through the system:
Makefile (SRCS)
↓
.c Files → Extract Headers → Resolve Paths
↓
Recursive Header Resolution
↓
Header-to-Path Dictionary
↓
LLM Agent + Tools
↓
Code Analysis Output
