<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C Call Tracer - With Argument Flow Tracking</title>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --border: #30363d;
            --text: #c9d1d9;
            --text-muted: #8b949e;
            --cyan: #58a6ff;
            --green: #3fb950;
            --purple: #a371f7;
            --pink: #f778ba;
            --orange: #d29922;
            --red: #f85149;
            --yellow: #e3b341;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: var(--bg-primary); color: var(--text); min-height: 100vh; }
        .container { max-width: 1700px; margin: 0 auto; padding: 20px; }
        header { text-align: center; padding: 15px 0; border-bottom: 1px solid var(--border); margin-bottom: 15px; }
        h1 { color: var(--cyan); font-size: 1.7rem; margin-bottom: 5px; }
        .subtitle { color: var(--text-muted); font-size: 0.85rem; }
        
        .main-grid { display: grid; grid-template-columns: 380px 1fr; gap: 20px; }
        @media (max-width: 1000px) { .main-grid { grid-template-columns: 1fr; } }
        
        .card { background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 8px; padding: 16px; margin-bottom: 14px; }
        .card-title { color: var(--cyan); font-size: 0.9rem; font-weight: 600; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid var(--border); }
        
        .upload-zone { border: 2px dashed var(--border); border-radius: 8px; padding: 20px; text-align: center; cursor: pointer; transition: all 0.2s; }
        .upload-zone:hover { border-color: var(--cyan); background: rgba(88, 166, 255, 0.05); }
        .upload-zone.has-files { border-color: var(--green); border-style: solid; }
        .upload-zone p { color: var(--text-muted); margin-bottom: 8px; font-size: 0.85rem; }
        .upload-zone .badge { display: inline-block; background: var(--bg-tertiary); color: var(--cyan); padding: 3px 8px; border-radius: 4px; font-size: 0.7rem; margin: 2px; font-family: monospace; }
        
        .file-list { max-height: 130px; overflow-y: auto; margin-top: 10px; }
        .file-item { display: flex; justify-content: space-between; align-items: center; background: var(--bg-tertiary); padding: 5px 10px; border-radius: 4px; margin-bottom: 4px; font-size: 0.75rem; font-family: monospace; }
        .file-item .type { padding: 2px 6px; border-radius: 3px; font-size: 0.65rem; margin-right: 8px; }
        .file-item .type.c { background: rgba(63, 185, 80, 0.2); color: var(--green); }
        .file-item .type.h { background: rgba(163, 113, 247, 0.2); color: var(--purple); }
        .file-item .remove { background: none; border: none; color: var(--text-muted); cursor: pointer; font-size: 1rem; }
        .file-item .remove:hover { color: var(--red); }
        
        .form-group { margin-bottom: 10px; }
        .form-group label { display: block; color: var(--text-muted); font-size: 0.75rem; margin-bottom: 4px; }
        .form-group input, .form-group select { width: 100%; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 4px; padding: 8px 10px; color: var(--text); font-family: monospace; font-size: 0.85rem; }
        .form-group input:focus { outline: none; border-color: var(--cyan); }
        
        .form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .form-row-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; }
        
        .btn { width: 100%; padding: 11px; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; transition: all 0.2s; font-size: 0.85rem; }
        .btn-primary { background: linear-gradient(135deg, var(--cyan), var(--purple)); color: #fff; }
        .btn-primary:hover:not(:disabled) { opacity: 0.9; }
        .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-secondary { background: var(--bg-tertiary); color: var(--text); border: 1px solid var(--border); margin-top: 8px; }
        .btn-arg { background: linear-gradient(135deg, var(--yellow), var(--orange)); color: #000; margin-top: 8px; }
        
        .stats { display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; margin-top: 10px; }
        .stat { background: var(--bg-tertiary); padding: 8px; border-radius: 4px; text-align: center; }
        .stat-val { font-size: 1.2rem; font-weight: 700; color: var(--cyan); }
        .stat-label { font-size: 0.65rem; color: var(--text-muted); }
        
        .tabs { display: flex; gap: 6px; margin-bottom: 10px; flex-wrap: wrap; }
        .tab { padding: 7px 14px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 4px; color: var(--text-muted); cursor: pointer; font-size: 0.8rem; }
        .tab:hover { border-color: var(--cyan); color: var(--text); }
        .tab.active { background: rgba(88, 166, 255, 0.1); border-color: var(--cyan); color: var(--cyan); }
        .tab.arg-tab { border-color: var(--yellow); }
        .tab.arg-tab.active { background: rgba(227, 179, 65, 0.15); border-color: var(--yellow); color: var(--yellow); }
        
        .output { background: var(--bg-tertiary); border-radius: 6px; padding: 14px; min-height: 420px; max-height: 580px; overflow: auto; font-family: 'Monaco', 'Menlo', monospace; font-size: 0.78rem; line-height: 1.6; white-space: pre-wrap; }
        
        .progress { padding: 20px; text-align: center; }
        .progress-bar { height: 4px; background: var(--border); border-radius: 2px; margin: 15px 0; overflow: hidden; }
        .progress-fill { height: 100%; background: var(--cyan); transition: width 0.3s; }
        .progress-text { color: var(--text-muted); font-size: 0.85rem; }
        
        .error { background: rgba(248, 81, 73, 0.1); border: 1px solid var(--red); border-radius: 6px; padding: 16px; color: var(--red); }
        
        .legend { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 10px; padding: 8px 10px; background: var(--bg-tertiary); border-radius: 4px; font-size: 0.7rem; }
        .legend-item { display: flex; align-items: center; gap: 5px; color: var(--text-muted); }
        .legend-color { width: 10px; height: 10px; border-radius: 2px; }
        
        .func-entry { color: var(--cyan); }
        .func-target { color: var(--green); font-weight: bold; }
        .func-inter { color: var(--purple); }
        .func-macro { color: var(--pink); }
        .func-ptr { color: #58a6ff; }
        .func-ext { color: var(--orange); }
        .file-ref { color: var(--text-muted); }
        .arg-highlight { color: var(--yellow); font-weight: bold; }
        .arg-value { color: var(--green); background: rgba(63, 185, 80, 0.15); padding: 1px 4px; border-radius: 3px; }
        .arg-source { color: var(--orange); }
        .arg-param { color: var(--pink); }
        
        .path-item { background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 6px; padding: 10px; margin-bottom: 8px; }
        .path-header { display: flex; justify-content: space-between; margin-bottom: 6px; }
        .path-num { background: var(--cyan); color: #000; padding: 2px 8px; border-radius: 10px; font-size: 0.7rem; font-weight: 600; }
        .path-chain { font-family: monospace; font-size: 0.75rem; display: flex; flex-wrap: wrap; gap: 4px; align-items: center; }
        .path-chain .func { background: var(--bg-tertiary); padding: 2px 6px; border-radius: 3px; }
        .path-chain .func.target { background: rgba(63, 185, 80, 0.2); color: var(--green); }
        .path-chain .arrow { color: var(--cyan); }
        
        /* Argument flow styles */
        .arg-flow-item { background: var(--bg-secondary); border: 1px solid var(--yellow); border-radius: 8px; padding: 12px; margin-bottom: 10px; }
        .arg-flow-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid var(--border); }
        .arg-flow-title { color: var(--yellow); font-weight: 600; }
        .arg-flow-badge { background: rgba(227, 179, 65, 0.2); color: var(--yellow); padding: 3px 10px; border-radius: 12px; font-size: 0.7rem; }
        .arg-flow-chain { margin-top: 8px; }
        .arg-flow-step { display: flex; align-items: flex-start; margin-bottom: 8px; padding-left: 10px; border-left: 2px solid var(--yellow); }
        .arg-flow-step .step-func { color: var(--purple); font-weight: 600; min-width: 150px; }
        .arg-flow-step .step-detail { color: var(--text-muted); }
        .arg-flow-step .step-value { color: var(--green); background: rgba(63, 185, 80, 0.1); padding: 2px 6px; border-radius: 3px; margin-left: 5px; }
        .arg-flow-step.origin { border-left-color: var(--green); }
        .arg-flow-step.origin .step-func { color: var(--green); }
        
        .arg-info-box { background: var(--bg-tertiary); border-radius: 6px; padding: 10px; margin-bottom: 10px; }
        .arg-info-box .label { color: var(--text-muted); font-size: 0.7rem; margin-bottom: 4px; }
        .arg-info-box .value { color: var(--yellow); font-family: monospace; }
        
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: var(--bg-tertiary); }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üîç C Call Tracer + Argument Flow</h1>
            <p class="subtitle">Trace function paths & backtrack argument values through call chains</p>
        </header>
        
        <div class="main-grid">
            <div class="sidebar">
                <div class="card">
                    <div class="card-title">üìÅ Upload Files</div>
                    <div class="upload-zone" id="uploadZone">
                        <p>Drop .c and .h files here</p>
                        <div>
                            <span class="badge">.c</span>
                            <span class="badge">.h</span>
                        </div>
                        <input type="file" id="fileInput" multiple accept=".c,.h,.cpp,.hpp" hidden>
                    </div>
                    <div class="file-list" id="fileList"></div>
                </div>
                
                <div class="card">
                    <div class="card-title">‚öôÔ∏è Call Path Configuration</div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Entry Function</label>
                            <input type="text" id="entryFunc" value="main">
                        </div>
                        <div class="form-group">
                            <label>Target Function</label>
                            <input type="text" id="targetFunc" value="mpf_mfs_open">
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Max Search Depth</label>
                        <input type="number" id="maxDepth" value="30" min="5" max="100">
                    </div>
                    <button class="btn btn-primary" id="analyzeBtn" disabled>üî¨ Analyze Call Paths</button>
                    <button class="btn btn-secondary" id="clearBtn">Clear All</button>
                </div>
                
                <div class="card">
                    <div class="card-title">üîÑ Argument Flow Tracking</div>
                    <div class="form-row-3">
                        <div class="form-group">
                            <label>Target Function</label>
                            <input type="text" id="argTargetFunc" value="mpf_mfs_open">
                        </div>
                        <div class="form-group">
                            <label>Arg Position</label>
                            <select id="argPosition">
                                <option value="1">1st Arg</option>
                                <option value="2">2nd Arg</option>
                                <option value="3" selected>3rd Arg</option>
                                <option value="4">4th Arg</option>
                                <option value="5">5th Arg</option>
                                <option value="6">6th Arg</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Arg Name (opt)</label>
                            <input type="text" id="argName" placeholder="e.g. mode">
                        </div>
                    </div>
                    <button class="btn btn-arg" id="traceArgBtn" disabled>üîÑ Trace Argument Origin</button>
                </div>
                
                <div class="card" id="statsCard" style="display:none;">
                    <div class="card-title">üìä Results</div>
                    <div class="stats">
                        <div class="stat"><div class="stat-val" id="statFiles">0</div><div class="stat-label">Files</div></div>
                        <div class="stat"><div class="stat-val" id="statFuncs">0</div><div class="stat-label">Functions</div></div>
                        <div class="stat"><div class="stat-val" id="statMacros">0</div><div class="stat-label">Macros</div></div>
                        <div class="stat"><div class="stat-val" id="statPaths">0</div><div class="stat-label">Paths</div></div>
                        <div class="stat"><div class="stat-val" id="statDepth">0</div><div class="stat-label">Max Depth</div></div>
                        <div class="stat"><div class="stat-val" id="statTime">0</div><div class="stat-label">ms</div></div>
                    </div>
                </div>
            </div>
            
            <div class="results">
                <div class="card" style="height: 100%;">
                    <div class="tabs">
                        <button class="tab active" data-tab="tree">Text Tree</button>
                        <button class="tab" data-tab="paths">All Paths</button>
                        <button class="tab arg-tab" data-tab="argflow">üîÑ Arg Flow</button>
                        <button class="tab" data-tab="funcs">Functions</button>
                        <button class="tab" data-tab="log">Log</button>
                    </div>
                    
                    <div class="legend">
                        <div class="legend-item"><div class="legend-color" style="background:var(--cyan)"></div>Entry</div>
                        <div class="legend-item"><div class="legend-color" style="background:var(--green)"></div>Target</div>
                        <div class="legend-item"><div class="legend-color" style="background:var(--purple)"></div>Intermediate</div>
                        <div class="legend-item"><div class="legend-color" style="background:var(--pink)"></div>Macro</div>
                        <div class="legend-item"><div class="legend-color" style="background:var(--orange)"></div>External</div>
                        <div class="legend-item"><div class="legend-color" style="background:var(--yellow)"></div>Arg Origin</div>
                    </div>
                    
                    <div class="output" id="output">
                        <div style="color:var(--text-muted);text-align:center;padding:50px;">
                            Upload C files and click Analyze to trace call paths
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

<script>
// Enhanced C Parser with Argument Flow Tracking
class CParser {
    constructor() {
        this.files = new Map();
        this.functions = new Map();       // name -> {name, file, params, body, calls, callsWithArgs}
        this.macros = new Map();
        this.funcPointers = new Map();
        this.callGraph = new Map();
        this.variableAssignments = new Map();  // func -> {varName -> value/source}
        this.log = [];
    }

    addLog(type, msg) {
        this.log.push({ type, msg });
        console.log(`[${type}] ${msg}`);
    }

    // Clean code - remove comments and strings (but preserve for arg tracking)
    clean(code) {
        code = code.replace(/\/\*[\s\S]*?\*\//g, ' ');
        code = code.replace(/\/\/.*$/gm, '');
        return code;
    }

    cleanWithStrings(code) {
        code = code.replace(/\/\*[\s\S]*?\*\//g, ' ');
        code = code.replace(/\/\/.*$/gm, '');
        code = code.replace(/"(?:[^"\\]|\\.)*"/g, '"STRING"');
        code = code.replace(/'(?:[^'\\]|\\.)*'/g, "'C'");
        return code;
    }

    // Parse macros
    parseMacros(code, file) {
        const funcMacro = /#\s*define\s+(\w+)\s*\(([^)]*)\)\s*(.+?)(?=\n|$)/g;
        let m;
        while ((m = funcMacro.exec(code)) !== null) {
            const name = m[1];
            const params = m[2].split(',').map(p => p.trim()).filter(p => p);
            const body = m[3].replace(/\\\n/g, ' ').trim();
            const calls = this.findCalls(body);
            this.macros.set(name, { name, params, body, calls, file });
            if (calls.length > 0) {
                this.addLog('macro', `${name}(${params.join(', ')}) -> ${calls.join(', ')}`);
            }
        }

        const objMacro = /#\s*define\s+(\w+)\s+([^(\n][^\n]*)/g;
        while ((m = objMacro.exec(code)) !== null) {
            const name = m[1];
            if (!this.macros.has(name)) {
                const body = m[2].trim();
                const calls = this.findCalls(body);
                this.macros.set(name, { name, params: [], body, calls, file });
            }
        }
    }

    // Parse function pointer assignments
    parseFuncPointers(code, file) {
        const patterns = [
            /\.(\w+)\s*=\s*&?(\w+)\s*[,;}\)]/g,
            /(\w+)\s*=\s*&?(\w+)\s*;/g
        ];
        
        for (const pat of patterns) {
            let m;
            while ((m = pat.exec(code)) !== null) {
                const varName = m[1];
                const funcName = m[2];
                if (this.isValidFunc(funcName)) {
                    if (!this.funcPointers.has(varName)) {
                        this.funcPointers.set(varName, new Set());
                    }
                    this.funcPointers.get(varName).add(funcName);
                }
            }
        }
    }

    isValidFunc(name) {
        const keywords = ['if','else','while','for','do','switch','case','break','continue','return','goto','sizeof','NULL','true','false','void','int','char','float','double','long','short','unsigned','signed','const','static','extern','struct','enum','union','typedef'];
        if (keywords.includes(name)) return false;
        if (/^\d/.test(name)) return false;
        if (name.length < 2) return false;
        return true;
    }

    findCalls(code) {
        const calls = [];
        const regex = /\b([a-zA-Z_]\w*)\s*\(/g;
        let m;
        while ((m = regex.exec(code)) !== null) {
            if (this.isValidFunc(m[1])) {
                calls.push(m[1]);
            }
        }
        return [...new Set(calls)];
    }

    // Extract function call with arguments
    findCallsWithArgs(code, targetFunc = null) {
        const callsWithArgs = [];
        // Match function calls with their arguments
        const regex = /\b([a-zA-Z_]\w*)\s*\(([^;]*?)\)/g;
        let m;
        
        while ((m = regex.exec(code)) !== null) {
            const funcName = m[1];
            if (!this.isValidFunc(funcName)) continue;
            if (targetFunc && funcName !== targetFunc) continue;
            
            // Parse arguments - handle nested parentheses
            const argsStr = m[2];
            const args = this.parseArguments(argsStr);
            
            callsWithArgs.push({
                func: funcName,
                args: args,
                raw: m[0],
                position: m.index
            });
        }
        
        return callsWithArgs;
    }

    // Parse arguments handling nested parentheses and commas
    parseArguments(argsStr) {
        const args = [];
        let current = '';
        let depth = 0;
        
        for (let i = 0; i < argsStr.length; i++) {
            const c = argsStr[i];
            if (c === '(' || c === '[' || c === '{') {
                depth++;
                current += c;
            } else if (c === ')' || c === ']' || c === '}') {
                depth--;
                current += c;
            } else if (c === ',' && depth === 0) {
                args.push(current.trim());
                current = '';
            } else {
                current += c;
            }
        }
        
        if (current.trim()) {
            args.push(current.trim());
        }
        
        return args;
    }

    // Parse variable assignments within a function body
    parseVariableAssignments(funcName, body) {
        const assignments = new Map();
        
        // Match variable declarations with initialization
        // int x = value; or Type x = value;
        const declPattern = /\b(\w+)\s+(\w+)\s*=\s*([^;]+);/g;
        let m;
        while ((m = declPattern.exec(body)) !== null) {
            const varName = m[2];
            const value = m[3].trim();
            assignments.set(varName, { value, type: 'declaration', raw: m[0] });
        }
        
        // Match simple assignments
        // x = value;
        const assignPattern = /\b(\w+)\s*=\s*([^;=]+);/g;
        while ((m = assignPattern.exec(body)) !== null) {
            const varName = m[1];
            const value = m[2].trim();
            if (!assignments.has(varName) && this.isValidFunc(varName) === false) {
                assignments.set(varName, { value, type: 'assignment', raw: m[0] });
            }
        }
        
        this.variableAssignments.set(funcName, assignments);
        return assignments;
    }

    findBrace(code, start, limit = 50000) {
        let depth = 1;
        let i = start;
        const end = Math.min(code.length, start + limit);
        while (i < end && depth > 0) {
            if (code[i] === '{') depth++;
            else if (code[i] === '}') depth--;
            i++;
        }
        return depth === 0 ? i : -1;
    }

    // Enhanced function parsing - captures parameters and call arguments
    parseFunctions(code, file) {
        const clean = this.clean(code);
        
        // Match function with parameters
        const funcRegex = /\b([a-zA-Z_]\w*)\s*\(([^)]*)\)\s*\{/g;
        let m;
        
        while ((m = funcRegex.exec(clean)) !== null) {
            const name = m[1];
            const paramsStr = m[2];
            
            if (!this.isValidFunc(name)) continue;
            
            // Parse parameters
            const params = this.parseParameters(paramsStr);
            
            const bodyStart = m.index + m[0].length;
            const bodyEnd = this.findBrace(clean, bodyStart);
            
            if (bodyEnd === -1) continue;
            
            const body = clean.substring(bodyStart - 1, bodyEnd);
            const directCalls = this.findCalls(body);
            
            // Get calls with their arguments
            const callsWithArgs = this.findCallsWithArgs(body);
            
            // Parse variable assignments in this function
            this.parseVariableAssignments(name, body);
            
            // Expand macro calls
            const allCalls = new Map();
            for (const call of directCalls) {
                if (this.macros.has(call)) {
                    const macro = this.macros.get(call);
                    allCalls.set(call, { type: 'macro-invoke' });
                    for (const mc of macro.calls) {
                        allCalls.set(mc, { type: 'macro', via: call });
                    }
                } else if (this.funcPointers.has(call)) {
                    for (const target of this.funcPointers.get(call)) {
                        allCalls.set(target, { type: 'pointer', via: call });
                    }
                } else {
                    allCalls.set(call, { type: 'direct' });
                }
            }

            const cbRegex = /(\w+)->(\w+)\s*\(/g;
            let cb;
            while ((cb = cbRegex.exec(body)) !== null) {
                const member = cb[2];
                if (this.funcPointers.has(member)) {
                    for (const target of this.funcPointers.get(member)) {
                        allCalls.set(target, { type: 'callback', via: member });
                    }
                }
            }

            this.functions.set(name, {
                name,
                file,
                params,
                body,
                calls: allCalls,
                callsWithArgs
            });
        }
    }

    // Parse function parameters
    parseParameters(paramsStr) {
        const params = [];
        const parts = paramsStr.split(',');
        
        for (const part of parts) {
            const trimmed = part.trim();
            if (!trimmed || trimmed === 'void') continue;
            
            // Extract parameter name (last word)
            const match = trimmed.match(/(\w+)\s*$/);
            if (match) {
                params.push({
                    name: match[1],
                    full: trimmed
                });
            }
        }
        
        return params;
    }

    buildGraph() {
        for (const [name, func] of this.functions) {
            this.callGraph.set(name, func.calls);
        }
        this.addLog('info', `Built call graph with ${this.functions.size} functions`);
    }

    parseFile(filename, content) {
        this.addLog('info', `Parsing ${filename} (${content.length} bytes)`);
        this.files.set(filename, content);
        
        try {
            this.parseMacros(content, filename);
            this.parseFuncPointers(content, filename);
            this.parseFunctions(content, filename);
        } catch (e) {
            this.addLog('error', `Error parsing ${filename}: ${e.message}`);
        }
    }

    findPaths(entry, target, maxDepth = 30, maxPaths = 100, maxTime = 5000) {
        const paths = [];
        const startTime = Date.now();
        
        if (!this.callGraph.has(entry)) {
            this.addLog('error', `Entry function '${entry}' not found`);
            return paths;
        }

        const dfs = (current, path, visited) => {
            if (Date.now() - startTime > maxTime) return;
            if (paths.length >= maxPaths) return;
            if (path.length > maxDepth) return;
            if (visited.has(current)) return;

            if (current === target) {
                paths.push([...path]);
                return;
            }

            visited.add(current);
            
            const calls = this.callGraph.get(current);
            if (calls) {
                for (const [callee, info] of calls) {
                    path.push({ name: callee, ...info });
                    dfs(callee, path, visited);
                    path.pop();
                }
            }

            visited.delete(current);
        };

        dfs(entry, [{ name: entry, type: 'entry' }], new Set());
        
        this.addLog('info', `Found ${paths.length} paths in ${Date.now() - startTime}ms`);
        return paths;
    }

    // =========================================
    // ARGUMENT FLOW TRACKING
    // =========================================
    
    // Trace where an argument value comes from
    traceArgumentFlow(targetFunc, argPosition, paths) {
        this.addLog('arg', `Tracing argument ${argPosition} of ${targetFunc}...`);
        
        const argFlows = [];
        
        for (let pathIdx = 0; pathIdx < paths.length; pathIdx++) {
            const path = paths[pathIdx];
            const flow = this.traceArgInPath(targetFunc, argPosition, path);
            
            if (flow && flow.origin) {
                argFlows.push({
                    pathIndex: pathIdx + 1,
                    path: path,
                    flow: flow
                });
            }
        }
        
        this.addLog('arg', `Found ${argFlows.length} argument flow traces`);
        return argFlows;
    }

    // Trace argument through a single path
    traceArgInPath(targetFunc, argPosition, path) {
        const flow = {
            target: targetFunc,
            argPosition: argPosition,
            steps: [],
            origin: null
        };
        
        // Find the function that calls targetFunc
        for (let i = path.length - 2; i >= 0; i--) {
            const callerName = path[i].name;
            const callerFunc = this.functions.get(callerName);
            
            if (!callerFunc) continue;
            
            // Find the call to targetFunc (or next function in path)
            const nextFunc = path[i + 1].name;
            const callInfo = callerFunc.callsWithArgs.find(c => c.func === nextFunc);
            
            if (!callInfo || !callInfo.args[argPosition - 1]) continue;
            
            const argValue = callInfo.args[argPosition - 1];
            
            // Add step
            flow.steps.unshift({
                func: callerName,
                file: callerFunc.file,
                passedAs: argValue,
                toFunc: nextFunc,
                argPos: argPosition
            });
            
            // Try to trace this value further
            const traced = this.traceValueOrigin(callerName, argValue, callerFunc);
            
            if (traced.isParam) {
                // It's a parameter - continue tracing up the call chain
                argPosition = traced.paramIndex + 1;
            } else if (traced.origin) {
                // Found the origin!
                flow.origin = {
                    func: callerName,
                    file: callerFunc.file,
                    type: traced.type,
                    value: traced.origin,
                    variable: argValue
                };
                break;
            } else {
                // Can't trace further - the value originates here
                flow.origin = {
                    func: callerName,
                    file: callerFunc.file,
                    type: 'expression',
                    value: argValue,
                    variable: null
                };
                break;
            }
        }
        
        // If we traced to the entry function, check its parameters
        if (!flow.origin && path.length > 0) {
            const entryFunc = this.functions.get(path[0].name);
            if (entryFunc && entryFunc.params[argPosition - 1]) {
                flow.origin = {
                    func: path[0].name,
                    file: entryFunc.file,
                    type: 'entry-param',
                    value: entryFunc.params[argPosition - 1].name,
                    variable: null
                };
            }
        }
        
        return flow;
    }

    // Trace where a value comes from within a function
    traceValueOrigin(funcName, value, funcInfo) {
        // Check if it's a parameter
        for (let i = 0; i < funcInfo.params.length; i++) {
            if (funcInfo.params[i].name === value) {
                return { isParam: true, paramIndex: i };
            }
        }
        
        // Check if it's a local variable assignment
        const assignments = this.variableAssignments.get(funcName);
        if (assignments && assignments.has(value)) {
            const assignment = assignments.get(value);
            return {
                isParam: false,
                type: 'variable',
                origin: assignment.value
            };
        }
        
        // Check if it's a literal value
        if (/^[\d\.\-]+$/.test(value) || /^0x[\da-fA-F]+$/.test(value)) {
            return { isParam: false, type: 'literal', origin: value };
        }
        
        // Check if it's a string
        if (value.startsWith('"') || value === '"STRING"') {
            return { isParam: false, type: 'string', origin: value };
        }
        
        // Check if it's a macro/constant
        if (this.macros.has(value)) {
            const macro = this.macros.get(value);
            return { isParam: false, type: 'macro', origin: macro.body };
        }
        
        // Check for common patterns
        if (value.includes('->') || value.includes('.')) {
            return { isParam: false, type: 'member-access', origin: value };
        }
        
        if (value.includes('(')) {
            return { isParam: false, type: 'function-call', origin: value };
        }
        
        // Unknown - likely a global or complex expression
        return { isParam: false, type: 'expression', origin: value };
    }
}

// UI Controller
class UI {
    constructor() {
        this.files = new Map();
        this.parser = null;
        this.results = null;
        this.argFlowResults = null;
        this.currentTab = 'tree';
        
        this.init();
    }

    init() {
        this.uploadZone = document.getElementById('uploadZone');
        this.fileInput = document.getElementById('fileInput');
        this.fileList = document.getElementById('fileList');
        this.analyzeBtn = document.getElementById('analyzeBtn');
        this.clearBtn = document.getElementById('clearBtn');
        this.traceArgBtn = document.getElementById('traceArgBtn');
        this.output = document.getElementById('output');
        this.statsCard = document.getElementById('statsCard');

        this.uploadZone.addEventListener('click', () => this.fileInput.click());
        this.fileInput.addEventListener('change', e => this.handleFiles(e.target.files));
        
        this.uploadZone.addEventListener('dragover', e => {
            e.preventDefault();
            this.uploadZone.style.borderColor = 'var(--cyan)';
        });
        this.uploadZone.addEventListener('dragleave', () => {
            this.uploadZone.style.borderColor = '';
        });
        this.uploadZone.addEventListener('drop', e => {
            e.preventDefault();
            this.uploadZone.style.borderColor = '';
            this.handleFiles(e.dataTransfer.files);
        });

        this.analyzeBtn.addEventListener('click', () => this.analyze());
        this.clearBtn.addEventListener('click', () => this.clear());
        this.traceArgBtn.addEventListener('click', () => this.traceArgument());

        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => this.switchTab(tab.dataset.tab));
        });
    }

    handleFiles(fileList) {
        for (const file of fileList) {
            const ext = file.name.split('.').pop().toLowerCase();
            if (['c', 'h', 'cpp', 'hpp'].includes(ext)) {
                const reader = new FileReader();
                reader.onload = e => {
                    this.files.set(file.name, e.target.result);
                    this.updateFileList();
                };
                reader.readAsText(file);
            }
        }
    }

    updateFileList() {
        this.fileList.innerHTML = '';
        
        for (const name of this.files.keys()) {
            const ext = name.split('.').pop().toLowerCase();
            const type = ['h', 'hpp'].includes(ext) ? 'h' : 'c';
            
            const item = document.createElement('div');
            item.className = 'file-item';
            item.innerHTML = `
                <span><span class="type ${type}">${type.toUpperCase()}</span>${name}</span>
                <button class="remove" data-file="${name}">√ó</button>
            `;
            this.fileList.appendChild(item);
        }

        this.fileList.querySelectorAll('.remove').forEach(btn => {
            btn.addEventListener('click', () => {
                this.files.delete(btn.dataset.file);
                this.updateFileList();
            });
        });

        this.analyzeBtn.disabled = this.files.size === 0;
        this.traceArgBtn.disabled = this.files.size === 0;
        this.uploadZone.classList.toggle('has-files', this.files.size > 0);
    }

    async analyze() {
        const entry = document.getElementById('entryFunc').value.trim();
        const target = document.getElementById('targetFunc').value.trim();
        const maxDepth = parseInt(document.getElementById('maxDepth').value) || 30;

        if (!entry || !target) {
            alert('Please enter entry and target function names');
            return;
        }

        this.output.innerHTML = `
            <div class="progress">
                <div class="progress-bar"><div class="progress-fill" style="width: 10%"></div></div>
                <p class="progress-text">Parsing files...</p>
            </div>
        `;

        await new Promise(r => setTimeout(r, 50));

        const startTime = Date.now();

        try {
            this.parser = new CParser();

            let progress = 10;
            const progressBar = this.output.querySelector('.progress-fill');
            const progressText = this.output.querySelector('.progress-text');

            // Parse headers first
            for (const [name, content] of this.files) {
                const ext = name.split('.').pop().toLowerCase();
                if (['h', 'hpp'].includes(ext)) {
                    this.parser.parseFile(name, content);
                    progress += 30 / this.files.size;
                    progressBar.style.width = progress + '%';
                    progressText.textContent = `Parsing ${name}...`;
                    await new Promise(r => setTimeout(r, 10));
                }
            }

            // Parse source files
            for (const [name, content] of this.files) {
                const ext = name.split('.').pop().toLowerCase();
                if (['c', 'cpp'].includes(ext)) {
                    this.parser.parseFile(name, content);
                    progress += 30 / this.files.size;
                    progressBar.style.width = progress + '%';
                    progressText.textContent = `Parsing ${name}...`;
                    await new Promise(r => setTimeout(r, 10));
                }
            }

            progressBar.style.width = '70%';
            progressText.textContent = 'Building call graph...';
            await new Promise(r => setTimeout(r, 50));

            this.parser.buildGraph();

            progressBar.style.width = '80%';
            progressText.textContent = 'Finding paths...';
            await new Promise(r => setTimeout(r, 50));

            const paths = this.parser.findPaths(entry, target, maxDepth, 100, 5000);

            const elapsed = Date.now() - startTime;

            this.results = { entry, target, paths, elapsed };

            // Update stats
            document.getElementById('statFiles').textContent = this.files.size;
            document.getElementById('statFuncs').textContent = this.parser.functions.size;
            document.getElementById('statMacros').textContent = this.parser.macros.size;
            document.getElementById('statPaths').textContent = paths.length;
            document.getElementById('statDepth').textContent = paths.length > 0 ? Math.max(...paths.map(p => p.length)) : 0;
            document.getElementById('statTime').textContent = elapsed;
            this.statsCard.style.display = 'block';

            this.switchTab(this.currentTab);

        } catch (error) {
            console.error(error);
            this.output.innerHTML = `<div class="error"><strong>Error:</strong> ${error.message}</div>`;
        }
    }

    async traceArgument() {
        const targetFunc = document.getElementById('argTargetFunc').value.trim();
        const argPosition = parseInt(document.getElementById('argPosition').value);
        
        if (!this.parser || !this.results) {
            alert('Please run "Analyze Call Paths" first');
            return;
        }

        if (!targetFunc) {
            alert('Please enter target function name');
            return;
        }

        this.output.innerHTML = `
            <div class="progress">
                <div class="progress-bar"><div class="progress-fill" style="width: 50%"></div></div>
                <p class="progress-text">Tracing argument ${argPosition} of ${targetFunc}...</p>
            </div>
        `;

        await new Promise(r => setTimeout(r, 100));

        try {
            // Find paths that end at the target function
            let pathsToTarget = this.results.paths;
            
            // If target is different from analysis target, find new paths
            if (targetFunc !== this.results.target) {
                pathsToTarget = this.parser.findPaths(this.results.entry, targetFunc, 30, 100, 5000);
            }

            if (pathsToTarget.length === 0) {
                this.output.innerHTML = `<div class="error">No paths found to ${targetFunc}</div>`;
                return;
            }

            // Trace argument flow
            this.argFlowResults = this.parser.traceArgumentFlow(targetFunc, argPosition, pathsToTarget);

            // Switch to arg flow tab
            this.switchTab('argflow');

        } catch (error) {
            console.error(error);
            this.output.innerHTML = `<div class="error"><strong>Error:</strong> ${error.message}</div>`;
        }
    }

    switchTab(tab) {
        this.currentTab = tab;
        
        document.querySelectorAll('.tab').forEach(t => {
            t.classList.toggle('active', t.dataset.tab === tab);
        });

        if (!this.results && !this.parser) return;

        switch (tab) {
            case 'tree': this.renderTree(); break;
            case 'paths': this.renderPaths(); break;
            case 'argflow': this.renderArgFlow(); break;
            case 'funcs': this.renderFunctions(); break;
            case 'log': this.renderLog(); break;
        }
    }

    renderTree() {
        if (!this.results || this.results.paths.length === 0) {
            this.output.innerHTML = `<div style="color:var(--text-muted);text-align:center;padding:50px;">No paths found from ${this.results?.entry || 'entry'} to ${this.results?.target || 'target'}</div>`;
            return;
        }

        const root = { name: this.results.entry, type: 'entry', children: new Map() };
        
        for (const path of this.results.paths) {
            let node = root;
            for (let i = 1; i < path.length; i++) {
                const step = path[i];
                if (!node.children.has(step.name)) {
                    node.children.set(step.name, {
                        name: step.name,
                        type: step.name === this.results.target ? 'target' : step.type,
                        via: step.via,
                        children: new Map()
                    });
                }
                node = node.children.get(step.name);
            }
        }

        let html = '';
        const render = (node, prefix = '', isLast = true) => {
            const conn = isLast ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ ';
            let cls = 'func-inter';
            if (node.type === 'entry') cls = 'func-entry';
            else if (node.type === 'target') cls = 'func-target';
            else if (node.type === 'macro' || node.type === 'macro-invoke') cls = 'func-macro';
            else if (node.type === 'pointer' || node.type === 'callback') cls = 'func-ptr';
            else if (!this.parser.functions.has(node.name)) cls = 'func-ext';

            const marker = node.type === 'target' ? ' ‚òÖ' : '';
            const via = node.via ? ` <span class="file-ref">[via ${node.via}]</span>` : '';
            const file = this.parser.functions.get(node.name)?.file;
            const fileRef = file ? ` <span class="file-ref">[${file}]</span>` : '';

            html += `${prefix}${conn}<span class="${cls}">${node.name}</span>${marker}${via}${fileRef}\n`;

            const children = [...node.children.values()];
            const newPrefix = prefix + (isLast ? '    ' : '‚îÇ   ');
            children.forEach((child, i) => render(child, newPrefix, i === children.length - 1));
        };

        render(root);
        this.output.innerHTML = html;
    }

    renderPaths() {
        if (!this.results || this.results.paths.length === 0) {
            this.output.innerHTML = `<div style="color:var(--text-muted);text-align:center;padding:50px;">No paths found</div>`;
            return;
        }

        let html = '';
        this.results.paths.forEach((path, i) => {
            html += `<div class="path-item">
                <div class="path-header">
                    <span class="path-num">Path ${i + 1}</span>
                    <span style="color:var(--text-muted);font-size:0.75rem;">Depth: ${path.length}</span>
                </div>
                <div class="path-chain">`;
            
            path.forEach((step, j) => {
                const isTarget = j === path.length - 1;
                html += `<span class="func ${isTarget ? 'target' : ''}">${step.name}</span>`;
                if (j < path.length - 1) html += '<span class="arrow">‚Üí</span>';
            });
            
            html += '</div></div>';
        });

        this.output.innerHTML = html;
    }

    renderArgFlow() {
        if (!this.argFlowResults || this.argFlowResults.length === 0) {
            const targetFunc = document.getElementById('argTargetFunc').value.trim() || 'target';
            const argPos = document.getElementById('argPosition').value;
            
            this.output.innerHTML = `
                <div style="color:var(--text-muted);text-align:center;padding:40px;">
                    <div style="font-size:1.5rem;margin-bottom:10px;">üîÑ</div>
                    <div>No argument flow data yet</div>
                    <div style="margin-top:10px;font-size:0.8rem;">
                        Click <strong>"Trace Argument Origin"</strong> to trace where<br>
                        argument ${argPos} of <code>${targetFunc}</code> comes from
                    </div>
                </div>
            `;
            return;
        }

        const argPos = document.getElementById('argPosition').value;
        const targetFunc = document.getElementById('argTargetFunc').value.trim();

        let html = `
            <div class="arg-info-box">
                <div class="label">Tracking</div>
                <div class="value">Argument #${argPos} of <strong>${targetFunc}()</strong></div>
            </div>
        `;

        // Group by origin
        const byOrigin = new Map();
        for (const flow of this.argFlowResults) {
            if (flow.flow.origin) {
                const key = `${flow.flow.origin.func}:${flow.flow.origin.value}`;
                if (!byOrigin.has(key)) {
                    byOrigin.set(key, { origin: flow.flow.origin, paths: [] });
                }
                byOrigin.get(key).paths.push(flow);
            }
        }

        html += `<div style="margin-bottom:15px;color:var(--text-muted);font-size:0.8rem;">
            Found <strong style="color:var(--yellow)">${byOrigin.size}</strong> unique origin(s) across 
            <strong style="color:var(--cyan)">${this.argFlowResults.length}</strong> path(s)
        </div>`;

        let originIdx = 0;
        for (const [key, data] of byOrigin) {
            originIdx++;
            const origin = data.origin;
            
            html += `<div class="arg-flow-item">
                <div class="arg-flow-header">
                    <span class="arg-flow-title">Origin #${originIdx}: ${origin.func}()</span>
                    <span class="arg-flow-badge">${origin.type}</span>
                </div>
                
                <div style="margin-bottom:10px;">
                    <span style="color:var(--text-muted);">Value: </span>
                    <span class="arg-value">${this.escapeHtml(origin.value)}</span>
                    ${origin.variable ? `<span style="color:var(--text-muted);"> (from variable: <code>${origin.variable}</code>)</span>` : ''}
                </div>
                
                <div style="color:var(--text-muted);font-size:0.75rem;margin-bottom:8px;">
                    Source file: <span style="color:var(--purple);">${origin.file}</span>
                </div>
                
                <div style="color:var(--text-muted);font-size:0.75rem;margin-bottom:5px;">
                    Paths using this value (${data.paths.length}):
                </div>`;
            
            // Show first few paths
            const showPaths = data.paths.slice(0, 3);
            for (const pathFlow of showPaths) {
                html += `<div style="font-size:0.7rem;color:var(--text-muted);margin-left:10px;margin-bottom:4px;">
                    Path ${pathFlow.pathIndex}: ${pathFlow.path.map(p => p.name).join(' ‚Üí ')}
                </div>`;
            }
            
            if (data.paths.length > 3) {
                html += `<div style="font-size:0.7rem;color:var(--text-muted);margin-left:10px;">
                    ... and ${data.paths.length - 3} more path(s)
                </div>`;
            }

            // Show flow steps for first path
            if (showPaths[0] && showPaths[0].flow.steps.length > 0) {
                html += `<div style="margin-top:10px;font-size:0.75rem;color:var(--text-muted);">Flow trace:</div>`;
                html += `<div class="arg-flow-chain">`;
                
                for (let i = 0; i < showPaths[0].flow.steps.length; i++) {
                    const step = showPaths[0].flow.steps[i];
                    const isFirst = i === 0;
                    
                    html += `<div class="arg-flow-step ${isFirst ? 'origin' : ''}">
                        <span class="step-func">${step.func}()</span>
                        <span class="step-detail">passes <span class="step-value">${this.escapeHtml(step.passedAs)}</span> as arg #${step.argPos} to ${step.toFunc}()</span>
                    </div>`;
                }
                
                html += `</div>`;
            }
            
            html += `</div>`;
        }

        this.output.innerHTML = html;
    }

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    renderFunctions() {
        if (!this.parser) return;

        let html = `<strong>Functions found: ${this.parser.functions.size}</strong>\n\n`;
        
        for (const [name, func] of this.parser.functions) {
            const callCount = func.calls.size;
            const params = func.params.map(p => p.name).join(', ');
            html += `<span class="func-inter">${name}</span>(<span class="arg-param">${params}</span>) <span class="file-ref">[${func.file}]</span> ‚Üí ${callCount} calls\n`;
        }

        if (this.parser.macros.size > 0) {
            html += `\n<strong>Macros with calls: ${this.parser.macros.size}</strong>\n\n`;
            for (const [name, macro] of this.parser.macros) {
                if (macro.calls.length > 0) {
                    html += `<span class="func-macro">${name}</span> ‚Üí ${macro.calls.join(', ')}\n`;
                }
            }
        }

        this.output.innerHTML = html;
    }

    renderLog() {
        if (!this.parser) return;

        let html = '';
        for (const entry of this.parser.log) {
            const color = entry.type === 'error' ? 'var(--red)' : 
                         entry.type === 'macro' ? 'var(--pink)' :
                         entry.type === 'arg' ? 'var(--yellow)' :
                         entry.type === 'info' ? 'var(--cyan)' : 'var(--text)';
            html += `<span style="color:${color}">[${entry.type.toUpperCase()}]</span> ${entry.msg}\n`;
        }

        this.output.innerHTML = html || '<span style="color:var(--text-muted)">No log entries</span>';
    }

    clear() {
        this.files.clear();
        this.parser = null;
        this.results = null;
        this.argFlowResults = null;
        this.updateFileList();
        this.statsCard.style.display = 'none';
        this.output.innerHTML = `<div style="color:var(--text-muted);text-align:center;padding:50px;">Upload C files and click Analyze to trace call paths</div>`;
    }
}

document.addEventListener('DOMContentLoaded', () => new UI());
</script>
</body>
</html>
