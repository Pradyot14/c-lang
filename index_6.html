<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C Call Tracer + Argument Flow</title>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --border: #30363d;
            --text: #c9d1d9;
            --text-muted: #8b949e;
            --cyan: #58a6ff;
            --green: #3fb950;
            --purple: #a371f7;
            --pink: #f778ba;
            --orange: #d29922;
            --red: #f85149;
            --yellow: #e3b341;
            --teal: #39d3c3;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: var(--bg-primary); color: var(--text); min-height: 100vh; }
        .container { max-width: 1600px; margin: 0 auto; padding: 20px; }
        header { text-align: center; padding: 20px 0; border-bottom: 1px solid var(--border); margin-bottom: 20px; }
        h1 { color: var(--cyan); font-size: 1.8rem; margin-bottom: 5px; }
        .subtitle { color: var(--text-muted); font-size: 0.9rem; }
        
        .main-grid { display: grid; grid-template-columns: 350px 1fr; gap: 20px; }
        @media (max-width: 1000px) { .main-grid { grid-template-columns: 1fr; } }
        
        .card { background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 8px; padding: 16px; margin-bottom: 16px; }
        .card-title { color: var(--cyan); font-size: 0.95rem; font-weight: 600; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid var(--border); }
        
        .upload-zone { border: 2px dashed var(--border); border-radius: 8px; padding: 25px; text-align: center; cursor: pointer; transition: all 0.2s; }
        .upload-zone:hover { border-color: var(--cyan); background: rgba(88, 166, 255, 0.05); }
        .upload-zone.has-files { border-color: var(--green); border-style: solid; }
        .upload-zone p { color: var(--text-muted); margin-bottom: 8px; }
        .upload-zone .badge { display: inline-block; background: var(--bg-tertiary); color: var(--cyan); padding: 3px 8px; border-radius: 4px; font-size: 0.75rem; margin: 2px; font-family: monospace; }
        
        .file-list { max-height: 150px; overflow-y: auto; margin-top: 10px; }
        .file-item { display: flex; justify-content: space-between; align-items: center; background: var(--bg-tertiary); padding: 6px 10px; border-radius: 4px; margin-bottom: 4px; font-size: 0.8rem; font-family: monospace; }
        .file-item .type { padding: 2px 6px; border-radius: 3px; font-size: 0.7rem; margin-right: 8px; }
        .file-item .type.c { background: rgba(63, 185, 80, 0.2); color: var(--green); }
        .file-item .type.h { background: rgba(163, 113, 247, 0.2); color: var(--purple); }
        .file-item .remove { background: none; border: none; color: var(--text-muted); cursor: pointer; font-size: 1rem; }
        .file-item .remove:hover { color: var(--red); }
        
        .form-group { margin-bottom: 12px; }
        .form-group label { display: block; color: var(--text-muted); font-size: 0.8rem; margin-bottom: 4px; }
        .form-group input, .form-group select { width: 100%; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 4px; padding: 8px 10px; color: var(--text); font-family: monospace; }
        .form-group input:focus { outline: none; border-color: var(--cyan); }
        
        .form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .form-row-3 { display: grid; grid-template-columns: 1fr 70px 80px; gap: 8px; }
        
        .btn { width: 100%; padding: 12px; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; transition: all 0.2s; }
        .btn-primary { background: var(--cyan); color: #000; }
        .btn-primary:hover { opacity: 0.9; }
        .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-secondary { background: var(--bg-tertiary); color: var(--text); border: 1px solid var(--border); margin-top: 8px; }
        .btn-arg { background: linear-gradient(135deg, var(--yellow), var(--orange)); color: #000; margin-top: 8px; }
        
        .stats { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-top: 12px; }
        .stat { background: var(--bg-tertiary); padding: 10px; border-radius: 4px; text-align: center; }
        .stat-val { font-size: 1.4rem; font-weight: 700; color: var(--cyan); }
        .stat-label { font-size: 0.7rem; color: var(--text-muted); }
        
        .tabs { display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap; }
        .tab { padding: 8px 16px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 4px; color: var(--text-muted); cursor: pointer; font-size: 0.85rem; }
        .tab:hover { border-color: var(--cyan); color: var(--text); }
        .tab.active { background: rgba(88, 166, 255, 0.1); border-color: var(--cyan); color: var(--cyan); }
        .tab.arg-tab { border-color: var(--yellow); }
        .tab.arg-tab.active { background: rgba(227, 179, 65, 0.15); border-color: var(--yellow); color: var(--yellow); }
        
        .output { background: var(--bg-tertiary); border-radius: 6px; padding: 16px; min-height: 400px; max-height: 600px; overflow: auto; font-family: 'Monaco', 'Menlo', monospace; font-size: 0.8rem; line-height: 1.5; white-space: pre-wrap; }
        
        .progress { padding: 20px; text-align: center; }
        .progress-bar { height: 4px; background: var(--border); border-radius: 2px; margin: 15px 0; overflow: hidden; }
        .progress-fill { height: 100%; background: var(--cyan); transition: width 0.3s; }
        .progress-text { color: var(--text-muted); font-size: 0.85rem; }
        
        .error { background: rgba(248, 81, 73, 0.1); border: 1px solid var(--red); border-radius: 6px; padding: 16px; color: var(--red); }
        .warning { background: rgba(210, 153, 34, 0.1); border: 1px solid var(--orange); border-radius: 6px; padding: 12px; color: var(--orange); margin-bottom: 10px; }
        .success { background: rgba(63, 185, 80, 0.1); border: 1px solid var(--green); border-radius: 6px; padding: 12px; color: var(--green); margin-bottom: 10px; }
        
        .legend { display: flex; flex-wrap: wrap; gap: 12px; margin-bottom: 12px; padding: 10px; background: var(--bg-tertiary); border-radius: 4px; }
        .legend-item { display: flex; align-items: center; gap: 6px; font-size: 0.75rem; color: var(--text-muted); }
        .legend-color { width: 12px; height: 12px; border-radius: 2px; }
        
        .func-entry { color: var(--cyan); }
        .func-target { color: var(--green); font-weight: bold; }
        .func-inter { color: var(--purple); }
        .func-macro { color: var(--pink); }
        .func-ptr { color: #58a6ff; }
        .func-ext { color: var(--orange); }
        .func-arg { color: var(--teal); }
        .file-ref { color: var(--text-muted); }
        
        .path-item { background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 6px; padding: 12px; margin-bottom: 8px; }
        .path-header { display: flex; justify-content: space-between; margin-bottom: 8px; }
        .path-num { background: var(--cyan); color: #000; padding: 2px 8px; border-radius: 10px; font-size: 0.75rem; font-weight: 600; }
        .path-chain { font-family: monospace; font-size: 0.8rem; display: flex; flex-wrap: wrap; gap: 4px; align-items: center; }
        .path-chain .func { background: var(--bg-tertiary); padding: 2px 6px; border-radius: 3px; }
        .path-chain .func.target { background: rgba(63, 185, 80, 0.2); color: var(--green); }
        .path-chain .arrow { color: var(--cyan); }
        
        .arg-box { background: var(--bg-secondary); border: 1px solid var(--yellow); border-radius: 8px; padding: 12px; margin-bottom: 12px; }
        .arg-box-title { color: var(--yellow); font-weight: 600; margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center; }
        .arg-box-badge { background: rgba(227, 179, 65, 0.2); color: var(--yellow); padding: 2px 10px; border-radius: 12px; font-size: 0.7rem; }
        .arg-step { background: var(--bg-tertiary); border-radius: 6px; padding: 10px; margin-bottom: 6px; border-left: 3px solid var(--purple); }
        .arg-step.origin { border-left-color: var(--green); background: rgba(63, 185, 80, 0.05); }
        .arg-step-func { color: var(--purple); font-weight: 600; }
        .arg-step.origin .arg-step-func { color: var(--green); }
        .arg-step-file { color: var(--text-muted); font-size: 0.75rem; }
        .arg-step-detail { margin-top: 4px; }
        .arg-step-detail code { background: var(--bg-secondary); padding: 1px 5px; border-radius: 3px; color: var(--yellow); }
        
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg-tertiary); }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üîç C Call Tracer + Argument Flow (v6)</h1>
            <p class="subtitle">Trace function call paths & backtrack argument origins - <strong>Now with function-as-argument detection!</strong></p>
        </header>
        
        <div class="main-grid">
            <div class="sidebar">
                <div class="card">
                    <div class="card-title">üìÅ Upload Files</div>
                    <div class="upload-zone" id="uploadZone">
                        <p>Drop .c and .h files here</p>
                        <div>
                            <span class="badge">.c</span>
                            <span class="badge">.h</span>
                        </div>
                        <input type="file" id="fileInput" multiple accept=".c,.h,.cpp,.hpp" hidden>
                    </div>
                    <div class="file-list" id="fileList"></div>
                </div>
                
                <div class="card">
                    <div class="card-title">‚öôÔ∏è Configuration</div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Entry Function</label>
                            <input type="text" id="entryFunc" value="main">
                        </div>
                        <div class="form-group">
                            <label>Target Function</label>
                            <input type="text" id="targetFunc" value="mpf_mfs_open">
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Max Search Depth</label>
                        <input type="number" id="maxDepth" value="30" min="5" max="100">
                    </div>
                    <button class="btn btn-primary" id="analyzeBtn" disabled>üî¨ Analyze</button>
                    <button class="btn btn-secondary" id="clearBtn">Clear All</button>
                </div>
                
                <div class="card">
                    <div class="card-title">üîÑ Argument Flow Tracking</div>
                    <div class="form-row-3">
                        <div class="form-group">
                            <label>Target Function</label>
                            <input type="text" id="argTargetFunc" value="mpf_mfs_open">
                        </div>
                        <div class="form-group">
                            <label>Arg #</label>
                            <select id="argPosition">
                                <option value="1">1st</option>
                                <option value="2">2nd</option>
                                <option value="3" selected>3rd</option>
                                <option value="4">4th</option>
                                <option value="5">5th</option>
                                <option value="6">6th</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Name</label>
                            <input type="text" id="argName" value="filenum">
                        </div>
                    </div>
                    <button class="btn btn-arg" id="traceArgBtn" disabled>üîÑ Trace Argument</button>
                </div>
                
                <div class="card" id="statsCard" style="display:none;">
                    <div class="card-title">üìä Results</div>
                    <div class="stats">
                        <div class="stat"><div class="stat-val" id="statFiles">0</div><div class="stat-label">Files</div></div>
                        <div class="stat"><div class="stat-val" id="statFuncs">0</div><div class="stat-label">Functions</div></div>
                        <div class="stat"><div class="stat-val" id="statMacros">0</div><div class="stat-label">Macros</div></div>
                        <div class="stat"><div class="stat-val" id="statPaths">0</div><div class="stat-label">Paths</div></div>
                        <div class="stat"><div class="stat-val" id="statDepth">0</div><div class="stat-label">Max Depth</div></div>
                        <div class="stat"><div class="stat-val" id="statTime">0</div><div class="stat-label">ms</div></div>
                    </div>
                </div>
            </div>
            
            <div class="results">
                <div class="card" style="height: 100%;">
                    <div class="tabs">
                        <button class="tab active" data-tab="tree">Text Tree</button>
                        <button class="tab" data-tab="paths">All Paths</button>
                        <button class="tab arg-tab" data-tab="argflow">üîÑ Arg Flow</button>
                        <button class="tab" data-tab="funcs">Functions</button>
                        <button class="tab" data-tab="log">Log</button>
                    </div>
                    
                    <div class="legend">
                        <div class="legend-item"><div class="legend-color" style="background:var(--cyan)"></div>Entry</div>
                        <div class="legend-item"><div class="legend-color" style="background:var(--green)"></div>Target/Origin</div>
                        <div class="legend-item"><div class="legend-color" style="background:var(--purple)"></div>Intermediate</div>
                        <div class="legend-item"><div class="legend-color" style="background:var(--pink)"></div>Macro</div>
                        <div class="legend-item"><div class="legend-color" style="background:var(--teal)"></div>Func as Arg</div>
                        <div class="legend-item"><div class="legend-color" style="background:var(--yellow)"></div>Argument</div>
                    </div>
                    
                    <div class="output" id="output">
                        <div style="color:var(--text-muted);text-align:center;padding:50px;">
                            Upload C files and click Analyze to trace call paths
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

<script>
// =============================================================================
// CPARSER - ENHANCED WITH FUNCTION-AS-ARGUMENT DETECTION
// =============================================================================
class CParser {
    constructor() {
        this.files = new Map();
        this.functions = new Map();
        this.macros = new Map();
        this.funcPointers = new Map();
        this.callGraph = new Map();
        this.knownFunctions = new Set(); // Track all known function names
        this.log = [];
    }

    addLog(type, msg) {
        this.log.push({ type, msg });
        console.log(`[${type}] ${msg}`);
    }

    clean(code) {
        code = code.replace(/\/\*[\s\S]*?\*\//g, ' ');
        code = code.replace(/\/\/.*$/gm, '');
        code = code.replace(/"(?:[^"\\]|\\.)*"/g, '""');
        code = code.replace(/'(?:[^'\\]|\\.)*'/g, "''");
        return code;
    }

    // First pass: collect all function names from definitions and declarations
    collectFunctionNames(code, file) {
        // Function definitions
        const defRegex = /\b([a-zA-Z_]\w*)\s*\([^)]*\)\s*\{/g;
        let m;
        while ((m = defRegex.exec(code)) !== null) {
            if (this.isValidFunc(m[1])) {
                this.knownFunctions.add(m[1]);
            }
        }
        
        // Function declarations (prototypes)
        const declRegex = /\b([a-zA-Z_]\w*)\s*\([^)]*\)\s*;/g;
        while ((m = declRegex.exec(code)) !== null) {
            if (this.isValidFunc(m[1])) {
                this.knownFunctions.add(m[1]);
            }
        }
        
        // Typedef function pointers: typedef void (*handler_t)(int);
        const typedefRegex = /typedef\s+[\w\s*]+\(\s*\*\s*(\w+)\s*\)/g;
        while ((m = typedefRegex.exec(code)) !== null) {
            // This is a type name, not a function, but track it
        }
    }

    parseMacros(code, file) {
        // Function-like macros: #define NAME(params) body
        const funcMacro = /#\s*define\s+(\w+)\s*\(([^)]*)\)\s*(.+?)(?=\n|$)/g;
        let m;
        while ((m = funcMacro.exec(code)) !== null) {
            const name = m[1];
            const params = m[2].split(',').map(p => p.trim()).filter(p => p);
            const body = m[3].replace(/\\\n/g, ' ').trim();
            
            // Find direct calls in macro body
            const calls = this.findCalls(body);
            
            // Find functions passed as arguments IN the macro body
            const funcArgs = this.findFunctionsAsArguments(body);
            
            this.macros.set(name, { 
                name, 
                params,
                body, 
                calls, 
                funcArgs,
                file 
            });
            
            if (calls.length > 0 || funcArgs.length > 0) {
                this.addLog('macro', `${name}(${params.join(',')}) -> calls:[${calls.join(',')}] func-args:[${funcArgs.join(',')}]`);
            }
        }

        // Object-like macros
        const objMacro = /#\s*define\s+(\w+)\s+([^(\n][^\n]*)/g;
        while ((m = objMacro.exec(code)) !== null) {
            const name = m[1];
            if (!this.macros.has(name)) {
                const body = m[2].trim();
                const calls = this.findCalls(body);
                const funcArgs = this.findFunctionsAsArguments(body);
                this.macros.set(name, { name, params: [], body, calls, funcArgs, file });
            }
        }
    }

    parseFuncPointers(code, file) {
        const patterns = [
            /\.(\w+)\s*=\s*&?(\w+)\s*[,;}\)]/g,
            /(\w+)\s*=\s*&?(\w+)\s*;/g
        ];
        
        for (const pat of patterns) {
            let m;
            while ((m = pat.exec(code)) !== null) {
                const varName = m[1];
                const funcName = m[2];
                if (this.isValidFunc(funcName)) {
                    if (!this.funcPointers.has(varName)) {
                        this.funcPointers.set(varName, new Set());
                    }
                    this.funcPointers.get(varName).add(funcName);
                }
            }
        }
    }

    isValidFunc(name) {
        const keywords = ['if','else','while','for','do','switch','case','break','continue','return','goto','sizeof','NULL','true','false','void','int','char','float','double','long','short','unsigned','signed','const','static','extern','struct','enum','union','typedef','register','volatile','inline','restrict','_Bool','_Complex','_Imaginary'];
        if (keywords.includes(name)) return false;
        if (/^\d/.test(name)) return false;
        if (name.length < 2) return false;
        return true;
    }

    findCalls(code) {
        const calls = [];
        const regex = /\b([a-zA-Z_]\w*)\s*\(/g;
        let m;
        while ((m = regex.exec(code)) !== null) {
            if (this.isValidFunc(m[1])) {
                calls.push(m[1]);
            }
        }
        return [...new Set(calls)];
    }

    // NEW: Find functions that are passed as arguments (not called directly)
    findFunctionsAsArguments(code) {
        const funcArgs = [];
        
        // Pattern 1: func_call(arg1, some_function, arg3) - function name as argument
        // We need to parse argument lists and check if any arg is a known function
        const callRegex = /\b([a-zA-Z_]\w*)\s*\(([^;{}]*?)\)/g;
        let m;
        
        while ((m = callRegex.exec(code)) !== null) {
            const caller = m[1];
            const argsStr = m[2];
            
            if (!this.isValidFunc(caller)) continue;
            
            // Parse arguments
            const args = this.parseArguments(argsStr);
            
            for (const arg of args) {
                const trimmed = arg.trim();
                // Check if this argument looks like a function reference
                // Could be: func_name, &func_name, (type)func_name
                const funcRefMatch = trimmed.match(/^&?(\w+)$/) || 
                                     trimmed.match(/^\([^)]+\)\s*&?(\w+)$/);
                
                if (funcRefMatch) {
                    const potentialFunc = funcRefMatch[1];
                    if (this.isValidFunc(potentialFunc) && potentialFunc !== caller) {
                        // We'll verify later if this is actually a known function
                        funcArgs.push({ func: potentialFunc, passedTo: caller, raw: trimmed });
                    }
                }
            }
        }
        
        return funcArgs;
    }

    // Parse comma-separated arguments handling nested parens
    parseArguments(argsStr) {
        if (!argsStr || !argsStr.trim()) return [];
        
        const args = [];
        let current = '';
        let depth = 0;
        
        for (let i = 0; i < argsStr.length; i++) {
            const c = argsStr[i];
            if (c === '(' || c === '[' || c === '{') {
                depth++;
                current += c;
            } else if (c === ')' || c === ']' || c === '}') {
                depth--;
                current += c;
            } else if (c === ',' && depth === 0) {
                if (current.trim()) args.push(current.trim());
                current = '';
            } else {
                current += c;
            }
        }
        if (current.trim()) args.push(current.trim());
        return args;
    }

    findBrace(code, start, limit = 50000) {
        let depth = 1;
        let i = start;
        const end = Math.min(code.length, start + limit);
        while (i < end && depth > 0) {
            if (code[i] === '{') depth++;
            else if (code[i] === '}') depth--;
            i++;
        }
        return depth === 0 ? i : -1;
    }

    parseFunctions(code, file) {
        const clean = this.clean(code);
        
        const funcRegex = /\b([a-zA-Z_]\w*)\s*\(([^)]*)\)\s*\{/g;
        let m;
        
        while ((m = funcRegex.exec(clean)) !== null) {
            const name = m[1];
            const paramsStr = m[2];
            
            if (!this.isValidFunc(name)) continue;
            
            const bodyStart = m.index + m[0].length;
            const bodyEnd = this.findBrace(clean, bodyStart);
            
            if (bodyEnd === -1) continue;
            
            const body = clean.substring(bodyStart - 1, bodyEnd);
            const directCalls = this.findCalls(body);
            
            const allCalls = new Map();
            
            // Process direct calls
            for (const call of directCalls) {
                if (this.macros.has(call)) {
                    const macro = this.macros.get(call);
                    allCalls.set(call, { type: 'macro-invoke' });
                    // Functions called BY the macro
                    for (const mc of macro.calls) {
                        allCalls.set(mc, { type: 'macro', via: call });
                    }
                    // Functions passed AS ARGUMENTS to the macro at definition time
                    // (This is in the macro body itself)
                    for (const fa of macro.funcArgs) {
                        if (this.knownFunctions.has(fa.func) || this.functions.has(fa.func)) {
                            allCalls.set(fa.func, { type: 'macro-arg', via: call });
                        }
                    }
                } else if (this.funcPointers.has(call)) {
                    for (const target of this.funcPointers.get(call)) {
                        allCalls.set(target, { type: 'pointer', via: call });
                    }
                } else {
                    allCalls.set(call, { type: 'direct' });
                }
            }

            // NEW: Find functions passed as arguments in THIS function's body
            const funcArgsInBody = this.findFunctionsPassedAsArgs(body, name);
            for (const fa of funcArgsInBody) {
                if (!allCalls.has(fa.func)) {
                    allCalls.set(fa.func, { type: 'func-arg', via: fa.passedTo });
                    this.addLog('func-arg', `${name}() passes ${fa.func} as arg to ${fa.passedTo}()`);
                }
            }

            // Callback patterns: ptr->member()
            const cbRegex = /(\w+)->(\w+)\s*\(/g;
            let cb;
            while ((cb = cbRegex.exec(body)) !== null) {
                const member = cb[2];
                if (this.funcPointers.has(member)) {
                    for (const target of this.funcPointers.get(member)) {
                        allCalls.set(target, { type: 'callback', via: member });
                    }
                }
            }

            this.functions.set(name, {
                name,
                file,
                params: paramsStr,
                calls: allCalls
            });
        }
    }

    // NEW: Enhanced function to find functions passed as arguments
    findFunctionsPassedAsArgs(body, currentFunc) {
        const results = [];
        
        // Pattern: function_call(arg1, potential_func, arg2)
        // We need to find all function calls and check their arguments
        const callRegex = /\b([a-zA-Z_]\w*)\s*\(/g;
        let match;
        
        while ((match = callRegex.exec(body)) !== null) {
            const callee = match[1];
            if (!this.isValidFunc(callee)) continue;
            
            const parenStart = match.index + match[0].length - 1;
            
            // Find matching parenthesis
            let depth = 1;
            let j = parenStart + 1;
            while (j < body.length && depth > 0) {
                if (body[j] === '(') depth++;
                else if (body[j] === ')') depth--;
                j++;
            }
            
            if (depth === 0) {
                const argsStr = body.substring(parenStart + 1, j - 1);
                const args = this.parseArguments(argsStr);
                
                for (const arg of args) {
                    const trimmed = arg.trim();
                    
                    // Check various patterns for function references:
                    // 1. Direct: func_name
                    // 2. Address-of: &func_name  
                    // 3. Cast: (type)func_name or (type)&func_name
                    // 4. In macro: MACRO(func_name)
                    
                    const patterns = [
                        /^&?([a-zA-Z_]\w*)$/,                          // func or &func
                        /^\([^)]+\)\s*&?([a-zA-Z_]\w*)$/,              // (cast)func
                        /^[A-Z_]+\s*\(\s*&?([a-zA-Z_]\w*)\s*\)$/,      // MACRO(func)
                    ];
                    
                    for (const pat of patterns) {
                        const funcMatch = trimmed.match(pat);
                        if (funcMatch) {
                            const potentialFunc = funcMatch[1];
                            // Check if this is a known function (not the current one, not the callee)
                            if (potentialFunc !== currentFunc && 
                                potentialFunc !== callee &&
                                this.isValidFunc(potentialFunc) &&
                                (this.knownFunctions.has(potentialFunc) || 
                                 this.functions.has(potentialFunc))) {
                                results.push({ 
                                    func: potentialFunc, 
                                    passedTo: callee,
                                    raw: trimmed 
                                });
                            }
                            break;
                        }
                    }
                }
            }
        }
        
        // Also check for macro invocations with function arguments
        for (const [macroName, macro] of this.macros) {
            const macroRegex = new RegExp(`\\b${macroName}\\s*\\(([^;{}]*?)\\)`, 'g');
            let mm;
            while ((mm = macroRegex.exec(body)) !== null) {
                const args = this.parseArguments(mm[1]);
                for (let i = 0; i < args.length; i++) {
                    const arg = args[i].trim();
                    // Check if arg is a function name
                    const funcMatch = arg.match(/^&?([a-zA-Z_]\w*)$/);
                    if (funcMatch) {
                        const potentialFunc = funcMatch[1];
                        if (potentialFunc !== currentFunc &&
                            this.isValidFunc(potentialFunc) &&
                            (this.knownFunctions.has(potentialFunc) || 
                             this.functions.has(potentialFunc))) {
                            results.push({
                                func: potentialFunc,
                                passedTo: macroName,
                                viaMacroArg: i,
                                raw: arg
                            });
                            this.addLog('macro-arg-use', `${currentFunc}() passes ${potentialFunc} to macro ${macroName}() arg #${i+1}`);
                        }
                    }
                }
            }
        }
        
        return results;
    }

    buildGraph() {
        for (const [name, func] of this.functions) {
            this.callGraph.set(name, func.calls);
        }
        this.addLog('info', `Built call graph with ${this.functions.size} functions, ${this.knownFunctions.size} known function names`);
    }

    parseFile(filename, content) {
        this.addLog('info', `Parsing ${filename} (${content.length} bytes)`);
        this.files.set(filename, content);
        
        try {
            // First pass: collect all function names
            this.collectFunctionNames(this.clean(content), filename);
            
            this.parseMacros(content, filename);
            this.parseFuncPointers(content, filename);
            this.parseFunctions(content, filename);
        } catch (e) {
            this.addLog('error', `Error parsing ${filename}: ${e.message}`);
        }
    }

    // Second pass after all files parsed - re-check function arguments
    finalizeGraph() {
        this.addLog('info', 'Finalizing graph - second pass for function arguments');
        
        for (const [funcName, func] of this.functions) {
            const body = this.files.get(func.file);
            if (!body) continue;
            
            // Re-scan for function arguments now that we know all functions
            const clean = this.clean(body);
            const funcRegex = new RegExp(`\\b${funcName}\\s*\\([^)]*\\)\\s*\\{`);
            const match = funcRegex.exec(clean);
            if (!match) continue;
            
            const bodyStart = match.index + match[0].length;
            const bodyEnd = this.findBrace(clean, bodyStart);
            if (bodyEnd === -1) continue;
            
            const funcBody = clean.substring(bodyStart - 1, bodyEnd);
            const funcArgsInBody = this.findFunctionsPassedAsArgs(funcBody, funcName);
            
            for (const fa of funcArgsInBody) {
                if (!func.calls.has(fa.func) && this.functions.has(fa.func)) {
                    func.calls.set(fa.func, { type: 'func-arg', via: fa.passedTo });
                    this.addLog('func-arg-final', `${funcName}() -> ${fa.func} (via ${fa.passedTo})`);
                }
            }
        }
        
        // Rebuild graph
        this.callGraph.clear();
        for (const [name, func] of this.functions) {
            this.callGraph.set(name, func.calls);
        }
    }

    findPaths(entry, target, maxDepth = 30, maxPaths = 100, maxTime = 5000) {
        const paths = [];
        const startTime = Date.now();
        
        if (!this.callGraph.has(entry)) {
            this.addLog('error', `Entry function '${entry}' not found`);
            return paths;
        }

        const dfs = (current, path, visited) => {
            if (Date.now() - startTime > maxTime) return;
            if (paths.length >= maxPaths) return;
            if (path.length > maxDepth) return;
            if (visited.has(current)) return;

            if (current === target) {
                paths.push([...path]);
                return;
            }

            visited.add(current);
            
            const calls = this.callGraph.get(current);
            if (calls) {
                for (const [callee, info] of calls) {
                    path.push({ name: callee, ...info });
                    dfs(callee, path, visited);
                    path.pop();
                }
            }

            visited.delete(current);
        };

        dfs(entry, [{ name: entry, type: 'entry' }], new Set());
        
        this.addLog('info', `Found ${paths.length} paths in ${Date.now() - startTime}ms`);
        return paths;
    }
}

// =============================================================================
// ARGUMENT TRACKER - SEPARATE CLASS FOR ROBUST ARGUMENT FLOW TRACKING
// =============================================================================
class ArgumentTracker {
    constructor() {
        this.funcBodies = new Map();
        this.funcParams = new Map();
        this.callsWithArgs = new Map();
        this.varOrigins = new Map();
        this.funcFiles = new Map();
        this.log = [];
    }

    addLog(msg) {
        this.log.push(msg);
        console.log('[ARG] ' + msg);
    }

    removeComments(code) {
        code = code.replace(/\/\*[\s\S]*?\*\//g, ' ');
        code = code.replace(/\/\/.*$/gm, '');
        return code;
    }

    parseParams(paramsStr) {
        const params = [];
        if (!paramsStr || !paramsStr.trim() || paramsStr.trim() === 'void') return params;
        
        const parts = paramsStr.split(',');
        for (const part of parts) {
            const trimmed = part.trim();
            if (!trimmed) continue;
            const match = trimmed.match(/(\w+)\s*(?:\[\s*\d*\s*\])?\s*$/);
            if (match) {
                params.push({ name: match[1], full: trimmed });
            }
        }
        return params;
    }

    parseArgs(argsStr) {
        if (!argsStr || !argsStr.trim()) return [];
        
        const args = [];
        let current = '';
        let depth = 0;
        let inString = false;
        let stringChar = '';
        
        for (let i = 0; i < argsStr.length; i++) {
            const c = argsStr[i];
            const prev = i > 0 ? argsStr[i-1] : '';
            
            if ((c === '"' || c === "'") && prev !== '\\') {
                if (!inString) {
                    inString = true;
                    stringChar = c;
                } else if (c === stringChar) {
                    inString = false;
                }
                current += c;
                continue;
            }
            
            if (inString) {
                current += c;
                continue;
            }
            
            if (c === '(' || c === '[' || c === '{') {
                depth++;
                current += c;
            } else if (c === ')' || c === ']' || c === '}') {
                depth--;
                current += c;
            } else if (c === ',' && depth === 0) {
                if (current.trim()) args.push(current.trim());
                current = '';
            } else {
                current += c;
            }
        }
        
        if (current.trim()) args.push(current.trim());
        return args;
    }

    findBrace(code, start) {
        let depth = 1, i = start;
        const end = Math.min(code.length, start + 100000);
        while (i < end && depth > 0) {
            if (code[i] === '{') depth++;
            else if (code[i] === '}') depth--;
            i++;
        }
        return depth === 0 ? i : -1;
    }

    parseFiles(files) {
        for (const [filename, content] of files) {
            const code = this.removeComments(content);
            
            const funcRegex = /\b([a-zA-Z_]\w*)\s*\(([^)]*)\)\s*\{/g;
            let m;
            
            while ((m = funcRegex.exec(code)) !== null) {
                const name = m[1];
                const paramsStr = m[2];
                
                const keywords = ['if','else','while','for','do','switch','case','return','sizeof'];
                if (keywords.includes(name)) continue;
                if (/^\d/.test(name) || name.length < 2) continue;
                
                const bodyStart = m.index + m[0].length;
                const bodyEnd = this.findBrace(code, bodyStart);
                if (bodyEnd === -1) continue;
                
                const body = code.substring(bodyStart - 1, bodyEnd);
                
                this.funcBodies.set(name, body);
                this.funcParams.set(name, this.parseParams(paramsStr));
                this.funcFiles.set(name, filename);
                
                this.extractCallsWithArgs(name, body);
                this.extractVarOrigins(name, body, this.funcParams.get(name));
            }
        }
        
        this.addLog(`Parsed ${this.funcBodies.size} functions for argument tracking`);
    }

    extractCallsWithArgs(funcName, body) {
        const calls = [];
        const regex = /\b([a-zA-Z_]\w*)\s*\(/g;
        let match;
        
        while ((match = regex.exec(body)) !== null) {
            const callee = match[1];
            const keywords = ['if','else','while','for','do','switch','case','return','sizeof'];
            if (keywords.includes(callee)) continue;
            if (/^\d/.test(callee) || callee.length < 2) continue;
            
            const parenStart = match.index + match[0].length - 1;
            
            let depth = 1;
            let j = parenStart + 1;
            let inStr = false, strChr = '';
            
            while (j < body.length && depth > 0) {
                const c = body[j];
                const prev = j > 0 ? body[j-1] : '';
                
                if ((c === '"' || c === "'") && prev !== '\\') {
                    if (!inStr) { inStr = true; strChr = c; }
                    else if (c === strChr) { inStr = false; }
                }
                
                if (!inStr) {
                    if (c === '(') depth++;
                    else if (c === ')') depth--;
                }
                j++;
            }
            
            if (depth === 0) {
                const argsStr = body.substring(parenStart + 1, j - 1);
                const args = this.parseArgs(argsStr);
                const line = (body.substring(0, match.index).match(/\n/g) || []).length + 1;
                
                calls.push({ callee, args, argsRaw: argsStr.trim(), line });
            }
        }
        
        this.callsWithArgs.set(funcName, calls);
    }

    extractVarOrigins(funcName, body, params) {
        const origins = new Map();
        
        params.forEach((p, idx) => {
            origins.set(p.name, { type: 'parameter', paramIndex: idx, value: `(param #${idx + 1})` });
        });
        
        const declRe = /\b(?:const\s+)?(?:unsigned\s+|signed\s+)?(?:int|char|short|long|float|double|void|size_t|ssize_t|uint\d+_t|int\d+_t|\w+_t)\s*\*?\s*(\w+)\s*=\s*([^;]+);/g;
        let m;
        while ((m = declRe.exec(body)) !== null) {
            if (!origins.has(m[1])) {
                origins.set(m[1], { type: this.classifyValue(m[2].trim()), value: m[2].trim() });
            }
        }
        
        const assignRe = /\b(\w+)\s*=\s*([^;=!<>]+);/g;
        while ((m = assignRe.exec(body)) !== null) {
            const varName = m[1];
            const value = m[2].trim();
            if (!origins.has(varName) && !['if','while','for','switch','return'].includes(varName)) {
                origins.set(varName, { type: this.classifyValue(value), value });
            }
        }
        
        this.varOrigins.set(funcName, origins);
    }

    classifyValue(value) {
        if (!value) return 'unknown';
        value = value.trim();
        if (/^-?\d+$/.test(value)) return 'literal-int';
        if (/^0x[\da-fA-F]+$/i.test(value)) return 'literal-hex';
        if (/^-?\d+\.\d*f?$/.test(value)) return 'literal-float';
        if (/^["']/.test(value)) return 'literal-string';
        if (value === 'NULL' || value === 'nullptr') return 'literal-null';
        if (value.includes('->')) return 'member-ptr';
        if (value.includes('.') && !value.includes('(')) return 'member-dot';
        if (value.includes('[')) return 'array-access';
        if (/\w+\s*\(/.test(value)) return 'function-call';
        if (/^[a-zA-Z_]\w*$/.test(value)) return 'variable';
        return 'expression';
    }

    traceArgumentFlow(targetFunc, argPosition, paths) {
        this.addLog(`=== Tracing arg #${argPosition} of ${targetFunc}() ===`);
        
        const results = [];
        
        for (let pathIdx = 0; pathIdx < paths.length; pathIdx++) {
            const path = paths[pathIdx];
            this.addLog(`Path ${pathIdx + 1}: ${path.map(p => p.name).join(' ‚Üí ')}`);
            
            const trace = this.traceArgInPath(targetFunc, argPosition, path);
            results.push({ pathIndex: pathIdx + 1, path, trace });
        }
        
        return results;
    }

    traceArgInPath(targetFunc, argPosition, path) {
        const trace = {
            targetFunc,
            argPosition,
            steps: [],
            origin: null,
            debug: []
        };
        
        let currentArgPos = argPosition;
        
        for (let i = path.length - 1; i >= 0; i--) {
            const funcName = path[i].name;
            
            trace.debug.push(`[${funcName}]`);
            
            if (funcName === targetFunc && i === path.length - 1) {
                const params = this.funcParams.get(funcName);
                if (params && params[currentArgPos - 1]) {
                    trace.debug.push(`  Target param #${currentArgPos}: ${params[currentArgPos - 1].name}`);
                }
                continue;
            }
            
            const nextFunc = path[i + 1]?.name;
            if (!nextFunc) continue;
            
            const calls = this.callsWithArgs.get(funcName);
            if (!calls) {
                trace.debug.push(`  No call data`);
                continue;
            }
            
            const callsToNext = calls.filter(c => c.callee === nextFunc);
            trace.debug.push(`  Found ${callsToNext.length} call(s) to ${nextFunc}`);
            
            if (callsToNext.length === 0) continue;
            
            const call = callsToNext[0];
            trace.debug.push(`  Call: ${call.callee}(${call.argsRaw.substring(0, 80)}...)`);
            trace.debug.push(`  Args: [${call.args.map((a,i) => `${i+1}:${a}`).join(' | ')}]`);
            
            const argValue = call.args[currentArgPos - 1];
            
            if (!argValue) {
                trace.debug.push(`  Arg #${currentArgPos} NOT FOUND`);
                continue;
            }
            
            trace.debug.push(`  Arg #${currentArgPos} = "${argValue}"`);
            
            trace.steps.push({
                func: funcName,
                file: this.funcFiles.get(funcName) || 'unknown',
                callsFunc: nextFunc,
                argPos: currentArgPos,
                argValue: argValue,
                line: call.line
            });
            
            const params = this.funcParams.get(funcName);
            if (params) {
                const paramIdx = params.findIndex(p => p.name === argValue);
                if (paramIdx !== -1) {
                    trace.debug.push(`  ‚Üí "${argValue}" is param #${paramIdx + 1}`);
                    currentArgPos = paramIdx + 1;
                    continue;
                }
            }
            
            const origins = this.varOrigins.get(funcName);
            if (origins && origins.has(argValue)) {
                const info = origins.get(argValue);
                trace.debug.push(`  ‚Üí "${argValue}" = ${info.type}: ${info.value}`);
                
                if (info.type === 'parameter') {
                    currentArgPos = info.paramIndex + 1;
                    continue;
                }
                
                trace.origin = {
                    func: funcName,
                    file: this.funcFiles.get(funcName) || 'unknown',
                    type: info.type,
                    value: info.value,
                    variable: argValue
                };
                break;
            }
            
            const vtype = this.classifyValue(argValue);
            trace.debug.push(`  ‚Üí Direct: ${vtype}`);
            
            trace.origin = {
                func: funcName,
                file: this.funcFiles.get(funcName) || 'unknown',
                type: vtype,
                value: argValue,
                variable: vtype === 'variable' ? argValue : null
            };
            break;
        }
        
        if (!trace.origin && path.length > 0) {
            const entryParams = this.funcParams.get(path[0].name);
            if (entryParams && entryParams[currentArgPos - 1]) {
                trace.origin = {
                    func: path[0].name,
                    file: this.funcFiles.get(path[0].name) || 'unknown',
                    type: 'entry-parameter',
                    value: entryParams[currentArgPos - 1].name,
                    variable: entryParams[currentArgPos - 1].name
                };
            }
        }
        
        return trace;
    }
}

// =============================================================================
// UI CONTROLLER
// =============================================================================
class UI {
    constructor() {
        this.files = new Map();
        this.parser = null;
        this.argTracker = null;
        this.results = null;
        this.argResults = null;
        this.currentTab = 'tree';
        this.init();
    }

    init() {
        this.uploadZone = document.getElementById('uploadZone');
        this.fileInput = document.getElementById('fileInput');
        this.fileList = document.getElementById('fileList');
        this.analyzeBtn = document.getElementById('analyzeBtn');
        this.clearBtn = document.getElementById('clearBtn');
        this.traceArgBtn = document.getElementById('traceArgBtn');
        this.output = document.getElementById('output');
        this.statsCard = document.getElementById('statsCard');

        this.uploadZone.addEventListener('click', () => this.fileInput.click());
        this.fileInput.addEventListener('change', e => this.handleFiles(e.target.files));
        
        this.uploadZone.addEventListener('dragover', e => { e.preventDefault(); this.uploadZone.style.borderColor = 'var(--cyan)'; });
        this.uploadZone.addEventListener('dragleave', () => { this.uploadZone.style.borderColor = ''; });
        this.uploadZone.addEventListener('drop', e => { e.preventDefault(); this.uploadZone.style.borderColor = ''; this.handleFiles(e.dataTransfer.files); });

        this.analyzeBtn.addEventListener('click', () => this.analyze());
        this.clearBtn.addEventListener('click', () => this.clear());
        this.traceArgBtn.addEventListener('click', () => this.traceArgument());

        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => this.switchTab(tab.dataset.tab));
        });
    }

    handleFiles(fileList) {
        for (const file of fileList) {
            const ext = file.name.split('.').pop().toLowerCase();
            if (['c', 'h', 'cpp', 'hpp'].includes(ext)) {
                const reader = new FileReader();
                reader.onload = e => { this.files.set(file.name, e.target.result); this.updateFileList(); };
                reader.readAsText(file);
            }
        }
    }

    updateFileList() {
        this.fileList.innerHTML = '';
        for (const name of this.files.keys()) {
            const ext = name.split('.').pop().toLowerCase();
            const type = ['h', 'hpp'].includes(ext) ? 'h' : 'c';
            const item = document.createElement('div');
            item.className = 'file-item';
            item.innerHTML = `<span><span class="type ${type}">${type.toUpperCase()}</span>${name}</span><button class="remove" data-file="${name}">√ó</button>`;
            this.fileList.appendChild(item);
        }
        this.fileList.querySelectorAll('.remove').forEach(btn => {
            btn.addEventListener('click', () => { this.files.delete(btn.dataset.file); this.updateFileList(); });
        });
        this.analyzeBtn.disabled = this.files.size === 0;
        this.traceArgBtn.disabled = this.files.size === 0;
        this.uploadZone.classList.toggle('has-files', this.files.size > 0);
    }

    async analyze() {
        const entry = document.getElementById('entryFunc').value.trim();
        const target = document.getElementById('targetFunc').value.trim();
        const maxDepth = parseInt(document.getElementById('maxDepth').value) || 30;

        if (!entry || !target) { alert('Please enter entry and target function names'); return; }

        this.output.innerHTML = `<div class="progress"><div class="progress-bar"><div class="progress-fill" style="width: 10%"></div></div><p class="progress-text">Parsing files...</p></div>`;
        await new Promise(r => setTimeout(r, 50));
        const startTime = Date.now();

        try {
            this.parser = new CParser();
            const progressBar = this.output.querySelector('.progress-fill');
            const progressText = this.output.querySelector('.progress-text');
            let progress = 10;

            // Parse headers first
            for (const [name, content] of this.files) {
                if (['h', 'hpp'].includes(name.split('.').pop().toLowerCase())) {
                    this.parser.parseFile(name, content);
                    progress += 25 / this.files.size;
                    progressBar.style.width = progress + '%';
                    progressText.textContent = `Parsing ${name}...`;
                    await new Promise(r => setTimeout(r, 10));
                }
            }

            // Parse source files
            for (const [name, content] of this.files) {
                if (['c', 'cpp'].includes(name.split('.').pop().toLowerCase())) {
                    this.parser.parseFile(name, content);
                    progress += 25 / this.files.size;
                    progressBar.style.width = progress + '%';
                    progressText.textContent = `Parsing ${name}...`;
                    await new Promise(r => setTimeout(r, 10));
                }
            }

            progressBar.style.width = '65%'; progressText.textContent = 'Building call graph...';
            await new Promise(r => setTimeout(r, 50));
            this.parser.buildGraph();

            // NEW: Finalize graph with second pass for function arguments
            progressBar.style.width = '70%'; progressText.textContent = 'Detecting function arguments...';
            await new Promise(r => setTimeout(r, 30));
            this.parser.finalizeGraph();

            // Build argument tracker
            progressBar.style.width = '75%'; progressText.textContent = 'Building argument tracker...';
            await new Promise(r => setTimeout(r, 30));
            this.argTracker = new ArgumentTracker();
            this.argTracker.parseFiles(this.files);

            progressBar.style.width = '80%'; progressText.textContent = 'Finding paths...';
            await new Promise(r => setTimeout(r, 50));
            const paths = this.parser.findPaths(entry, target, maxDepth, 100, 5000);
            const elapsed = Date.now() - startTime;

            this.results = { entry, target, paths, elapsed };

            document.getElementById('statFiles').textContent = this.files.size;
            document.getElementById('statFuncs').textContent = this.parser.functions.size;
            document.getElementById('statMacros').textContent = this.parser.macros.size;
            document.getElementById('statPaths').textContent = paths.length;
            document.getElementById('statDepth').textContent = paths.length > 0 ? Math.max(...paths.map(p => p.length)) : 0;
            document.getElementById('statTime').textContent = elapsed;
            this.statsCard.style.display = 'block';

            this.switchTab(this.currentTab);
        } catch (error) {
            console.error(error);
            this.output.innerHTML = `<div class="error"><strong>Error:</strong> ${error.message}</div>`;
        }
    }

    async traceArgument() {
        const targetFunc = document.getElementById('argTargetFunc').value.trim();
        const argPosition = parseInt(document.getElementById('argPosition').value);
        const argName = document.getElementById('argName').value.trim();

        if (!this.parser || !this.results || !this.argTracker) { alert('Run "Analyze" first'); return; }

        this.output.innerHTML = `<div class="progress"><div class="progress-bar"><div class="progress-fill" style="width: 50%"></div></div><p class="progress-text">Tracing arg #${argPosition} (${argName || 'unnamed'}) of ${targetFunc}...</p></div>`;
        await new Promise(r => setTimeout(r, 50));

        try {
            let pathsToTarget = this.results.paths;
            if (targetFunc !== this.results.target) {
                pathsToTarget = this.parser.findPaths(this.results.entry, targetFunc, 30, 100, 5000);
            }

            if (pathsToTarget.length === 0) {
                this.output.innerHTML = `<div class="error">No paths found to ${targetFunc}</div>`;
                return;
            }

            this.argResults = {
                targetFunc, argPosition, argName,
                traces: this.argTracker.traceArgumentFlow(targetFunc, argPosition, pathsToTarget)
            };
            this.switchTab('argflow');
        } catch (error) {
            console.error(error);
            this.output.innerHTML = `<div class="error"><strong>Error:</strong> ${error.message}</div>`;
        }
    }

    switchTab(tab) {
        this.currentTab = tab;
        document.querySelectorAll('.tab').forEach(t => t.classList.toggle('active', t.dataset.tab === tab));
        if (!this.results && !this.parser) return;

        switch (tab) {
            case 'tree': this.renderTree(); break;
            case 'paths': this.renderPaths(); break;
            case 'argflow': this.renderArgFlow(); break;
            case 'funcs': this.renderFunctions(); break;
            case 'log': this.renderLog(); break;
        }
    }

    renderTree() {
        if (!this.results || this.results.paths.length === 0) {
            this.output.innerHTML = `<div style="color:var(--text-muted);text-align:center;padding:50px;">No paths found from ${this.results?.entry || 'entry'} to ${this.results?.target || 'target'}</div>`;
            return;
        }

        const root = { name: this.results.entry, type: 'entry', children: new Map() };
        for (const path of this.results.paths) {
            let node = root;
            for (let i = 1; i < path.length; i++) {
                const step = path[i];
                if (!node.children.has(step.name)) {
                    node.children.set(step.name, { 
                        name: step.name, 
                        type: step.name === this.results.target ? 'target' : step.type, 
                        via: step.via, 
                        children: new Map() 
                    });
                }
                node = node.children.get(step.name);
            }
        }

        let html = '';
        const render = (node, prefix = '', isLast = true) => {
            const conn = isLast ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ ';
            let cls = 'func-inter';
            if (node.type === 'entry') cls = 'func-entry';
            else if (node.type === 'target') cls = 'func-target';
            else if (node.type === 'macro' || node.type === 'macro-invoke') cls = 'func-macro';
            else if (node.type === 'macro-arg') cls = 'func-macro';
            else if (node.type === 'pointer' || node.type === 'callback') cls = 'func-ptr';
            else if (node.type === 'func-arg') cls = 'func-arg';
            else if (!this.parser.functions.has(node.name)) cls = 'func-ext';

            const marker = node.type === 'target' ? ' ‚òÖ' : '';
            let via = '';
            if (node.via) {
                if (node.type === 'func-arg') {
                    via = ` <span class="file-ref">[passed to ${node.via}]</span>`;
                } else if (node.type === 'macro-arg') {
                    via = ` <span class="file-ref">[macro arg: ${node.via}]</span>`;
                } else {
                    via = ` <span class="file-ref">[via ${node.via}]</span>`;
                }
            }
            const file = this.parser.functions.get(node.name)?.file;
            const fileRef = file ? ` <span class="file-ref">[${file}]</span>` : '';
            
            // Add type indicator for special types
            let typeIndicator = '';
            if (node.type === 'func-arg') typeIndicator = '<span style="color:var(--teal)">[arg‚Üí]</span> ';
            else if (node.type === 'macro-arg') typeIndicator = '<span style="color:var(--pink)">[M-arg]</span> ';
            
            html += `${prefix}${conn}${typeIndicator}<span class="${cls}">${node.name}</span>${marker}${via}${fileRef}\n`;

            const children = [...node.children.values()];
            const newPrefix = prefix + (isLast ? '    ' : '‚îÇ   ');
            children.forEach((child, i) => render(child, newPrefix, i === children.length - 1));
        };
        render(root);
        this.output.innerHTML = html;
    }

    renderPaths() {
        if (!this.results || this.results.paths.length === 0) {
            this.output.innerHTML = `<div style="color:var(--text-muted);text-align:center;padding:50px;">No paths found</div>`;
            return;
        }
        let html = '';
        this.results.paths.forEach((path, i) => {
            html += `<div class="path-item"><div class="path-header"><span class="path-num">Path ${i + 1}</span><span style="color:var(--text-muted);font-size:0.8rem;">Depth: ${path.length}</span></div><div class="path-chain">`;
            path.forEach((step, j) => {
                const isTarget = j === path.length - 1;
                let typeClass = '';
                if (step.type === 'func-arg') typeClass = 'style="border:1px solid var(--teal)"';
                else if (step.type === 'macro-arg') typeClass = 'style="border:1px solid var(--pink)"';
                html += `<span class="func ${isTarget ? 'target' : ''}" ${typeClass}>${step.name}</span>`;
                if (j < path.length - 1) {
                    let arrowStyle = '';
                    const nextStep = path[j + 1];
                    if (nextStep.type === 'func-arg') arrowStyle = 'style="color:var(--teal)"';
                    else if (nextStep.type === 'macro-arg') arrowStyle = 'style="color:var(--pink)"';
                    html += `<span class="arrow" ${arrowStyle}>‚Üí</span>`;
                }
            });
            html += '</div></div>';
        });
        this.output.innerHTML = html;
    }

    renderArgFlow() {
        if (!this.argResults) {
            this.output.innerHTML = `<div style="color:var(--text-muted);text-align:center;padding:50px;">Click "Trace Argument" to analyze</div>`;
            return;
        }

        const { targetFunc, argPosition, argName, traces } = this.argResults;
        let html = `<div class="arg-box"><div class="arg-box-title"><span>üéØ ${targetFunc}() ‚Üí Arg #${argPosition}${argName ? ` (${argName})` : ''}</span><span class="arg-box-badge">${traces.length} path(s)</span></div></div>`;

        const byOrigin = new Map();
        const noOrigin = [];
        for (const t of traces) {
            if (t.trace.origin) {
                const key = `${t.trace.origin.func}::${t.trace.origin.value}`;
                if (!byOrigin.has(key)) byOrigin.set(key, { origin: t.trace.origin, traces: [] });
                byOrigin.get(key).traces.push(t);
            } else {
                noOrigin.push(t);
            }
        }

        if (byOrigin.size === 0) {
            html += `<div class="warning">‚ö†Ô∏è Could not trace argument origin. Check Log tab.</div>`;
            if (traces.length > 0 && traces[0].trace.debug.length > 0) {
                html += `<div style="background:var(--bg-tertiary);padding:10px;border-radius:6px;font-size:0.75rem;max-height:200px;overflow:auto;"><strong>Debug:</strong>\n`;
                for (const d of traces[0].trace.debug) html += `${this.esc(d)}\n`;
                html += `</div>`;
            }
        } else {
            html += `<div class="success">‚úì Found <strong>${byOrigin.size}</strong> unique origin(s)</div>`;

            let idx = 0;
            for (const [key, data] of byOrigin) {
                idx++;
                const origin = data.origin;
                html += `<div class="arg-box"><div class="arg-box-title"><span>Origin #${idx}: ${origin.func}()</span><span class="arg-box-badge">${origin.type}</span></div>`;
                html += `<div class="arg-step origin"><div class="arg-step-func">üìç ${origin.func}()</div><div class="arg-step-file">${origin.file}</div><div class="arg-step-detail">Value: <code>${this.esc(origin.value)}</code>${origin.variable ? ` (var: <code>${origin.variable}</code>)` : ''}</div></div>`;

                const firstTrace = data.traces[0];
                if (firstTrace.trace.steps.length > 0) {
                    html += `<div style="margin:8px 0 4px;color:var(--text-muted);font-size:0.75rem;">Call chain:</div>`;
                    for (let i = firstTrace.trace.steps.length - 1; i >= 0; i--) {
                        const step = firstTrace.trace.steps[i];
                        html += `<div class="arg-step"><div class="arg-step-func">${step.func}()</div><div class="arg-step-file">${step.file}:${step.line}</div><div class="arg-step-detail">Passes <code>${this.esc(step.argValue)}</code> as arg #${step.argPos} ‚Üí ${step.callsFunc}()</div></div>`;
                    }
                }
                html += `<div style="margin-top:6px;font-size:0.7rem;color:var(--text-muted);">Paths: ${data.traces.map(t => '#' + t.pathIndex).join(', ')}</div></div>`;
            }
        }

        if (noOrigin.length > 0) {
            html += `<div class="warning">‚ö†Ô∏è ${noOrigin.length} path(s) could not be traced</div>`;
        }

        this.output.innerHTML = html;
    }

    renderFunctions() {
        if (!this.parser) return;
        let html = `<strong>Functions: ${this.parser.functions.size}</strong>\n\n`;
        for (const [name, func] of this.parser.functions) {
            const callTypes = [];
            for (const [callee, info] of func.calls) {
                if (info.type === 'func-arg') {
                    callTypes.push(`<span style="color:var(--teal)">${callee}[arg]</span>`);
                } else if (info.type === 'macro-arg') {
                    callTypes.push(`<span style="color:var(--pink)">${callee}[M-arg]</span>`);
                } else {
                    callTypes.push(callee);
                }
            }
            html += `<span class="func-inter">${name}</span> <span class="file-ref">[${func.file}]</span> ‚Üí ${callTypes.join(', ') || 'no calls'}\n`;
        }
        if (this.parser.macros.size > 0) {
            html += `\n<strong>Macros: ${this.parser.macros.size}</strong>\n\n`;
            for (const [name, macro] of this.parser.macros) {
                const info = [];
                if (macro.calls.length > 0) info.push(`calls: ${macro.calls.join(', ')}`);
                if (macro.funcArgs && macro.funcArgs.length > 0) {
                    info.push(`<span style="color:var(--teal)">func-args: ${macro.funcArgs.map(f => f.func).join(', ')}</span>`);
                }
                if (info.length > 0) {
                    html += `<span class="func-macro">${name}</span> ‚Üí ${info.join(' | ')}\n`;
                }
            }
        }
        this.output.innerHTML = html;
    }

    renderLog() {
        if (!this.parser) return;
        let html = '<strong>Parser Log:</strong>\n';
        for (const entry of this.parser.log) {
            let color = 'var(--text)';
            if (entry.type === 'error') color = 'var(--red)';
            else if (entry.type === 'macro') color = 'var(--pink)';
            else if (entry.type === 'macro-arg-use') color = 'var(--pink)';
            else if (entry.type === 'info') color = 'var(--cyan)';
            else if (entry.type === 'func-arg') color = 'var(--teal)';
            else if (entry.type === 'func-arg-final') color = 'var(--teal)';
            html += `<span style="color:${color}">[${entry.type.toUpperCase()}]</span> ${entry.msg}\n`;
        }
        if (this.argTracker && this.argTracker.log.length > 0) {
            html += '\n<strong>Argument Tracker Log:</strong>\n';
            for (const msg of this.argTracker.log) {
                html += `<span style="color:var(--yellow)">[ARG]</span> ${msg}\n`;
            }
        }
        this.output.innerHTML = html || '<span style="color:var(--text-muted)">No log entries</span>';
    }

    esc(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = String(text);
        return div.innerHTML;
    }

    clear() {
        this.files.clear();
        this.parser = null;
        this.argTracker = null;
        this.results = null;
        this.argResults = null;
        this.updateFileList();
        this.statsCard.style.display = 'none';
        this.output.innerHTML = `<div style="color:var(--text-muted);text-align:center;padding:50px;">Upload C files and click Analyze to trace call paths</div>`;
    }
}

document.addEventListener('DOMContentLoaded', () => new UI());
</script>
</body>
</html>
