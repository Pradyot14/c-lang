<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enterprise C Call Tracer - Complete Analysis Suite</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Space+Grotesk:wght@400;500;600;700&family=IBM+Plex+Sans:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-tertiary: #1a1a25;
            --bg-card: rgba(20, 20, 30, 0.8);
            --border-color: rgba(100, 200, 255, 0.15);
            --text-primary: #e8e8f0;
            --text-secondary: #a0a0b0;
            --text-muted: #606070;
            --accent-cyan: #00d4ff;
            --accent-purple: #a855f7;
            --accent-pink: #ec4899;
            --accent-green: #10b981;
            --accent-orange: #f59e0b;
            --accent-red: #ef4444;
            --accent-blue: #3b82f6;
            --accent-yellow: #eab308;
            --glow-cyan: 0 0 20px rgba(0, 212, 255, 0.3);
            --glow-purple: 0 0 20px rgba(168, 85, 247, 0.3);
            --glow-green: 0 0 20px rgba(16, 185, 129, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'IBM Plex Sans', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .bg-grid {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                linear-gradient(rgba(0, 212, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 212, 255, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            pointer-events: none;
            z-index: 0;
        }

        .container {
            position: relative;
            z-index: 1;
            max-width: 1900px;
            margin: 0 auto;
            padding: 15px;
        }

        header {
            text-align: center;
            padding: 20px 0;
            margin-bottom: 20px;
        }

        h1 {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 2.2rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple), var(--accent-pink));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 0.95rem;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 380px 1fr;
            gap: 20px;
            min-height: calc(100vh - 160px);
        }

        .card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .card-title {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            color: var(--accent-cyan);
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card-title::before {
            content: '';
            width: 4px;
            height: 18px;
            background: linear-gradient(180deg, var(--accent-cyan), var(--accent-purple));
            border-radius: 2px;
        }

        /* Sidebar sections */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* Phase indicators */
        .phase-indicator {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }

        .phase {
            flex: 1;
            text-align: center;
            padding: 10px 5px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            font-size: 0.7rem;
            color: var(--text-muted);
            border: 1px solid transparent;
            transition: all 0.3s;
        }

        .phase.active {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
            background: rgba(0, 212, 255, 0.1);
        }

        .phase.completed {
            border-color: var(--accent-green);
            color: var(--accent-green);
            background: rgba(16, 185, 129, 0.1);
        }

        .phase-num {
            display: block;
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 3px;
        }

        /* Upload zones */
        .upload-section {
            margin-bottom: 15px;
        }

        .upload-label {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .upload-count {
            background: var(--bg-tertiary);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.75rem;
            color: var(--accent-cyan);
        }

        .upload-zone {
            border: 2px dashed var(--border-color);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-zone:hover, .upload-zone.drag-over {
            border-color: var(--accent-cyan);
            background: rgba(0, 212, 255, 0.05);
        }

        .upload-zone.has-files {
            border-color: var(--accent-green);
            border-style: solid;
        }

        .upload-zone svg {
            width: 32px;
            height: 32px;
            stroke: var(--accent-cyan);
            margin-bottom: 10px;
        }

        .upload-zone p {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        .upload-zone .formats {
            margin-top: 8px;
            display: flex;
            justify-content: center;
            gap: 6px;
            flex-wrap: wrap;
        }

        .format-badge {
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid rgba(0, 212, 255, 0.3);
            padding: 3px 8px;
            border-radius: 15px;
            font-size: 0.7rem;
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent-cyan);
        }

        /* File chips */
        .file-list {
            max-height: 120px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .file-chip {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 6px 10px;
            margin-bottom: 5px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
        }

        .file-chip .file-info {
            display: flex;
            align-items: center;
            gap: 8px;
            overflow: hidden;
        }

        .file-chip .file-name {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .file-chip .file-type {
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.65rem;
            font-weight: 600;
            flex-shrink: 0;
        }

        .file-type.source { background: rgba(16, 185, 129, 0.2); color: var(--accent-green); }
        .file-type.header { background: rgba(168, 85, 247, 0.2); color: var(--accent-purple); }
        .file-type.makefile { background: rgba(245, 158, 11, 0.2); color: var(--accent-orange); }
        .file-type.registry { background: rgba(236, 72, 153, 0.2); color: var(--accent-pink); }

        .file-chip .remove-btn {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 4px;
            transition: all 0.2s;
            flex-shrink: 0;
        }

        .file-chip .remove-btn:hover {
            color: var(--accent-red);
            background: rgba(239, 68, 68, 0.1);
        }

        /* Form inputs */
        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 12px;
        }

        .form-group {
            margin-bottom: 12px;
        }

        .form-group label {
            display: block;
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 6px;
        }

        .form-group input, .form-group select {
            width: 100%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 10px 12px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: var(--accent-cyan);
            box-shadow: var(--glow-cyan);
        }

        /* Checkbox options */
        .options-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }

        .option-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            cursor: pointer;
        }

        .option-item input[type="checkbox"] {
            width: 14px;
            height: 14px;
            accent-color: var(--accent-cyan);
            cursor: pointer;
        }

        /* Buttons */
        .btn-group {
            display: flex;
            gap: 10px;
        }

        .btn {
            flex: 1;
            border: none;
            border-radius: 8px;
            padding: 12px 16px;
            font-family: 'Space Grotesk', sans-serif;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: var(--glow-cyan);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
        }

        .btn-secondary:hover:not(:disabled) {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn svg {
            width: 18px;
            height: 18px;
        }

        /* Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 15px;
        }

        .stat-item {
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
        }

        .stat-value {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--accent-cyan);
        }

        .stat-label {
            font-size: 0.65rem;
            color: var(--text-muted);
            margin-top: 2px;
        }

        /* Results area */
        .results-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .tabs {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .tab-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 8px 16px;
            color: var(--text-secondary);
            font-family: 'Space Grotesk', sans-serif;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tab-btn:hover {
            border-color: var(--accent-cyan);
            color: var(--text-primary);
        }

        .tab-btn.active {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.2), rgba(168, 85, 247, 0.2));
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        /* Legend */
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }

        /* Tree container */
        .tree-container {
            flex: 1;
            min-height: 450px;
            background: var(--bg-secondary);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .tree-svg {
            width: 100%;
            height: 100%;
        }

        .tree-controls {
            position: absolute;
            top: 12px;
            right: 12px;
            display: flex;
            gap: 6px;
            z-index: 10;
        }

        .tree-controls button {
            width: 32px;
            height: 32px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 1rem;
        }

        .tree-controls button:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        /* Text outputs */
        .text-output {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 16px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            line-height: 1.6;
            overflow: auto;
            max-height: 400px;
            white-space: pre;
        }

        .text-output .func-main { color: var(--accent-cyan); }
        .text-output .func-target { color: var(--accent-green); font-weight: bold; }
        .text-output .func-intermediate { color: var(--accent-purple); }
        .text-output .func-external { color: var(--accent-orange); }
        .text-output .func-macro { color: var(--accent-pink); }
        .text-output .func-pointer { color: var(--accent-blue); }
        .text-output .func-registry { color: var(--accent-yellow); }
        .text-output .file-ref { color: var(--text-muted); }
        .text-output .call-type { color: var(--text-muted); font-style: italic; }

        /* Dependency tree */
        .dep-tree {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 16px;
            max-height: 400px;
            overflow: auto;
        }

        .dep-file {
            margin-bottom: 12px;
        }

        .dep-file-header {
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--accent-green);
            margin-bottom: 6px;
        }

        .dep-includes {
            padding-left: 20px;
            border-left: 2px solid var(--border-color);
        }

        .dep-include {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--accent-purple);
            padding: 3px 0;
        }

        .dep-include .path {
            color: var(--text-muted);
            margin-left: 8px;
        }

        .dep-include.unresolved {
            color: var(--accent-orange);
        }

        /* Registry view */
        .registry-list {
            max-height: 400px;
            overflow: auto;
        }

        .registry-item {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
        }

        .registry-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .registry-func-name {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            color: var(--accent-yellow);
            font-weight: 600;
        }

        .registry-badge {
            background: rgba(234, 179, 8, 0.2);
            color: var(--accent-yellow);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
        }

        .registry-proto {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-secondary);
            background: var(--bg-secondary);
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 8px;
            overflow-x: auto;
        }

        .registry-meta {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
            font-size: 0.7rem;
        }

        .registry-meta-item {
            color: var(--text-muted);
        }

        .registry-meta-item strong {
            color: var(--text-secondary);
        }

        /* Log entries */
        .log-entry {
            display: flex;
            gap: 8px;
            margin-bottom: 6px;
            font-size: 0.8rem;
            align-items: flex-start;
        }

        .log-entry .log-type {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 4px;
            min-width: 55px;
            text-align: center;
            flex-shrink: 0;
        }

        .log-type.info { background: rgba(59, 130, 246, 0.2); color: var(--accent-blue); }
        .log-type.success { background: rgba(16, 185, 129, 0.2); color: var(--accent-green); }
        .log-type.warning { background: rgba(245, 158, 11, 0.2); color: var(--accent-orange); }
        .log-type.error { background: rgba(239, 68, 68, 0.2); color: var(--accent-red); }
        .log-type.macro { background: rgba(236, 72, 153, 0.2); color: var(--accent-pink); }
        .log-type.pointer { background: rgba(168, 85, 247, 0.2); color: var(--accent-purple); }
        .log-type.dep { background: rgba(0, 212, 255, 0.2); color: var(--accent-cyan); }
        .log-type.registry { background: rgba(234, 179, 8, 0.2); color: var(--accent-yellow); }

        .log-entry .log-msg {
            color: var(--text-secondary);
            word-break: break-word;
        }

        .log-entry .log-msg code {
            background: var(--bg-tertiary);
            padding: 1px 5px;
            border-radius: 3px;
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent-cyan);
            font-size: 0.75rem;
        }

        /* Paths summary */
        .paths-list {
            max-height: 400px;
            overflow: auto;
        }

        .path-item {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
        }

        .path-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .path-number {
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
            padding: 3px 10px;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .path-meta {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .path-chain {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            color: var(--text-secondary);
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 6px;
        }

        .path-chain .arrow {
            color: var(--accent-cyan);
        }

        .path-chain .func {
            padding: 2px 6px;
            border-radius: 4px;
            background: var(--bg-secondary);
        }

        .path-chain .func.macro-call {
            border: 1px dashed var(--accent-pink);
        }

        .path-chain .func.pointer-call {
            border: 1px dashed var(--accent-blue);
        }

        .path-chain .func.registry-call {
            border: 1px dashed var(--accent-yellow);
        }

        .path-chain .func.target {
            background: rgba(16, 185, 129, 0.2);
            color: var(--accent-green);
        }

        /* Loading */
        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 250px;
            gap: 15px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--bg-tertiary);
            border-top-color: var(--accent-cyan);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading p {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        /* Error */
        .error-msg {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
        }

        .error-msg h3 {
            color: var(--accent-red);
            margin-bottom: 10px;
        }

        .error-msg p {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-cyan);
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
            .sidebar {
                max-height: none;
            }
        }
    </style>
</head>
<body>
    <div class="bg-grid"></div>
    
    <div class="container">
        <header>
            <h1>üî¨ Enterprise C Call Tracer</h1>
            <p class="subtitle">Makefile Parsing ‚Ä¢ Dependency Resolution ‚Ä¢ Function Registry ‚Ä¢ Complete Call Analysis</p>
        </header>

        <div class="main-layout">
            <!-- Sidebar -->
            <div class="sidebar">
                <!-- Phase Indicator -->
                <div class="card">
                    <div class="phase-indicator">
                        <div class="phase" id="phase1">
                            <span class="phase-num">1</span>
                            Dependencies
                        </div>
                        <div class="phase" id="phase2">
                            <span class="phase-num">2</span>
                            Registry
                        </div>
                        <div class="phase" id="phase3">
                            <span class="phase-num">3</span>
                            Analysis
                        </div>
                        <div class="phase" id="phase4">
                            <span class="phase-num">4</span>
                            Trace
                        </div>
                    </div>

                    <!-- Upload Sections -->
                    <div class="upload-section">
                        <div class="upload-label">
                            <span>üìÅ Project Files (.c, .h, Makefile)</span>
                            <span class="upload-count" id="projectCount">0 files</span>
                        </div>
                        <div class="upload-zone" id="projectUpload">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12"/>
                            </svg>
                            <p>Drop project files here</p>
                            <div class="formats">
                                <span class="format-badge">.c</span>
                                <span class="format-badge">.h</span>
                                <span class="format-badge">Makefile</span>
                            </div>
                            <input type="file" id="projectInput" multiple accept=".c,.h,.cpp,.hpp,.cc,.hh,Makefile,.mk" hidden>
                        </div>
                        <div class="file-list" id="projectFileList"></div>
                    </div>

                    <div class="upload-section">
                        <div class="upload-label">
                            <span>üìã Function Registry (optional)</span>
                            <span class="upload-count" id="registryCount">0 files</span>
                        </div>
                        <div class="upload-zone" id="registryUpload">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                                <polyline points="14 2 14 8 20 8"/>
                                <line x1="16" y1="13" x2="8" y2="13"/>
                                <line x1="16" y1="17" x2="8" y2="17"/>
                            </svg>
                            <p>Function metadata JSON</p>
                            <div class="formats">
                                <span class="format-badge">.json</span>
                            </div>
                            <input type="file" id="registryInput" accept=".json" hidden>
                        </div>
                        <div class="file-list" id="registryFileList"></div>
                    </div>
                </div>

                <!-- Configuration -->
                <div class="card">
                    <h2 class="card-title">Configuration</h2>
                    
                    <div class="form-row">
                        <div class="form-group">
                            <label>Entry Function</label>
                            <input type="text" id="entryFunc" value="main" placeholder="main">
                        </div>
                        <div class="form-group">
                            <label>Target Function</label>
                            <input type="text" id="targetFunc" value="mpf_mfs_open" placeholder="mpf_mfs_open">
                        </div>
                    </div>

                    <div class="form-group">
                        <label>Include Paths (comma-separated)</label>
                        <input type="text" id="includePaths" placeholder="./include, ./src, ./lib">
                    </div>

                    <div class="options-grid">
                        <label class="option-item">
                            <input type="checkbox" id="optMakefile" checked>
                            <span>Parse Makefile</span>
                        </label>
                        <label class="option-item">
                            <input type="checkbox" id="optRecursive" checked>
                            <span>Recursive headers</span>
                        </label>
                        <label class="option-item">
                            <input type="checkbox" id="optMacros" checked>
                            <span>Expand macros</span>
                        </label>
                        <label class="option-item">
                            <input type="checkbox" id="optPointers" checked>
                            <span>Track func pointers</span>
                        </label>
                        <label class="option-item">
                            <input type="checkbox" id="optRegistry" checked>
                            <span>Use registry</span>
                        </label>
                        <label class="option-item">
                            <input type="checkbox" id="optAllPaths" checked>
                            <span>Show all paths</span>
                        </label>
                    </div>

                    <div class="btn-group">
                        <button class="btn btn-secondary" id="clearBtn">Clear All</button>
                        <button class="btn btn-primary" id="analyzeBtn" disabled>
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="11" cy="11" r="8"/>
                                <path d="m21 21-4.35-4.35"/>
                            </svg>
                            Analyze
                        </button>
                    </div>
                </div>

                <!-- Stats -->
                <div class="card" id="statsCard" style="display: none;">
                    <h2 class="card-title">Analysis Results</h2>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-value" id="statFiles">0</div>
                            <div class="stat-label">Files</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="statFuncs">0</div>
                            <div class="stat-label">Functions</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="statHeaders">0</div>
                            <div class="stat-label">Headers</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="statMacros">0</div>
                            <div class="stat-label">Macros</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="statPaths">0</div>
                            <div class="stat-label">Paths</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="statDepth">0</div>
                            <div class="stat-label">Max Depth</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Results Panel -->
            <div class="results-panel">
                <div class="card" style="flex: 1; display: flex; flex-direction: column;">
                    <div class="tabs">
                        <button class="tab-btn active" data-tab="visual">Visual Tree</button>
                        <button class="tab-btn" data-tab="text">Text Tree</button>
                        <button class="tab-btn" data-tab="paths">All Paths</button>
                        <button class="tab-btn" data-tab="deps">Dependencies</button>
                        <button class="tab-btn" data-tab="registry">Registry</button>
                        <button class="tab-btn" data-tab="log">Analysis Log</button>
                    </div>

                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: var(--accent-cyan);"></div>
                            <span>Entry</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: var(--accent-green);"></div>
                            <span>Target</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: var(--accent-purple);"></div>
                            <span>Intermediate</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: var(--accent-pink);"></div>
                            <span>Macro</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: var(--accent-blue);"></div>
                            <span>Pointer</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: var(--accent-yellow);"></div>
                            <span>Registry Func</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: var(--accent-orange);"></div>
                            <span>External</span>
                        </div>
                    </div>

                    <div id="tabContent" style="flex: 1; display: flex; flex-direction: column; min-height: 0;">
                        <div class="tree-container" id="visualTab">
                            <div class="tree-controls">
                                <button id="zoomIn" title="Zoom In">+</button>
                                <button id="zoomOut" title="Zoom Out">‚àí</button>
                                <button id="resetView" title="Reset View">‚ü≤</button>
                                <button id="exportSvg" title="Export SVG">‚§ì</button>
                            </div>
                            <svg class="tree-svg" id="treeSvg"></svg>
                        </div>
                        <div class="text-output" id="textTab" style="display: none;"></div>
                        <div class="paths-list" id="pathsTab" style="display: none;"></div>
                        <div class="dep-tree" id="depsTab" style="display: none;"></div>
                        <div class="registry-list" id="registryTab" style="display: none;"></div>
                        <div class="text-output" id="logTab" style="display: none; white-space: normal;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
    // ============================================
    // PHASE 1: DEPENDENCY RESOLVER
    // ============================================
    class DependencyResolver {
        constructor() {
            this.files = new Map();           // filename -> content
            this.headerPaths = new Map();     // header name -> resolved path
            this.fileDependencies = new Map(); // file -> Set of headers
            this.srcsFromMakefile = [];       // SRCS extracted from Makefile
            this.includePaths = [];           // Include search paths
            this.log = [];
        }

        addLog(type, msg) {
            this.log.push({ type, message: msg });
        }

        setIncludePaths(paths) {
            this.includePaths = paths.filter(p => p.trim());
        }

        // Parse Makefile to extract SRCS
        parseMakefile(content) {
            this.addLog('dep', 'Parsing Makefile for SRCS...');
            
            // Handle line continuations
            const normalized = content.replace(/\\\s*\n/g, ' ');
            
            // Multiple patterns for SRCS
            const patterns = [
                /SRCS\s*[:+]?=\s*([^\n]+)/gi,
                /SRC\s*[:+]?=\s*([^\n]+)/gi,
                /SOURCES\s*[:+]?=\s*([^\n]+)/gi,
                /C_SRCS\s*[:+]?=\s*([^\n]+)/gi,
                /SOURCE_FILES\s*[:+]?=\s*([^\n]+)/gi,
            ];

            const sources = new Set();
            
            for (const pattern of patterns) {
                let match;
                while ((match = pattern.exec(normalized)) !== null) {
                    const filesStr = match[1];
                    // Extract .c files
                    const fileMatches = filesStr.match(/[\w\/\-\.]+\.c/gi);
                    if (fileMatches) {
                        fileMatches.forEach(f => sources.add(f.trim()));
                    }
                }
            }

            // Also extract from $(wildcard ...) patterns
            const wildcardPattern = /\$\(wildcard\s+([^)]+)\)/gi;
            let wildcardMatch;
            while ((wildcardMatch = wildcardPattern.exec(normalized)) !== null) {
                const pattern = wildcardMatch[1];
                // For now, just note the pattern
                this.addLog('info', `Found wildcard pattern: ${pattern}`);
            }

            this.srcsFromMakefile = [...sources];
            this.addLog('success', `Found ${this.srcsFromMakefile.length} source files in Makefile`);
            
            return this.srcsFromMakefile;
        }

        // Extract #include directives from a file
        extractIncludes(content) {
            const includes = [];
            const patterns = [
                /#include\s*"([^"]+)"/g,      // #include "header.h"
                /#include\s*<([^>]+)>/g,       // #include <header.h>
            ];

            for (const pattern of patterns) {
                let match;
                while ((match = pattern.exec(content)) !== null) {
                    includes.push({
                        name: match[1],
                        isLocal: pattern.source.includes('"')
                    });
                }
            }

            return includes;
        }

        // Resolve header path
        resolveHeaderPath(headerName, fromFile = null) {
            // Already resolved?
            if (this.headerPaths.has(headerName)) {
                return this.headerPaths.get(headerName);
            }

            // Check in uploaded files
            for (const [filename, content] of this.files) {
                const baseName = filename.split('/').pop();
                if (baseName === headerName || filename.endsWith('/' + headerName) || filename === headerName) {
                    this.headerPaths.set(headerName, filename);
                    return filename;
                }
            }

            // Check include paths
            for (const incPath of this.includePaths) {
                const possiblePath = incPath + '/' + headerName;
                if (this.files.has(possiblePath)) {
                    this.headerPaths.set(headerName, possiblePath);
                    return possiblePath;
                }
            }

            // Not found
            return null;
        }

        // Recursively resolve all dependencies
        resolveAllDependencies() {
            this.addLog('dep', 'Starting recursive dependency resolution...');
            
            const processed = new Set();
            const queue = [];

            // Start with all .c files
            for (const [filename, content] of this.files) {
                if (filename.endsWith('.c') || filename.endsWith('.cpp')) {
                    queue.push(filename);
                }
            }

            while (queue.length > 0) {
                const currentFile = queue.shift();
                
                if (processed.has(currentFile)) continue;
                processed.add(currentFile);

                const content = this.files.get(currentFile);
                if (!content) continue;

                const includes = this.extractIncludes(content);
                const deps = new Set();

                for (const inc of includes) {
                    const resolvedPath = this.resolveHeaderPath(inc.name, currentFile);
                    
                    if (resolvedPath) {
                        deps.add(resolvedPath);
                        
                        // Add to queue for recursive processing
                        if (!processed.has(resolvedPath)) {
                            queue.push(resolvedPath);
                        }
                    } else {
                        // Mark as unresolved
                        deps.add(`[UNRESOLVED] ${inc.name}`);
                    }
                }

                this.fileDependencies.set(currentFile, deps);
            }

            this.addLog('success', `Resolved dependencies for ${processed.size} files`);
            this.addLog('info', `Header path dictionary contains ${this.headerPaths.size} entries`);
        }

        // Get header-to-path dictionary (output of Phase 1)
        getHeaderPathDictionary() {
            return Object.fromEntries(this.headerPaths);
        }
    }

    // ============================================
    // PHASE 2: FUNCTION REGISTRY
    // ============================================
    class FunctionRegistry {
        constructor() {
            this.functions = new Map();  // function_name -> function_info
            this.log = [];
        }

        addLog(type, msg) {
            this.log.push({ type, message: msg });
        }

        // Load from JSON
        loadFromJSON(jsonContent) {
            try {
                const data = JSON.parse(jsonContent);
                
                if (Array.isArray(data)) {
                    // Array of function definitions
                    for (const func of data) {
                        if (func.name || func.function_name) {
                            const name = func.name || func.function_name;
                            this.functions.set(name, this.normalizeFunction(func));
                        }
                    }
                } else if (typeof data === 'object') {
                    // Object with function names as keys
                    for (const [name, info] of Object.entries(data)) {
                        this.functions.set(name, this.normalizeFunction({ name, ...info }));
                    }
                }

                this.addLog('registry', `Loaded ${this.functions.size} functions from registry`);
            } catch (e) {
                this.addLog('error', `Failed to parse registry JSON: ${e.message}`);
            }
        }

        // Normalize function info to standard format
        normalizeFunction(func) {
            return {
                name: func.name || func.function_name || 'unknown',
                prototype: func.prototype || func.signature || func.declaration || '',
                returnType: func.returnType || func.return_type || func.returns || 'void',
                arguments: this.normalizeArguments(func.arguments || func.args || func.parameters || []),
                callbacks: func.callbacks || func.callback_refs || [],
                description: func.description || func.desc || '',
                file: func.file || func.source || '',
                metadata: func.metadata || {}
            };
        }

        normalizeArguments(args) {
            if (Array.isArray(args)) {
                return args.map(arg => {
                    if (typeof arg === 'string') {
                        return { name: arg, type: 'unknown', description: '' };
                    }
                    return {
                        name: arg.name || arg.arg_name || '',
                        type: arg.type || arg.arg_type || 'unknown',
                        description: arg.description || arg.desc || ''
                    };
                });
            }
            return [];
        }

        // Check if function is in registry
        has(funcName) {
            return this.functions.has(funcName);
        }

        // Get function info
        get(funcName) {
            return this.functions.get(funcName);
        }

        // Get all callback references for a function
        getCallbacks(funcName) {
            const func = this.functions.get(funcName);
            return func ? func.callbacks : [];
        }
    }

    // ============================================
    // PHASE 3 & 4: ADVANCED CODE ANALYZER
    // ============================================
    class AdvancedCodeAnalyzer {
        constructor(dependencyResolver, functionRegistry) {
            this.depResolver = dependencyResolver;
            this.registry = functionRegistry;
            this.functions = new Map();
            this.macros = new Map();
            this.typedefs = new Map();
            this.funcPointers = new Map();
            this.callGraph = new Map();
            this.reverseGraph = new Map();
            this.log = [];
            this.stats = {
                files: 0,
                functions: 0,
                headers: 0,
                macros: 0,
                paths: 0,
                maxDepth: 0
            };
        }

        addLog(type, msg) {
            this.log.push({ type, message: msg });
        }

        // Remove comments
        removeComments(code) {
            return code
                .replace(/\/\/.*$/gm, '')
                .replace(/\/\*[\s\S]*?\*\//g, '');
        }

        // Remove string literals
        removeStrings(code) {
            return code
                .replace(/"(?:[^"\\]|\\.)*"/g, '""')
                .replace(/'(?:[^'\\]|\\.)*'/g, "''");
        }

        // Parse macros with full support
        parseMacros(code, filename) {
            // Function-like macros
            const funcMacroRegex = /^[ \t]*#[ \t]*define[ \t]+(\w+)\s*\(([^)]*)\)\s*(.+?)$/gm;
            let match;
            
            while ((match = funcMacroRegex.exec(code)) !== null) {
                const [, name, params, body] = match;
                const cleanBody = body.replace(/\\\s*\n/g, ' ').trim();
                const calls = this.extractCalls(cleanBody);
                
                this.macros.set(name, {
                    name,
                    params: params.split(',').map(p => p.trim()).filter(p => p),
                    body: cleanBody,
                    calls,
                    file: filename,
                    isFunctionLike: true
                });

                if (calls.length > 0) {
                    this.addLog('macro', `Macro <code>${name}</code> expands to: ${calls.join(', ')}`);
                }
            }

            // Object-like macros
            const objMacroRegex = /^[ \t]*#[ \t]*define[ \t]+(\w+)[ \t]+([^(\n][^\n]*)$/gm;
            while ((match = objMacroRegex.exec(code)) !== null) {
                const [, name, body] = match;
                if (!this.macros.has(name)) {
                    const cleanBody = body.replace(/\\\s*\n/g, ' ').trim();
                    const calls = this.extractCalls(cleanBody);
                    
                    this.macros.set(name, {
                        name,
                        params: [],
                        body: cleanBody,
                        calls,
                        file: filename,
                        isFunctionLike: false
                    });
                }
            }
        }

        // Parse function pointer typedefs
        parseTypedefs(code, filename) {
            const patterns = [
                /typedef\s+[\w\s\*]+\s*\(\s*\*\s*(\w+)\s*\)\s*\([^)]*\)/g,
                /typedef\s+(\w+)\s+\(\s*\*\s*(\w+)\s*\)/g
            ];

            for (const pattern of patterns) {
                let match;
                while ((match = pattern.exec(code)) !== null) {
                    const name = match[1] || match[2];
                    this.typedefs.set(name, { name, file: filename, isFunction: true });
                    this.addLog('pointer', `Found function pointer typedef: <code>${name}</code>`);
                }
            }
        }

        // Parse function pointer assignments
        parseFuncPointerAssignments(code, filename) {
            const patterns = [
                // Direct: void (*cb)(int) = func;
                /[\w\s\*]+\s*\(\s*\*\s*(\w+)\s*\)\s*\([^)]*\)\s*=\s*&?(\w+)/g,
                // Assignment: cb = func;
                /(\w+)\s*=\s*&?(\w+)\s*;/g,
                // Struct member: .cb = func
                /\.(\w+)\s*=\s*&?(\w+)/g,
                // Array: handlers[0] = func
                /(\w+)\s*\[[^\]]*\]\s*=\s*&?(\w+)/g
            ];

            for (const pattern of patterns) {
                let match;
                while ((match = pattern.exec(code)) !== null) {
                    const [, varName, funcName] = match;
                    if (this.isLikelyFunction(funcName)) {
                        if (!this.funcPointers.has(varName)) {
                            this.funcPointers.set(varName, new Set());
                        }
                        this.funcPointers.get(varName).add(funcName);
                    }
                }
            }
        }

        // Check if name looks like a function
        isLikelyFunction(name) {
            const keywords = new Set([
                'if', 'else', 'while', 'for', 'do', 'switch', 'case', 'break',
                'continue', 'return', 'goto', 'sizeof', 'typeof', 'NULL', 'null',
                'true', 'false', 'void', 'int', 'char', 'float', 'double', 'long',
                'short', 'unsigned', 'signed', 'const', 'static', 'extern'
            ]);
            
            if (keywords.has(name)) return false;
            if (/^\d/.test(name)) return false;
            if (name.length < 2) return false;
            return true;
        }

        // Extract function calls from code
        extractCalls(code) {
            const calls = [];
            const regex = /\b([a-zA-Z_]\w*)\s*\(/g;
            let match;
            
            while ((match = regex.exec(code)) !== null) {
                if (this.isLikelyFunction(match[1])) {
                    calls.push(match[1]);
                }
            }
            return [...new Set(calls)];
        }

        // Find matching brace
        findMatchingBrace(code, start) {
            let depth = 1, i = start;
            while (i < code.length && depth > 0) {
                if (code[i] === '{') depth++;
                else if (code[i] === '}') depth--;
                i++;
            }
            return depth === 0 ? i : -1;
        }

        // Parse function definitions
        parseFunctions(code, filename) {
            const cleanCode = this.removeStrings(this.removeComments(code));
            
            const funcPattern = /(?:^|[\n;{}])\s*((?:static|inline|extern|__attribute__\s*\([^)]*\)|const|volatile|unsigned|signed|long|short|struct\s+\w+|enum\s+\w+|\w+)\s*[\*\s]*)*\s*\b([a-zA-Z_]\w*)\s*\(([^)]*)\)\s*\{/g;
            
            let match;
            while ((match = funcPattern.exec(cleanCode)) !== null) {
                const modifiers = match[1] || '';
                const name = match[2];
                const params = match[3];
                
                if (!this.isLikelyFunction(name)) continue;
                
                const bodyStart = match.index + match[0].length - 1;
                const bodyEnd = this.findMatchingBrace(cleanCode, bodyStart + 1);
                if (bodyEnd === -1) continue;
                
                const body = cleanCode.substring(bodyStart, bodyEnd);
                const lineNum = (code.substring(0, match.index).match(/\n/g) || []).length + 1;
                
                // Extract calls with type info
                const directCalls = this.extractCalls(body);
                const callDetails = [];
                
                for (const call of directCalls) {
                    // Check macro expansion
                    if (this.macros.has(call)) {
                        const macro = this.macros.get(call);
                        for (const macroCall of macro.calls) {
                            callDetails.push({ name: macroCall, type: 'macro', via: call });
                        }
                        callDetails.push({ name: call, type: 'macro-invoke' });
                    }
                    // Check registry for callbacks
                    else if (this.registry.has(call)) {
                        callDetails.push({ name: call, type: 'registry' });
                        const callbacks = this.registry.getCallbacks(call);
                        for (const cb of callbacks) {
                            callDetails.push({ name: cb, type: 'callback', via: call });
                        }
                    }
                    // Check function pointer
                    else if (this.funcPointers.has(call)) {
                        for (const target of this.funcPointers.get(call)) {
                            callDetails.push({ name: target, type: 'pointer', via: call });
                        }
                    }
                    // Direct call
                    else {
                        callDetails.push({ name: call, type: 'direct' });
                    }
                }

                // Check for indirect calls through pointers in body
                const ptrCallPatterns = [
                    /(\w+)->(\w+)\s*\(/g,  // obj->callback()
                    /(\w+)\.(\w+)\s*\(/g,   // obj.callback()
                ];
                
                for (const pattern of ptrCallPatterns) {
                    let ptrMatch;
                    while ((ptrMatch = pattern.exec(body)) !== null) {
                        const member = ptrMatch[2];
                        if (this.funcPointers.has(member)) {
                            for (const target of this.funcPointers.get(member)) {
                                callDetails.push({ name: target, type: 'callback', via: member });
                            }
                        }
                    }
                }

                this.functions.set(name, {
                    name,
                    file: filename,
                    line: lineNum,
                    modifiers: modifiers.trim(),
                    params,
                    callDetails,
                    isRegistry: this.registry.has(name)
                });
            }
        }

        // Parse a single file
        parseFile(filename, content) {
            this.addLog('info', `Parsing: <code>${filename}</code>`);
            
            // First: macros and typedefs
            this.parseMacros(content, filename);
            this.parseTypedefs(content, filename);
            this.parseFuncPointerAssignments(content, filename);
            
            // Second: functions
            this.parseFunctions(content, filename);
            
            this.stats.files++;
        }

        // Build call graph
        buildCallGraph() {
            for (const [funcName, func] of this.functions) {
                if (!this.callGraph.has(funcName)) {
                    this.callGraph.set(funcName, new Map());
                }

                for (const detail of func.callDetails) {
                    this.callGraph.get(funcName).set(detail.name, detail);

                    if (!this.reverseGraph.has(detail.name)) {
                        this.reverseGraph.set(detail.name, new Set());
                    }
                    this.reverseGraph.get(detail.name).add(funcName);
                }
            }
        }

        // Find all paths
        findAllPaths(entry, target, maxDepth = 50) {
            const allPaths = [];
            const visited = new Set();

            const dfs = (current, path, depth) => {
                if (depth > maxDepth) return;
                if (current === target) {
                    allPaths.push([...path]);
                    return;
                }
                if (visited.has(current)) return;

                visited.add(current);

                const calls = this.callGraph.get(current);
                if (calls) {
                    for (const [callee, detail] of calls) {
                        path.push({ name: callee, ...detail });
                        dfs(callee, path, depth + 1);
                        path.pop();
                    }
                }

                // Check macros
                if (this.macros.has(current)) {
                    for (const macroCall of this.macros.get(current).calls) {
                        path.push({ name: macroCall, type: 'macro-expansion', via: current });
                        dfs(macroCall, path, depth + 1);
                        path.pop();
                    }
                }

                visited.delete(current);
            };

            dfs(entry, [{ name: entry, type: 'entry' }], 0);

            this.stats.paths = allPaths.length;
            if (allPaths.length > 0) {
                this.stats.maxDepth = Math.max(...allPaths.map(p => p.length));
            }

            return allPaths;
        }

        // Build visualization tree
        buildTree(entry, target) {
            const paths = this.findAllPaths(entry, target);
            
            if (paths.length === 0) {
                this.addLog('warning', `No path found from <code>${entry}</code> to <code>${target}</code>`);
                return null;
            }

            this.addLog('success', `Found ${paths.length} path(s) to target`);

            const root = {
                name: entry,
                type: 'entry',
                file: this.functions.get(entry)?.file || 'unknown',
                children: [],
                callType: 'direct'
            };

            const addPath = (node, path, idx) => {
                if (idx >= path.length) return;
                const step = path[idx];
                let child = node.children.find(c => c.name === step.name);

                if (!child) {
                    const func = this.functions.get(step.name);
                    const isReg = this.registry.has(step.name);
                    child = {
                        name: step.name,
                        type: step.name === target ? 'target' : 
                              isReg ? 'registry' : 
                              (func ? 'intermediate' : 'external'),
                        file: func?.file || (isReg ? 'registry' : 'external'),
                        callType: step.type || 'direct',
                        via: step.via,
                        children: []
                    };
                    node.children.push(child);
                }

                addPath(child, path, idx + 1);
            };

            for (const path of paths) {
                addPath(root, path, 1);
            }

            return { tree: root, paths };
        }

        // Finalize
        finalize() {
            this.buildCallGraph();
            this.stats.functions = this.functions.size;
            this.stats.macros = this.macros.size;
            this.stats.headers = this.depResolver.headerPaths.size;
            
            this.addLog('success', `Analysis complete: ${this.stats.functions} functions, ${this.stats.macros} macros`);
        }
    }

    // ============================================
    // UI CONTROLLER
    // ============================================
    class UIController {
        constructor() {
            this.projectFiles = new Map();
            this.registryFiles = new Map();
            this.depResolver = null;
            this.funcRegistry = null;
            this.analyzer = null;
            this.treeData = null;
            this.transform = { x: 0, y: 0, scale: 1 };
            
            this.init();
        }

        init() {
            this.bindElements();
            this.bindEvents();
        }

        bindElements() {
            this.projectUpload = document.getElementById('projectUpload');
            this.projectInput = document.getElementById('projectInput');
            this.projectFileList = document.getElementById('projectFileList');
            this.projectCount = document.getElementById('projectCount');
            
            this.registryUpload = document.getElementById('registryUpload');
            this.registryInput = document.getElementById('registryInput');
            this.registryFileList = document.getElementById('registryFileList');
            this.registryCount = document.getElementById('registryCount');
            
            this.entryFunc = document.getElementById('entryFunc');
            this.targetFunc = document.getElementById('targetFunc');
            this.includePaths = document.getElementById('includePaths');
            
            this.analyzeBtn = document.getElementById('analyzeBtn');
            this.clearBtn = document.getElementById('clearBtn');
            this.statsCard = document.getElementById('statsCard');
            
            this.treeSvg = document.getElementById('treeSvg');
            this.textTab = document.getElementById('textTab');
            this.pathsTab = document.getElementById('pathsTab');
            this.depsTab = document.getElementById('depsTab');
            this.registryTab = document.getElementById('registryTab');
            this.logTab = document.getElementById('logTab');
            
            this.phases = [
                document.getElementById('phase1'),
                document.getElementById('phase2'),
                document.getElementById('phase3'),
                document.getElementById('phase4')
            ];
        }

        bindEvents() {
            // Project files upload
            this.projectUpload.addEventListener('click', () => this.projectInput.click());
            this.projectInput.addEventListener('change', e => this.handleProjectFiles(e.target.files));
            this.projectUpload.addEventListener('dragover', e => {
                e.preventDefault();
                this.projectUpload.classList.add('drag-over');
            });
            this.projectUpload.addEventListener('dragleave', () => {
                this.projectUpload.classList.remove('drag-over');
            });
            this.projectUpload.addEventListener('drop', e => {
                e.preventDefault();
                this.projectUpload.classList.remove('drag-over');
                this.handleProjectFiles(e.dataTransfer.files);
            });

            // Registry upload
            this.registryUpload.addEventListener('click', () => this.registryInput.click());
            this.registryInput.addEventListener('change', e => this.handleRegistryFiles(e.target.files));
            this.registryUpload.addEventListener('dragover', e => {
                e.preventDefault();
                this.registryUpload.classList.add('drag-over');
            });
            this.registryUpload.addEventListener('dragleave', () => {
                this.registryUpload.classList.remove('drag-over');
            });
            this.registryUpload.addEventListener('drop', e => {
                e.preventDefault();
                this.registryUpload.classList.remove('drag-over');
                this.handleRegistryFiles(e.dataTransfer.files);
            });

            // Buttons
            this.analyzeBtn.addEventListener('click', () => this.analyze());
            this.clearBtn.addEventListener('click', () => this.clearAll());

            // Tabs
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', () => this.switchTab(btn.dataset.tab));
            });

            // Tree controls
            document.getElementById('zoomIn').addEventListener('click', () => this.zoom(1.2));
            document.getElementById('zoomOut').addEventListener('click', () => this.zoom(0.8));
            document.getElementById('resetView').addEventListener('click', () => this.resetView());
            document.getElementById('exportSvg').addEventListener('click', () => this.exportSvg());

            // Pan/zoom
            this.treeSvg.addEventListener('wheel', e => {
                e.preventDefault();
                this.zoom(e.deltaY > 0 ? 0.9 : 1.1);
            });

            let isPanning = false, startX, startY;
            this.treeSvg.addEventListener('mousedown', e => {
                isPanning = true;
                startX = e.clientX - this.transform.x;
                startY = e.clientY - this.transform.y;
            });
            document.addEventListener('mousemove', e => {
                if (!isPanning) return;
                this.transform.x = e.clientX - startX;
                this.transform.y = e.clientY - startY;
                this.updateTransform();
            });
            document.addEventListener('mouseup', () => isPanning = false);
        }

        handleProjectFiles(files) {
            for (const file of files) {
                const ext = file.name.split('.').pop().toLowerCase();
                const base = file.name.toLowerCase();
                const valid = ['c', 'h', 'cpp', 'hpp', 'cc', 'hh', 'mk'];
                const isMake = base === 'makefile' || base.endsWith('.mk');
                
                if (valid.includes(ext) || isMake) {
                    const reader = new FileReader();
                    reader.onload = e => {
                        this.projectFiles.set(file.name, e.target.result);
                        this.updateProjectList();
                    };
                    reader.readAsText(file);
                }
            }
        }

        handleRegistryFiles(files) {
            for (const file of files) {
                if (file.name.endsWith('.json')) {
                    const reader = new FileReader();
                    reader.onload = e => {
                        this.registryFiles.set(file.name, e.target.result);
                        this.updateRegistryList();
                    };
                    reader.readAsText(file);
                }
            }
        }

        updateProjectList() {
            this.projectFileList.innerHTML = '';
            this.projectCount.textContent = `${this.projectFiles.size} files`;
            
            if (this.projectFiles.size > 0) {
                this.projectUpload.classList.add('has-files');
            } else {
                this.projectUpload.classList.remove('has-files');
            }

            for (const name of this.projectFiles.keys()) {
                const ext = name.split('.').pop().toLowerCase();
                const base = name.toLowerCase();
                let type = 'source';
                if (['h', 'hpp', 'hh'].includes(ext)) type = 'header';
                else if (base === 'makefile' || base.endsWith('.mk')) type = 'makefile';

                const chip = document.createElement('div');
                chip.className = 'file-chip';
                chip.innerHTML = `
                    <div class="file-info">
                        <span class="file-type ${type}">${type.slice(0,3).toUpperCase()}</span>
                        <span class="file-name">${name}</span>
                    </div>
                    <button class="remove-btn" data-file="${name}" data-type="project">√ó</button>
                `;
                this.projectFileList.appendChild(chip);
            }

            this.bindRemoveButtons();
            this.analyzeBtn.disabled = this.projectFiles.size === 0;
        }

        updateRegistryList() {
            this.registryFileList.innerHTML = '';
            this.registryCount.textContent = `${this.registryFiles.size} files`;

            if (this.registryFiles.size > 0) {
                this.registryUpload.classList.add('has-files');
            } else {
                this.registryUpload.classList.remove('has-files');
            }

            for (const name of this.registryFiles.keys()) {
                const chip = document.createElement('div');
                chip.className = 'file-chip';
                chip.innerHTML = `
                    <div class="file-info">
                        <span class="file-type registry">REG</span>
                        <span class="file-name">${name}</span>
                    </div>
                    <button class="remove-btn" data-file="${name}" data-type="registry">√ó</button>
                `;
                this.registryFileList.appendChild(chip);
            }

            this.bindRemoveButtons();
        }

        bindRemoveButtons() {
            document.querySelectorAll('.remove-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const file = btn.dataset.file;
                    const type = btn.dataset.type;
                    if (type === 'project') {
                        this.projectFiles.delete(file);
                        this.updateProjectList();
                    } else {
                        this.registryFiles.delete(file);
                        this.updateRegistryList();
                    }
                });
            });
        }

        setPhase(num) {
            this.phases.forEach((p, i) => {
                p.classList.remove('active', 'completed');
                if (i < num - 1) p.classList.add('completed');
                else if (i === num - 1) p.classList.add('active');
            });
        }

        async analyze() {
            const entry = this.entryFunc.value.trim();
            const target = this.targetFunc.value.trim();

            if (!entry || !target) {
                alert('Please specify entry and target functions');
                return;
            }

            // Show loading
            this.treeSvg.innerHTML = `
                <foreignObject x="0" y="0" width="100%" height="100%">
                    <div class="loading" xmlns="http://www.w3.org/1999/xhtml">
                        <div class="spinner"></div>
                        <p>Analyzing code...</p>
                    </div>
                </foreignObject>
            `;

            await new Promise(r => setTimeout(r, 50));

            try {
                // PHASE 1: Dependency Resolution
                this.setPhase(1);
                this.depResolver = new DependencyResolver();
                
                // Set include paths
                const incPaths = this.includePaths.value.split(',').map(p => p.trim()).filter(p => p);
                this.depResolver.setIncludePaths(incPaths);

                // Add all files
                for (const [name, content] of this.projectFiles) {
                    this.depResolver.files.set(name, content);
                }

                // Parse Makefile if present and enabled
                if (document.getElementById('optMakefile').checked) {
                    for (const [name, content] of this.projectFiles) {
                        if (name.toLowerCase() === 'makefile' || name.endsWith('.mk')) {
                            this.depResolver.parseMakefile(content);
                        }
                    }
                }

                // Resolve dependencies
                if (document.getElementById('optRecursive').checked) {
                    this.depResolver.resolveAllDependencies();
                }

                await new Promise(r => setTimeout(r, 50));

                // PHASE 2: Function Registry
                this.setPhase(2);
                this.funcRegistry = new FunctionRegistry();

                if (document.getElementById('optRegistry').checked) {
                    for (const [name, content] of this.registryFiles) {
                        this.funcRegistry.loadFromJSON(content);
                    }
                }

                await new Promise(r => setTimeout(r, 50));

                // PHASE 3: Code Analysis
                this.setPhase(3);
                this.analyzer = new AdvancedCodeAnalyzer(this.depResolver, this.funcRegistry);

                // Parse headers first
                for (const [name, content] of this.projectFiles) {
                    const ext = name.split('.').pop().toLowerCase();
                    if (['h', 'hpp', 'hh'].includes(ext)) {
                        this.analyzer.parseFile(name, content);
                    }
                }

                // Parse source files
                for (const [name, content] of this.projectFiles) {
                    const ext = name.split('.').pop().toLowerCase();
                    if (['c', 'cpp', 'cc'].includes(ext)) {
                        this.analyzer.parseFile(name, content);
                    }
                }

                this.analyzer.finalize();

                await new Promise(r => setTimeout(r, 50));

                // PHASE 4: Call Tracing
                this.setPhase(4);

                // Check entry exists
                if (!this.analyzer.functions.has(entry)) {
                    this.analyzer.addLog('error', `Entry function <code>${entry}</code> not found`);
                    const funcs = [...this.analyzer.functions.keys()].slice(0, 15);
                    this.analyzer.addLog('info', `Available: ${funcs.join(', ')}...`);
                }

                // Build tree
                const result = this.analyzer.buildTree(entry, target);
                this.treeData = result;

                // Update UI
                this.updateStats();
                this.renderDependencies();
                this.renderRegistry();
                this.renderLog();

                if (result) {
                    this.renderTree(result.tree);
                    this.renderTextTree(result.tree);
                    this.renderPaths(result.paths);
                } else {
                    this.treeSvg.innerHTML = `
                        <foreignObject x="0" y="0" width="100%" height="100%">
                            <div class="error-msg" xmlns="http://www.w3.org/1999/xhtml">
                                <h3>No Path Found</h3>
                                <p>Could not trace from "${entry}" to "${target}"</p>
                                <p>Check the Analysis Log for details.</p>
                            </div>
                        </foreignObject>
                    `;
                }

                this.statsCard.style.display = 'block';

            } catch (error) {
                console.error(error);
                this.treeSvg.innerHTML = `
                    <foreignObject x="0" y="0" width="100%" height="100%">
                        <div class="error-msg" xmlns="http://www.w3.org/1999/xhtml">
                            <h3>Analysis Error</h3>
                            <p>${error.message}</p>
                        </div>
                    </foreignObject>
                `;
            }
        }

        updateStats() {
            document.getElementById('statFiles').textContent = this.analyzer.stats.files;
            document.getElementById('statFuncs').textContent = this.analyzer.stats.functions;
            document.getElementById('statHeaders').textContent = this.analyzer.stats.headers;
            document.getElementById('statMacros').textContent = this.analyzer.stats.macros;
            document.getElementById('statPaths').textContent = this.analyzer.stats.paths;
            document.getElementById('statDepth').textContent = this.analyzer.stats.maxDepth;
        }

        renderTree(root) {
            const width = this.treeSvg.clientWidth || 800;
            const nodeW = 160, nodeH = 44, levelH = 90, spacing = 15;

            const levels = [];
            const assignLevels = (node, level) => {
                if (!levels[level]) levels[level] = [];
                node.level = level;
                levels[level].push(node);
                for (const child of node.children || []) assignLevels(child, level + 1);
            };
            assignLevels(root, 0);

            for (let i = 0; i < levels.length; i++) {
                const nodes = levels[i];
                const totalW = nodes.length * nodeW + (nodes.length - 1) * spacing;
                const startX = (width - totalW) / 2;
                for (let j = 0; j < nodes.length; j++) {
                    nodes[j].x = startX + j * (nodeW + spacing) + nodeW / 2;
                    nodes[j].y = 60 + i * levelH;
                }
            }

            let svg = `
                <defs>
                    <marker id="arr" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
                        <polygon points="0 0, 8 3, 0 6" fill="#00d4ff"/>
                    </marker>
                    <marker id="arr-m" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
                        <polygon points="0 0, 8 3, 0 6" fill="#ec4899"/>
                    </marker>
                    <marker id="arr-p" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
                        <polygon points="0 0, 8 3, 0 6" fill="#3b82f6"/>
                    </marker>
                    <marker id="arr-r" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
                        <polygon points="0 0, 8 3, 0 6" fill="#eab308"/>
                    </marker>
                </defs>
                <g id="treeGroup">
            `;

            const colors = {
                entry: { bg: 'rgba(0,212,255,0.2)', border: '#00d4ff', text: '#00d4ff' },
                target: { bg: 'rgba(16,185,129,0.2)', border: '#10b981', text: '#10b981' },
                intermediate: { bg: 'rgba(168,85,247,0.2)', border: '#a855f7', text: '#a855f7' },
                external: { bg: 'rgba(245,158,11,0.2)', border: '#f59e0b', text: '#f59e0b' },
                registry: { bg: 'rgba(234,179,8,0.2)', border: '#eab308', text: '#eab308' },
                macro: { bg: 'rgba(236,72,153,0.2)', border: '#ec4899', text: '#ec4899' },
                pointer: { bg: 'rgba(59,130,246,0.2)', border: '#3b82f6', text: '#3b82f6' }
            };

            const drawEdges = (node) => {
                for (const child of node.children || []) {
                    let stroke = '#00d4ff', marker = 'url(#arr)', dash = 'none';
                    if (child.callType === 'macro' || child.callType === 'macro-expansion') {
                        stroke = '#ec4899'; marker = 'url(#arr-m)'; dash = '4,4';
                    } else if (child.callType === 'pointer' || child.callType === 'callback') {
                        stroke = '#3b82f6'; marker = 'url(#arr-p)'; dash = '4,4';
                    } else if (child.callType === 'registry') {
                        stroke = '#eab308'; marker = 'url(#arr-r)';
                    }

                    const midY = (node.y + child.y) / 2;
                    svg += `<path d="M${node.x} ${node.y + nodeH/2} Q${node.x} ${midY}, ${(node.x+child.x)/2} ${midY} Q${child.x} ${midY}, ${child.x} ${child.y - nodeH/2}" fill="none" stroke="${stroke}" stroke-width="2" stroke-dasharray="${dash}" marker-end="${marker}" opacity="0.7"/>`;
                    drawEdges(child);
                }
            };
            drawEdges(root);

            const drawNodes = (node) => {
                let c = colors[node.type] || colors.intermediate;
                if (node.callType === 'macro' || node.callType === 'macro-expansion') c = colors.macro;
                else if (node.callType === 'pointer' || node.callType === 'callback') c = colors.pointer;
                if (node.type === 'target') c = colors.target;
                if (node.type === 'entry') c = colors.entry;
                if (node.type === 'registry') c = colors.registry;

                const x = node.x - nodeW/2, y = node.y - nodeH/2;
                const label = node.name.length > 18 ? node.name.slice(0,15) + '...' : node.name;

                svg += `
                    <g class="node">
                        <rect x="${x}" y="${y}" width="${nodeW}" height="${nodeH}" rx="6" fill="${c.bg}" stroke="${c.border}" stroke-width="2"/>
                        <text x="${node.x}" y="${node.y - 3}" text-anchor="middle" fill="${c.text}" font-family="JetBrains Mono" font-size="11" font-weight="600">${label}</text>
                        <text x="${node.x}" y="${node.y + 12}" text-anchor="middle" fill="#606070" font-family="IBM Plex Sans" font-size="9">${node.file}</text>
                    </g>
                `;
                for (const child of node.children || []) drawNodes(child);
            };
            drawNodes(root);

            svg += '</g>';
            this.treeSvg.innerHTML = svg;
            this.resetView();
        }

        renderTextTree(root) {
            let out = '';
            const render = (node, prefix = '', isLast = true) => {
                const conn = isLast ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ ';
                let cls = 'func-intermediate';
                if (node.type === 'entry') cls = 'func-main';
                else if (node.type === 'target') cls = 'func-target';
                else if (node.callType === 'macro' || node.callType === 'macro-expansion') cls = 'func-macro';
                else if (node.callType === 'pointer' || node.callType === 'callback') cls = 'func-pointer';
                else if (node.type === 'registry') cls = 'func-registry';
                else if (node.type === 'external') cls = 'func-external';

                const marker = node.type === 'target' ? ' ‚òÖ' : '';
                const via = node.via ? ` <span class="call-type">[via ${node.via}]</span>` : '';

                out += `${prefix}${conn}<span class="${cls}">${node.name}</span>${marker}${via} <span class="file-ref">[${node.file}]</span>\n`;

                const newPre = prefix + (isLast ? '    ' : '‚îÇ   ');
                const children = node.children || [];
                children.forEach((c, i) => render(c, newPre, i === children.length - 1));
            };
            render(root);
            this.textTab.innerHTML = out;
        }

        renderPaths(paths) {
            let html = '';
            paths.forEach((path, i) => {
                html += `<div class="path-item"><div class="path-header"><span class="path-number">Path ${i + 1}</span><span class="path-meta">Depth: ${path.length}</span></div><div class="path-chain">`;
                path.forEach((step, j) => {
                    let cls = '';
                    if (step.type === 'macro' || step.type === 'macro-expansion') cls = 'macro-call';
                    else if (step.type === 'pointer' || step.type === 'callback') cls = 'pointer-call';
                    else if (step.type === 'registry') cls = 'registry-call';
                    if (j === path.length - 1) cls += ' target';
                    html += `<span class="func ${cls}">${step.name}</span>`;
                    if (j < path.length - 1) html += '<span class="arrow">‚Üí</span>';
                });
                html += '</div></div>';
            });
            this.pathsTab.innerHTML = html || '<p style="color:var(--text-muted);">No paths found</p>';
        }

        renderDependencies() {
            let html = '';
            for (const [file, deps] of this.depResolver.fileDependencies) {
                html += `<div class="dep-file"><div class="dep-file-header">üìÑ ${file}</div><div class="dep-includes">`;
                for (const dep of deps) {
                    const unres = dep.startsWith('[UNRESOLVED]');
                    html += `<div class="dep-include ${unres ? 'unresolved' : ''}">‚Üí ${dep}</div>`;
                }
                html += '</div></div>';
            }
            this.depsTab.innerHTML = html || '<p style="color:var(--text-muted);">No dependencies resolved</p>';
        }

        renderRegistry() {
            let html = '';
            for (const [name, func] of this.funcRegistry.functions) {
                html += `
                    <div class="registry-item">
                        <div class="registry-item-header">
                            <span class="registry-func-name">${name}</span>
                            <span class="registry-badge">Registry</span>
                        </div>
                        <div class="registry-proto">${func.prototype || 'No prototype'}</div>
                        <div class="registry-meta">
                            <div class="registry-meta-item"><strong>Return:</strong> ${func.returnType}</div>
                            <div class="registry-meta-item"><strong>Args:</strong> ${func.arguments.length}</div>
                            <div class="registry-meta-item"><strong>Callbacks:</strong> ${func.callbacks.length}</div>
                            <div class="registry-meta-item"><strong>File:</strong> ${func.file || 'N/A'}</div>
                        </div>
                    </div>
                `;
            }
            this.registryTab.innerHTML = html || '<p style="color:var(--text-muted);">No registry loaded</p>';
        }

        renderLog() {
            let html = '';
            const allLogs = [
                ...this.depResolver.log,
                ...this.funcRegistry.log,
                ...this.analyzer.log
            ];
            for (const entry of allLogs) {
                html += `<div class="log-entry"><span class="log-type ${entry.type}">${entry.type.toUpperCase()}</span><span class="log-msg">${entry.message}</span></div>`;
            }
            this.logTab.innerHTML = html || '<p style="color:var(--text-muted);">No log entries</p>';
        }

        switchTab(tab) {
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === tab);
            });
            document.getElementById('visualTab').style.display = tab === 'visual' ? 'block' : 'none';
            this.textTab.style.display = tab === 'text' ? 'block' : 'none';
            this.pathsTab.style.display = tab === 'paths' ? 'block' : 'none';
            this.depsTab.style.display = tab === 'deps' ? 'block' : 'none';
            this.registryTab.style.display = tab === 'registry' ? 'block' : 'none';
            this.logTab.style.display = tab === 'log' ? 'block' : 'none';
        }

        zoom(factor) {
            this.transform.scale = Math.max(0.1, Math.min(3, this.transform.scale * factor));
            this.updateTransform();
        }

        resetView() {
            this.transform = { x: 0, y: 0, scale: 1 };
            this.updateTransform();
        }

        updateTransform() {
            const g = document.getElementById('treeGroup');
            if (g) g.setAttribute('transform', `translate(${this.transform.x},${this.transform.y}) scale(${this.transform.scale})`);
        }

        exportSvg() {
            const svg = this.treeSvg.outerHTML;
            const blob = new Blob([svg], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'call-trace.svg';
            a.click();
            URL.revokeObjectURL(url);
        }

        clearAll() {
            this.projectFiles.clear();
            this.registryFiles.clear();
            this.updateProjectList();
            this.updateRegistryList();
            this.statsCard.style.display = 'none';
            this.treeSvg.innerHTML = '';
            this.textTab.innerHTML = '';
            this.pathsTab.innerHTML = '';
            this.depsTab.innerHTML = '';
            this.registryTab.innerHTML = '';
            this.logTab.innerHTML = '';
            this.phases.forEach(p => p.classList.remove('active', 'completed'));
        }
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', () => new UIController());
    </script>
</body>
</html>
